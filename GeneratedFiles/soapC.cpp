/* soapC.cpp
   Generated by gSOAP 2.7.13 from VirtualEarth.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.13 2009-04-23 18:16:49 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_in_xsd__byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_ns5__char:
		return soap_in_ns5__char(soap, NULL, NULL, "ns5:char");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_in_xsd__unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedShort:
		return soap_in_unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns16__ItineraryWarningType:
		return soap_in_ns16__ItineraryWarningType(soap, NULL, NULL, "ns16:ItineraryWarningType");
	case SOAP_TYPE_ns16__ItineraryWarningSeverity:
		return soap_in_ns16__ItineraryWarningSeverity(soap, NULL, NULL, "ns16:ItineraryWarningSeverity");
	case SOAP_TYPE_ns16__ManeuverType:
		return soap_in_ns16__ManeuverType(soap, NULL, NULL, "ns16:ManeuverType");
	case SOAP_TYPE_ns16__ItineraryItemHintType:
		return soap_in_ns16__ItineraryItemHintType(soap, NULL, NULL, "ns16:ItineraryItemHintType");
	case SOAP_TYPE_ns16__TrafficUsage:
		return soap_in_ns16__TrafficUsage(soap, NULL, NULL, "ns16:TrafficUsage");
	case SOAP_TYPE_ns16__RoutePathType:
		return soap_in_ns16__RoutePathType(soap, NULL, NULL, "ns16:RoutePathType");
	case SOAP_TYPE_ns16__RouteOptimization:
		return soap_in_ns16__RouteOptimization(soap, NULL, NULL, "ns16:RouteOptimization");
	case SOAP_TYPE_ns16__TravelMode:
		return soap_in_ns16__TravelMode(soap, NULL, NULL, "ns16:TravelMode");
	case SOAP_TYPE_ns6__SortOrder:
		return soap_in_ns6__SortOrder(soap, NULL, NULL, "ns6:SortOrder");
	case SOAP_TYPE_ns6__ListingType:
		return soap_in_ns6__ListingType(soap, NULL, NULL, "ns6:ListingType");
	case SOAP_TYPE_ns4__ImageType:
		return soap_in_ns4__ImageType(soap, NULL, NULL, "ns4:ImageType");
	case SOAP_TYPE_ns4__MapStyle:
		return soap_in_ns4__MapStyle(soap, NULL, NULL, "ns4:MapStyle");
	case SOAP_TYPE_ns4__UriScheme:
		return soap_in_ns4__UriScheme(soap, NULL, NULL, "ns4:UriScheme");
	case SOAP_TYPE_ns4__ResponseStatusCode:
		return soap_in_ns4__ResponseStatusCode(soap, NULL, NULL, "ns4:ResponseStatusCode");
	case SOAP_TYPE_ns4__AuthenticationResultCode:
		return soap_in_ns4__AuthenticationResultCode(soap, NULL, NULL, "ns4:AuthenticationResultCode");
	case SOAP_TYPE_ns4__LogicalOperator:
		return soap_in_ns4__LogicalOperator(soap, NULL, NULL, "ns4:LogicalOperator");
	case SOAP_TYPE_ns4__CompareOperator:
		return soap_in_ns4__CompareOperator(soap, NULL, NULL, "ns4:CompareOperator");
	case SOAP_TYPE_ns4__DistanceUnit:
		return soap_in_ns4__DistanceUnit(soap, NULL, NULL, "ns4:DistanceUnit");
	case SOAP_TYPE_ns4__DeviceType:
		return soap_in_ns4__DeviceType(soap, NULL, NULL, "ns4:DeviceType");
	case SOAP_TYPE_ns4__Confidence:
		return soap_in_ns4__Confidence(soap, NULL, NULL, "ns4:Confidence");
	case SOAP_TYPE_ns1__DistanceUnit:
		return soap_in_ns1__DistanceUnit(soap, NULL, NULL, "ns1:DistanceUnit");
	case SOAP_TYPE_ns1__DataSourceCapability:
		return soap_in_ns1__DataSourceCapability(soap, NULL, NULL, "ns1:DataSourceCapability");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns16__ItineraryWarningType_:
		return soap_in_ns16__ItineraryWarningType_(soap, NULL, NULL, "ns16:ItineraryWarningType");
	case SOAP_TYPE_ns16__ItineraryWarningSeverity_:
		return soap_in_ns16__ItineraryWarningSeverity_(soap, NULL, NULL, "ns16:ItineraryWarningSeverity");
	case SOAP_TYPE_ns16__ManeuverType_:
		return soap_in_ns16__ManeuverType_(soap, NULL, NULL, "ns16:ManeuverType");
	case SOAP_TYPE_ns16__ItineraryItemHintType_:
		return soap_in_ns16__ItineraryItemHintType_(soap, NULL, NULL, "ns16:ItineraryItemHintType");
	case SOAP_TYPE_ns16__TrafficUsage_:
		return soap_in_ns16__TrafficUsage_(soap, NULL, NULL, "ns16:TrafficUsage");
	case SOAP_TYPE_ns16__RoutePathType_:
		return soap_in_ns16__RoutePathType_(soap, NULL, NULL, "ns16:RoutePathType");
	case SOAP_TYPE_ns16__RouteOptimization_:
		return soap_in_ns16__RouteOptimization_(soap, NULL, NULL, "ns16:RouteOptimization");
	case SOAP_TYPE_ns16__TravelMode_:
		return soap_in_ns16__TravelMode_(soap, NULL, NULL, "ns16:TravelMode");
	case SOAP_TYPE_ns6__SortOrder_:
		return soap_in_ns6__SortOrder_(soap, NULL, NULL, "ns6:SortOrder");
	case SOAP_TYPE_ns6__ListingType_:
		return soap_in_ns6__ListingType_(soap, NULL, NULL, "ns6:ListingType");
	case SOAP_TYPE_ns5__guid__:
		return soap_in_ns5__guid__(soap, NULL, NULL, "ns5:guid");
	case SOAP_TYPE_ns5__duration__:
		return soap_in_ns5__duration__(soap, NULL, NULL, "ns5:duration");
	case SOAP_TYPE_ns5__char__:
		return soap_in_ns5__char__(soap, NULL, NULL, "ns5:char");
	case SOAP_TYPE_ns4__ImageType_:
		return soap_in_ns4__ImageType_(soap, NULL, NULL, "ns4:ImageType");
	case SOAP_TYPE_ns4__MapStyle_:
		return soap_in_ns4__MapStyle_(soap, NULL, NULL, "ns4:MapStyle");
	case SOAP_TYPE_ns4__UriScheme_:
		return soap_in_ns4__UriScheme_(soap, NULL, NULL, "ns4:UriScheme");
	case SOAP_TYPE_ns4__ResponseStatusCode_:
		return soap_in_ns4__ResponseStatusCode_(soap, NULL, NULL, "ns4:ResponseStatusCode");
	case SOAP_TYPE_ns4__AuthenticationResultCode_:
		return soap_in_ns4__AuthenticationResultCode_(soap, NULL, NULL, "ns4:AuthenticationResultCode");
	case SOAP_TYPE_ns4__LogicalOperator_:
		return soap_in_ns4__LogicalOperator_(soap, NULL, NULL, "ns4:LogicalOperator");
	case SOAP_TYPE_ns4__CompareOperator_:
		return soap_in_ns4__CompareOperator_(soap, NULL, NULL, "ns4:CompareOperator");
	case SOAP_TYPE_ns4__DistanceUnit_:
		return soap_in_ns4__DistanceUnit_(soap, NULL, NULL, "ns4:DistanceUnit");
	case SOAP_TYPE_ns4__DeviceType_:
		return soap_in_ns4__DeviceType_(soap, NULL, NULL, "ns4:DeviceType");
	case SOAP_TYPE_ns4__Confidence_:
		return soap_in_ns4__Confidence_(soap, NULL, NULL, "ns4:Confidence");
	case SOAP_TYPE_ns1__DistanceUnit_:
		return soap_in_ns1__DistanceUnit_(soap, NULL, NULL, "ns1:DistanceUnit");
	case SOAP_TYPE_ns1__DataSourceCapability_:
		return soap_in_ns1__DataSourceCapability_(soap, NULL, NULL, "ns1:DataSourceCapability");
	case SOAP_TYPE_ns16__ArrayOfRouteResult:
		return soap_in_ns16__ArrayOfRouteResult(soap, NULL, NULL, "ns16:ArrayOfRouteResult");
	case SOAP_TYPE_ns16__MajorRoutesResponse:
		return soap_in_ns16__MajorRoutesResponse(soap, NULL, NULL, "ns16:MajorRoutesResponse");
	case SOAP_TYPE_ns16__MajorRoutesOptions:
		return soap_in_ns16__MajorRoutesOptions(soap, NULL, NULL, "ns16:MajorRoutesOptions");
	case SOAP_TYPE_ns16__MajorRoutesRequest:
		return soap_in_ns16__MajorRoutesRequest(soap, NULL, NULL, "ns16:MajorRoutesRequest");
	case SOAP_TYPE_ns16__RoutePath:
		return soap_in_ns16__RoutePath(soap, NULL, NULL, "ns16:RoutePath");
	case SOAP_TYPE_ns16__ItineraryItemWarning:
		return soap_in_ns16__ItineraryItemWarning(soap, NULL, NULL, "ns16:ItineraryItemWarning");
	case SOAP_TYPE_ns16__ArrayOfItineraryItemWarning:
		return soap_in_ns16__ArrayOfItineraryItemWarning(soap, NULL, NULL, "ns16:ArrayOfItineraryItemWarning");
	case SOAP_TYPE_ns16__RouteSummary:
		return soap_in_ns16__RouteSummary(soap, NULL, NULL, "ns16:RouteSummary");
	case SOAP_TYPE_ns16__ItineraryItemHint:
		return soap_in_ns16__ItineraryItemHint(soap, NULL, NULL, "ns16:ItineraryItemHint");
	case SOAP_TYPE_ns16__ArrayOfItineraryItemHint:
		return soap_in_ns16__ArrayOfItineraryItemHint(soap, NULL, NULL, "ns16:ArrayOfItineraryItemHint");
	case SOAP_TYPE_ns16__ItineraryItem:
		return soap_in_ns16__ItineraryItem(soap, NULL, NULL, "ns16:ItineraryItem");
	case SOAP_TYPE_ns16__ArrayOfItineraryItem:
		return soap_in_ns16__ArrayOfItineraryItem(soap, NULL, NULL, "ns16:ArrayOfItineraryItem");
	case SOAP_TYPE_ns16__RouteLeg:
		return soap_in_ns16__RouteLeg(soap, NULL, NULL, "ns16:RouteLeg");
	case SOAP_TYPE_ns16__ArrayOfRouteLeg:
		return soap_in_ns16__ArrayOfRouteLeg(soap, NULL, NULL, "ns16:ArrayOfRouteLeg");
	case SOAP_TYPE_ns16__RouteResult:
		return soap_in_ns16__RouteResult(soap, NULL, NULL, "ns16:RouteResult");
	case SOAP_TYPE_ns16__RouteResponse:
		return soap_in_ns16__RouteResponse(soap, NULL, NULL, "ns16:RouteResponse");
	case SOAP_TYPE_ns16__Waypoint:
		return soap_in_ns16__Waypoint(soap, NULL, NULL, "ns16:Waypoint");
	case SOAP_TYPE_ns16__ArrayOfWaypoint:
		return soap_in_ns16__ArrayOfWaypoint(soap, NULL, NULL, "ns16:ArrayOfWaypoint");
	case SOAP_TYPE_ns16__RouteOptions:
		return soap_in_ns16__RouteOptions(soap, NULL, NULL, "ns16:RouteOptions");
	case SOAP_TYPE_ns16__RouteRequest:
		return soap_in_ns16__RouteRequest(soap, NULL, NULL, "ns16:RouteRequest");
	case SOAP_TYPE_ns13__MapUriResponse:
		return soap_in_ns13__MapUriResponse(soap, NULL, NULL, "ns13:MapUriResponse");
	case SOAP_TYPE_ns13__MapUriOptions:
		return soap_in_ns13__MapUriOptions(soap, NULL, NULL, "ns13:MapUriOptions");
	case SOAP_TYPE_ns13__MapUriRequest:
		return soap_in_ns13__MapUriRequest(soap, NULL, NULL, "ns13:MapUriRequest");
	case SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult:
		return soap_in_ns13__ImageryMetadataBirdseyeResult(soap, NULL, NULL, "ns13:ImageryMetadataBirdseyeResult");
	case SOAP_TYPE_ns13__CoverageArea:
		return soap_in_ns13__CoverageArea(soap, NULL, NULL, "ns13:CoverageArea");
	case SOAP_TYPE_ns13__ArrayOfCoverageArea:
		return soap_in_ns13__ArrayOfCoverageArea(soap, NULL, NULL, "ns13:ArrayOfCoverageArea");
	case SOAP_TYPE_ns13__ImageryProvider:
		return soap_in_ns13__ImageryProvider(soap, NULL, NULL, "ns13:ImageryProvider");
	case SOAP_TYPE_ns13__ArrayOfImageryProvider:
		return soap_in_ns13__ArrayOfImageryProvider(soap, NULL, NULL, "ns13:ArrayOfImageryProvider");
	case SOAP_TYPE_ns13__ImageryMetadataResult:
		return soap_in_ns13__ImageryMetadataResult(soap, NULL, NULL, "ns13:ImageryMetadataResult");
	case SOAP_TYPE_ns13__ArrayOfImageryMetadataResult:
		return soap_in_ns13__ArrayOfImageryMetadataResult(soap, NULL, NULL, "ns13:ArrayOfImageryMetadataResult");
	case SOAP_TYPE_ns13__ImageryMetadataResponse:
		return soap_in_ns13__ImageryMetadataResponse(soap, NULL, NULL, "ns13:ImageryMetadataResponse");
	case SOAP_TYPE_ns13__ImageryMetadataOptions:
		return soap_in_ns13__ImageryMetadataOptions(soap, NULL, NULL, "ns13:ImageryMetadataOptions");
	case SOAP_TYPE_ns13__ImageryMetadataRequest:
		return soap_in_ns13__ImageryMetadataRequest(soap, NULL, NULL, "ns13:ImageryMetadataRequest");
	case SOAP_TYPE_ns10__ReverseGeocodeRequest:
		return soap_in_ns10__ReverseGeocodeRequest(soap, NULL, NULL, "ns10:ReverseGeocodeRequest");
	case SOAP_TYPE_ns10__GeocodeResponse:
		return soap_in_ns10__GeocodeResponse(soap, NULL, NULL, "ns10:GeocodeResponse");
	case SOAP_TYPE_ns10__ConfidenceFilter:
		return soap_in_ns10__ConfidenceFilter(soap, NULL, NULL, "ns10:ConfidenceFilter");
	case SOAP_TYPE_ns10__FilterBase:
		return soap_in_ns10__FilterBase(soap, NULL, NULL, "ns10:FilterBase");
	case SOAP_TYPE_ns10__ArrayOfFilterBase:
		return soap_in_ns10__ArrayOfFilterBase(soap, NULL, NULL, "ns10:ArrayOfFilterBase");
	case SOAP_TYPE_ns10__GeocodeOptions:
		return soap_in_ns10__GeocodeOptions(soap, NULL, NULL, "ns10:GeocodeOptions");
	case SOAP_TYPE_ns10__GeocodeRequest:
		return soap_in_ns10__GeocodeRequest(soap, NULL, NULL, "ns10:GeocodeRequest");
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		return soap_in_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, NULL, NULL, "ns7:ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_P9s");
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType:
		return soap_in_ns7__ArrayOfKeyValueOfstringanyType(soap, NULL, NULL, "ns7:ArrayOfKeyValueOfstringanyType");
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6:
		return soap_in_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, NULL, NULL, "ns7:ArrayOfKeyValueOfNeighborhoodintkC8b0tr6");
	case SOAP_TYPE_ns7__ArrayOfanyType:
		return soap_in_ns7__ArrayOfanyType(soap, NULL, NULL, "ns7:ArrayOfanyType");
	case SOAP_TYPE_ns7__ArrayOfstring:
		return soap_in_ns7__ArrayOfstring(soap, NULL, NULL, "ns7:ArrayOfstring");
	case SOAP_TYPE_ns6__SearchPoint:
		return soap_in_ns6__SearchPoint(soap, NULL, NULL, "ns6:SearchPoint");
	case SOAP_TYPE_ns6__PersonSearchResult:
		return soap_in_ns6__PersonSearchResult(soap, NULL, NULL, "ns6:PersonSearchResult");
	case SOAP_TYPE_ns6__ArrayOfNeighborhood:
		return soap_in_ns6__ArrayOfNeighborhood(soap, NULL, NULL, "ns6:ArrayOfNeighborhood");
	case SOAP_TYPE_ns6__CategorySpecificPropertySet:
		return soap_in_ns6__CategorySpecificPropertySet(soap, NULL, NULL, "ns6:CategorySpecificPropertySet");
	case SOAP_TYPE_ns6__ArrayOfCategory:
		return soap_in_ns6__ArrayOfCategory(soap, NULL, NULL, "ns6:ArrayOfCategory");
	case SOAP_TYPE_ns6__BusinessSearchResult:
		return soap_in_ns6__BusinessSearchResult(soap, NULL, NULL, "ns6:BusinessSearchResult");
	case SOAP_TYPE_ns6__CommunityContentSearchResult:
		return soap_in_ns6__CommunityContentSearchResult(soap, NULL, NULL, "ns6:CommunityContentSearchResult");
	case SOAP_TYPE_ns6__LocationData:
		return soap_in_ns6__LocationData(soap, NULL, NULL, "ns6:LocationData");
	case SOAP_TYPE_ns6__SearchResultBase:
		return soap_in_ns6__SearchResultBase(soap, NULL, NULL, "ns6:SearchResultBase");
	case SOAP_TYPE_ns6__ArrayOfSearchResultBase:
		return soap_in_ns6__ArrayOfSearchResultBase(soap, NULL, NULL, "ns6:ArrayOfSearchResultBase");
	case SOAP_TYPE_ns6__Parse:
		return soap_in_ns6__Parse(soap, NULL, NULL, "ns6:Parse");
	case SOAP_TYPE_ns6__CategoryCount:
		return soap_in_ns6__CategoryCount(soap, NULL, NULL, "ns6:CategoryCount");
	case SOAP_TYPE_ns6__ArrayOfCategoryCount:
		return soap_in_ns6__ArrayOfCategoryCount(soap, NULL, NULL, "ns6:ArrayOfCategoryCount");
	case SOAP_TYPE_ns6__FilterValue:
		return soap_in_ns6__FilterValue(soap, NULL, NULL, "ns6:FilterValue");
	case SOAP_TYPE_ns6__Category:
		return soap_in_ns6__Category(soap, NULL, NULL, "ns6:Category");
	case SOAP_TYPE_ns6__Neighborhood:
		return soap_in_ns6__Neighborhood(soap, NULL, NULL, "ns6:Neighborhood");
	case SOAP_TYPE_ns6__ValueListFilter:
		return soap_in_ns6__ValueListFilter(soap, NULL, NULL, "ns6:ValueListFilter");
	case SOAP_TYPE_ns6__RangeFilter:
		return soap_in_ns6__RangeFilter(soap, NULL, NULL, "ns6:RangeFilter");
	case SOAP_TYPE_ns6__AvailableFilter:
		return soap_in_ns6__AvailableFilter(soap, NULL, NULL, "ns6:AvailableFilter");
	case SOAP_TYPE_ns6__ArrayOfAvailableFilter:
		return soap_in_ns6__ArrayOfAvailableFilter(soap, NULL, NULL, "ns6:ArrayOfAvailableFilter");
	case SOAP_TYPE_ns6__SearchRegion:
		return soap_in_ns6__SearchRegion(soap, NULL, NULL, "ns6:SearchRegion");
	case SOAP_TYPE_ns6__ArrayOfSearchRegion:
		return soap_in_ns6__ArrayOfSearchRegion(soap, NULL, NULL, "ns6:ArrayOfSearchRegion");
	case SOAP_TYPE_ns6__SearchResultSet:
		return soap_in_ns6__SearchResultSet(soap, NULL, NULL, "ns6:SearchResultSet");
	case SOAP_TYPE_ns6__ArrayOfSearchResultSet:
		return soap_in_ns6__ArrayOfSearchResultSet(soap, NULL, NULL, "ns6:ArrayOfSearchResultSet");
	case SOAP_TYPE_ns6__QuerySuggestion:
		return soap_in_ns6__QuerySuggestion(soap, NULL, NULL, "ns6:QuerySuggestion");
	case SOAP_TYPE_ns6__SearchResponse:
		return soap_in_ns6__SearchResponse(soap, NULL, NULL, "ns6:SearchResponse");
	case SOAP_TYPE_ns6__StructuredSearchQuery:
		return soap_in_ns6__StructuredSearchQuery(soap, NULL, NULL, "ns6:StructuredSearchQuery");
	case SOAP_TYPE_ns6__SearchOptions:
		return soap_in_ns6__SearchOptions(soap, NULL, NULL, "ns6:SearchOptions");
	case SOAP_TYPE_ns6__SearchRequest:
		return soap_in_ns6__SearchRequest(soap, NULL, NULL, "ns6:SearchRequest");
	case SOAP_TYPE_ns4__Pushpin:
		return soap_in_ns4__Pushpin(soap, NULL, NULL, "ns4:Pushpin");
	case SOAP_TYPE_ns4__ArrayOfPushpin:
		return soap_in_ns4__ArrayOfPushpin(soap, NULL, NULL, "ns4:ArrayOfPushpin");
	case SOAP_TYPE_ns4__RangeOfdateTime:
		return soap_in_ns4__RangeOfdateTime(soap, NULL, NULL, "ns4:RangeOfdateTime");
	case SOAP_TYPE_ns4__RangeOfint:
		return soap_in_ns4__RangeOfint(soap, NULL, NULL, "ns4:RangeOfint");
	case SOAP_TYPE_ns4__ArrayOfGeocodeResult:
		return soap_in_ns4__ArrayOfGeocodeResult(soap, NULL, NULL, "ns4:ArrayOfGeocodeResult");
	case SOAP_TYPE_ns4__ArrayOfGeocodeLocation:
		return soap_in_ns4__ArrayOfGeocodeLocation(soap, NULL, NULL, "ns4:ArrayOfGeocodeLocation");
	case SOAP_TYPE_ns4__Address:
		return soap_in_ns4__Address(soap, NULL, NULL, "ns4:Address");
	case SOAP_TYPE_ns4__GeocodeResult:
		return soap_in_ns4__GeocodeResult(soap, NULL, NULL, "ns4:GeocodeResult");
	case SOAP_TYPE_ns4__ResponseSummary:
		return soap_in_ns4__ResponseSummary(soap, NULL, NULL, "ns4:ResponseSummary");
	case SOAP_TYPE_ns4__ResponseBase:
		return soap_in_ns4__ResponseBase(soap, NULL, NULL, "ns4:ResponseBase");
	case SOAP_TYPE_ns4__ArrayOfFilterExpressionBase:
		return soap_in_ns4__ArrayOfFilterExpressionBase(soap, NULL, NULL, "ns4:ArrayOfFilterExpressionBase");
	case SOAP_TYPE_ns4__FilterExpressionClause:
		return soap_in_ns4__FilterExpressionClause(soap, NULL, NULL, "ns4:FilterExpressionClause");
	case SOAP_TYPE_ns4__FilterExpression:
		return soap_in_ns4__FilterExpression(soap, NULL, NULL, "ns4:FilterExpression");
	case SOAP_TYPE_ns4__FilterExpressionBase:
		return soap_in_ns4__FilterExpressionBase(soap, NULL, NULL, "ns4:FilterExpressionBase");
	case SOAP_TYPE_ns4__SizeOfint:
		return soap_in_ns4__SizeOfint(soap, NULL, NULL, "ns4:SizeOfint");
	case SOAP_TYPE_ns4__ArrayOfLocation:
		return soap_in_ns4__ArrayOfLocation(soap, NULL, NULL, "ns4:ArrayOfLocation");
	case SOAP_TYPE_ns4__Polygon:
		return soap_in_ns4__Polygon(soap, NULL, NULL, "ns4:Polygon");
	case SOAP_TYPE_ns4__Circle:
		return soap_in_ns4__Circle(soap, NULL, NULL, "ns4:Circle");
	case SOAP_TYPE_ns4__Rectangle:
		return soap_in_ns4__Rectangle(soap, NULL, NULL, "ns4:Rectangle");
	case SOAP_TYPE_ns4__ShapeBase:
		return soap_in_ns4__ShapeBase(soap, NULL, NULL, "ns4:ShapeBase");
	case SOAP_TYPE_ns4__GeocodeLocation:
		return soap_in_ns4__GeocodeLocation(soap, NULL, NULL, "ns4:GeocodeLocation");
	case SOAP_TYPE_ns4__Location:
		return soap_in_ns4__Location(soap, NULL, NULL, "ns4:Location");
	case SOAP_TYPE_ns4__UserLocation:
		return soap_in_ns4__UserLocation(soap, NULL, NULL, "ns4:UserLocation");
	case SOAP_TYPE_ns4__Heading:
		return soap_in_ns4__Heading(soap, NULL, NULL, "ns4:Heading");
	case SOAP_TYPE_ns4__UserProfile:
		return soap_in_ns4__UserProfile(soap, NULL, NULL, "ns4:UserProfile");
	case SOAP_TYPE_ns4__ExecutionOptions:
		return soap_in_ns4__ExecutionOptions(soap, NULL, NULL, "ns4:ExecutionOptions");
	case SOAP_TYPE_ns4__Credentials:
		return soap_in_ns4__Credentials(soap, NULL, NULL, "ns4:Credentials");
	case SOAP_TYPE_ns4__RequestBase:
		return soap_in_ns4__RequestBase(soap, NULL, NULL, "ns4:RequestBase");
	case SOAP_TYPE_ns1__TokenSpecification:
		return soap_in_ns1__TokenSpecification(soap, NULL, NULL, "ns1:TokenSpecification");
	case SOAP_TYPE_ns1__ArrayOfDouble:
		return soap_in_ns1__ArrayOfDouble(soap, NULL, NULL, "ns1:ArrayOfDouble");
	case SOAP_TYPE_ns1__ArrayOfLatLong:
		return soap_in_ns1__ArrayOfLatLong(soap, NULL, NULL, "ns1:ArrayOfLatLong");
	case SOAP_TYPE_ns1__DataSource:
		return soap_in_ns1__DataSource(soap, NULL, NULL, "ns1:DataSource");
	case SOAP_TYPE_ns1__ArrayOfDataSource:
		return soap_in_ns1__ArrayOfDataSource(soap, NULL, NULL, "ns1:ArrayOfDataSource");
	case SOAP_TYPE_ns1__ArrayOfString:
		return soap_in_ns1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__EntityProperty:
		return soap_in_ns1__EntityProperty(soap, NULL, NULL, "ns1:EntityProperty");
	case SOAP_TYPE_ns1__ArrayOfEntityProperty:
		return soap_in_ns1__ArrayOfEntityProperty(soap, NULL, NULL, "ns1:ArrayOfEntityProperty");
	case SOAP_TYPE_ns1__EntityType:
		return soap_in_ns1__EntityType(soap, NULL, NULL, "ns1:EntityType");
	case SOAP_TYPE_ns1__ArrayOfEntityType:
		return soap_in_ns1__ArrayOfEntityType(soap, NULL, NULL, "ns1:ArrayOfEntityType");
	case SOAP_TYPE_ns1__LatLong:
		return soap_in_ns1__LatLong(soap, NULL, NULL, "ns1:LatLong");
	case SOAP_TYPE_ns1__CountryRegionInfo:
		return soap_in_ns1__CountryRegionInfo(soap, NULL, NULL, "ns1:CountryRegionInfo");
	case SOAP_TYPE_ns1__ArrayOfCountryRegionInfo:
		return soap_in_ns1__ArrayOfCountryRegionInfo(soap, NULL, NULL, "ns1:ArrayOfCountryRegionInfo");
	case SOAP_TYPE_ns1__ArrayOfInt:
		return soap_in_ns1__ArrayOfInt(soap, NULL, NULL, "ns1:ArrayOfInt");
	case SOAP_TYPE_ns1__CountryRegionContext:
		return soap_in_ns1__CountryRegionContext(soap, NULL, NULL, "ns1:CountryRegionContext");
	case SOAP_TYPE_ns1__CultureInfo:
		return soap_in_ns1__CultureInfo(soap, NULL, NULL, "ns1:CultureInfo");
	case SOAP_TYPE_ns1__UserInfoHeader:
		return soap_in_ns1__UserInfoHeader(soap, NULL, NULL, "ns1:UserInfoHeader");
	case SOAP_TYPE_ns1__CustomerInfoHeader:
		return soap_in_ns1__CustomerInfoHeader(soap, NULL, NULL, "ns1:CustomerInfoHeader");
	case SOAP_TYPE_ns1__VersionInfo:
		return soap_in_ns1__VersionInfo(soap, NULL, NULL, "ns1:VersionInfo");
	case SOAP_TYPE_ns1__ArrayOfVersionInfo:
		return soap_in_ns1__ArrayOfVersionInfo(soap, NULL, NULL, "ns1:ArrayOfVersionInfo");
	case SOAP_TYPE_xsd__unsignedShort:
		return soap_in_xsd__unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_xsd__unsignedLong:
		return soap_in_xsd__unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_in_xsd__unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedByte_:
		return soap_in_xsd__unsignedByte_(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__string:
		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__short:
		return soap_in_xsd__short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_xsd__long:
		return soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__float:
		return soap_in_xsd__float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_xsd__duration_:
		return soap_in_xsd__duration_(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_xsd__double:
		return soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_xsd__decimal_:
		return soap_in_xsd__decimal_(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__byte_:
		return soap_in_xsd__byte_(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__base64Binary_:
		return soap_in_xsd__base64Binary_(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI_:
		return soap_in_xsd__anyURI_(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTo_ns3__SearchResponse:
		return soap_in_PointerTo_ns3__SearchResponse(soap, NULL, NULL, "ns3:SearchResponse");
	case SOAP_TYPE_PointerTo_ns3__Search:
		return soap_in_PointerTo_ns3__Search(soap, NULL, NULL, "ns3:Search");
	case SOAP_TYPE_PointerTo_ns15__CalculateRoutesFromMajorRoadsResponse:
		return soap_in_PointerTo_ns15__CalculateRoutesFromMajorRoadsResponse(soap, NULL, NULL, "ns15:CalculateRoutesFromMajorRoadsResponse");
	case SOAP_TYPE_PointerTo_ns15__CalculateRoutesFromMajorRoads:
		return soap_in_PointerTo_ns15__CalculateRoutesFromMajorRoads(soap, NULL, NULL, "ns15:CalculateRoutesFromMajorRoads");
	case SOAP_TYPE_PointerTo_ns15__CalculateRouteResponse:
		return soap_in_PointerTo_ns15__CalculateRouteResponse(soap, NULL, NULL, "ns15:CalculateRouteResponse");
	case SOAP_TYPE_PointerTo_ns15__CalculateRoute:
		return soap_in_PointerTo_ns15__CalculateRoute(soap, NULL, NULL, "ns15:CalculateRoute");
	case SOAP_TYPE_PointerTo_ns12__GetMapUriResponse:
		return soap_in_PointerTo_ns12__GetMapUriResponse(soap, NULL, NULL, "ns12:GetMapUriResponse");
	case SOAP_TYPE_PointerTo_ns12__GetMapUri:
		return soap_in_PointerTo_ns12__GetMapUri(soap, NULL, NULL, "ns12:GetMapUri");
	case SOAP_TYPE_PointerTo_ns12__GetImageryMetadataResponse:
		return soap_in_PointerTo_ns12__GetImageryMetadataResponse(soap, NULL, NULL, "ns12:GetImageryMetadataResponse");
	case SOAP_TYPE_PointerTo_ns12__GetImageryMetadata:
		return soap_in_PointerTo_ns12__GetImageryMetadata(soap, NULL, NULL, "ns12:GetImageryMetadata");
	case SOAP_TYPE_PointerTo_ns9__ReverseGeocodeResponse:
		return soap_in_PointerTo_ns9__ReverseGeocodeResponse(soap, NULL, NULL, "ns9:ReverseGeocodeResponse");
	case SOAP_TYPE_PointerTo_ns9__ReverseGeocode:
		return soap_in_PointerTo_ns9__ReverseGeocode(soap, NULL, NULL, "ns9:ReverseGeocode");
	case SOAP_TYPE_PointerTo_ns9__GeocodeResponse:
		return soap_in_PointerTo_ns9__GeocodeResponse(soap, NULL, NULL, "ns9:GeocodeResponse");
	case SOAP_TYPE_PointerTo_ns9__Geocode:
		return soap_in_PointerTo_ns9__Geocode(soap, NULL, NULL, "ns9:Geocode");
	case SOAP_TYPE_PointerTo_ns1__GetClientTokenResponse:
		return soap_in_PointerTo_ns1__GetClientTokenResponse(soap, NULL, NULL, "ns1:GetClientTokenResponse");
	case SOAP_TYPE_PointerTo_ns1__GetClientToken:
		return soap_in_PointerTo_ns1__GetClientToken(soap, NULL, NULL, "ns1:GetClientToken");
	case SOAP_TYPE_PointerTo_ns1__GetGreatCircleDistancesResponse:
		return soap_in_PointerTo_ns1__GetGreatCircleDistancesResponse(soap, NULL, NULL, "ns1:GetGreatCircleDistancesResponse");
	case SOAP_TYPE_PointerTo_ns1__GetGreatCircleDistances:
		return soap_in_PointerTo_ns1__GetGreatCircleDistances(soap, NULL, NULL, "ns1:GetGreatCircleDistances");
	case SOAP_TYPE_PointerTo_ns1__GetDataSourceInfoResponse:
		return soap_in_PointerTo_ns1__GetDataSourceInfoResponse(soap, NULL, NULL, "ns1:GetDataSourceInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetDataSourceInfo:
		return soap_in_PointerTo_ns1__GetDataSourceInfo(soap, NULL, NULL, "ns1:GetDataSourceInfo");
	case SOAP_TYPE_PointerTo_ns1__GetEntityTypesResponse:
		return soap_in_PointerTo_ns1__GetEntityTypesResponse(soap, NULL, NULL, "ns1:GetEntityTypesResponse");
	case SOAP_TYPE_PointerTo_ns1__GetEntityTypes:
		return soap_in_PointerTo_ns1__GetEntityTypes(soap, NULL, NULL, "ns1:GetEntityTypes");
	case SOAP_TYPE_PointerTo_ns1__GetCountryRegionInfoResponse:
		return soap_in_PointerTo_ns1__GetCountryRegionInfoResponse(soap, NULL, NULL, "ns1:GetCountryRegionInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetCountryRegionInfo:
		return soap_in_PointerTo_ns1__GetCountryRegionInfo(soap, NULL, NULL, "ns1:GetCountryRegionInfo");
	case SOAP_TYPE_PointerTo_ns1__GetVersionInfoResponse:
		return soap_in_PointerTo_ns1__GetVersionInfoResponse(soap, NULL, NULL, "ns1:GetVersionInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetVersionInfo:
		return soap_in_PointerTo_ns1__GetVersionInfo(soap, NULL, NULL, "ns1:GetVersionInfo");
	case SOAP_TYPE_PointerTons1__UserInfoHeader:
		return soap_in_PointerTons1__UserInfoHeader(soap, NULL, NULL, "ns1:UserInfoHeader");
	case SOAP_TYPE_PointerTons1__CustomerInfoHeader:
		return soap_in_PointerTons1__CustomerInfoHeader(soap, NULL, NULL, "ns1:CustomerInfoHeader");
	case SOAP_TYPE_PointerTons16__ArrayOfRouteResult:
		return soap_in_PointerTons16__ArrayOfRouteResult(soap, NULL, NULL, "ns16:ArrayOfRouteResult");
	case SOAP_TYPE_PointerTons16__MajorRoutesOptions:
		return soap_in_PointerTons16__MajorRoutesOptions(soap, NULL, NULL, "ns16:MajorRoutesOptions");
	case SOAP_TYPE_PointerTons16__ArrayOfWaypoint:
		return soap_in_PointerTons16__ArrayOfWaypoint(soap, NULL, NULL, "ns16:ArrayOfWaypoint");
	case SOAP_TYPE_PointerTons16__RouteOptions:
		return soap_in_PointerTons16__RouteOptions(soap, NULL, NULL, "ns16:RouteOptions");
	case SOAP_TYPE_PointerTons4__ArrayOfPushpin:
		return soap_in_PointerTons4__ArrayOfPushpin(soap, NULL, NULL, "ns4:ArrayOfPushpin");
	case SOAP_TYPE_PointerTons13__MapUriOptions:
		return soap_in_PointerTons13__MapUriOptions(soap, NULL, NULL, "ns13:MapUriOptions");
	case SOAP_TYPE_PointerTons13__ArrayOfImageryMetadataResult:
		return soap_in_PointerTons13__ArrayOfImageryMetadataResult(soap, NULL, NULL, "ns13:ArrayOfImageryMetadataResult");
	case SOAP_TYPE_PointerTons13__ImageryMetadataOptions:
		return soap_in_PointerTons13__ImageryMetadataOptions(soap, NULL, NULL, "ns13:ImageryMetadataOptions");
	case SOAP_TYPE_PointerTons4__ArrayOfGeocodeResult:
		return soap_in_PointerTons4__ArrayOfGeocodeResult(soap, NULL, NULL, "ns4:ArrayOfGeocodeResult");
	case SOAP_TYPE_PointerTons10__GeocodeOptions:
		return soap_in_PointerTons10__GeocodeOptions(soap, NULL, NULL, "ns10:GeocodeOptions");
	case SOAP_TYPE_PointerTons6__ArrayOfNeighborhood:
		return soap_in_PointerTons6__ArrayOfNeighborhood(soap, NULL, NULL, "ns6:ArrayOfNeighborhood");
	case SOAP_TYPE_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		return soap_in_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, NULL, NULL, "ns7:ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_P9s");
	case SOAP_TYPE_PointerTons6__ArrayOfCategory:
		return soap_in_PointerTons6__ArrayOfCategory(soap, NULL, NULL, "ns6:ArrayOfCategory");
	case SOAP_TYPE_PointerTons7__ArrayOfanyType:
		return soap_in_PointerTons7__ArrayOfanyType(soap, NULL, NULL, "ns7:ArrayOfanyType");
	case SOAP_TYPE_PointerTons6__ArrayOfSearchResultSet:
		return soap_in_PointerTons6__ArrayOfSearchResultSet(soap, NULL, NULL, "ns6:ArrayOfSearchResultSet");
	case SOAP_TYPE_PointerTons6__QuerySuggestion:
		return soap_in_PointerTons6__QuerySuggestion(soap, NULL, NULL, "ns6:QuerySuggestion");
	case SOAP_TYPE_PointerTons6__SearchOptions:
		return soap_in_PointerTons6__SearchOptions(soap, NULL, NULL, "ns6:SearchOptions");
	case SOAP_TYPE_PointerTons4__LogicalOperator:
		return soap_in_PointerTons4__LogicalOperator(soap, NULL, NULL, "ns4:LogicalOperator");
	case SOAP_TYPE_PointerTons4__ArrayOfFilterExpressionBase:
		return soap_in_PointerTons4__ArrayOfFilterExpressionBase(soap, NULL, NULL, "ns4:ArrayOfFilterExpressionBase");
	case SOAP_TYPE_PointerTons4__CompareOperator:
		return soap_in_PointerTons4__CompareOperator(soap, NULL, NULL, "ns4:CompareOperator");
	case SOAP_TYPE_PointerToPointerTons16__RouteResult:
		return soap_in_PointerToPointerTons16__RouteResult(soap, NULL, NULL, "ns16:RouteResult");
	case SOAP_TYPE_PointerTons16__RouteResult:
		return soap_in_PointerTons16__RouteResult(soap, NULL, NULL, "ns16:RouteResult");
	case SOAP_TYPE_PointerTons4__ArrayOfLocation:
		return soap_in_PointerTons4__ArrayOfLocation(soap, NULL, NULL, "ns4:ArrayOfLocation");
	case SOAP_TYPE_PointerTons16__ItineraryWarningType:
		return soap_in_PointerTons16__ItineraryWarningType(soap, NULL, NULL, "ns16:ItineraryWarningType");
	case SOAP_TYPE_PointerTons16__ItineraryWarningSeverity:
		return soap_in_PointerTons16__ItineraryWarningSeverity(soap, NULL, NULL, "ns16:ItineraryWarningSeverity");
	case SOAP_TYPE_PointerToPointerTons16__ItineraryItemWarning:
		return soap_in_PointerToPointerTons16__ItineraryItemWarning(soap, NULL, NULL, "ns16:ItineraryItemWarning");
	case SOAP_TYPE_PointerTons16__ItineraryItemWarning:
		return soap_in_PointerTons16__ItineraryItemWarning(soap, NULL, NULL, "ns16:ItineraryItemWarning");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerTons16__ItineraryItemHintType:
		return soap_in_PointerTons16__ItineraryItemHintType(soap, NULL, NULL, "ns16:ItineraryItemHintType");
	case SOAP_TYPE_PointerToPointerTons16__ItineraryItemHint:
		return soap_in_PointerToPointerTons16__ItineraryItemHint(soap, NULL, NULL, "ns16:ItineraryItemHint");
	case SOAP_TYPE_PointerTons16__ItineraryItemHint:
		return soap_in_PointerTons16__ItineraryItemHint(soap, NULL, NULL, "ns16:ItineraryItemHint");
	case SOAP_TYPE_PointerTons16__ArrayOfItineraryItemWarning:
		return soap_in_PointerTons16__ArrayOfItineraryItemWarning(soap, NULL, NULL, "ns16:ArrayOfItineraryItemWarning");
	case SOAP_TYPE_PointerTons16__ManeuverType:
		return soap_in_PointerTons16__ManeuverType(soap, NULL, NULL, "ns16:ManeuverType");
	case SOAP_TYPE_PointerTons16__ArrayOfItineraryItemHint:
		return soap_in_PointerTons16__ArrayOfItineraryItemHint(soap, NULL, NULL, "ns16:ArrayOfItineraryItemHint");
	case SOAP_TYPE_PointerToPointerTons16__ItineraryItem:
		return soap_in_PointerToPointerTons16__ItineraryItem(soap, NULL, NULL, "ns16:ItineraryItem");
	case SOAP_TYPE_PointerTons16__ItineraryItem:
		return soap_in_PointerTons16__ItineraryItem(soap, NULL, NULL, "ns16:ItineraryItem");
	case SOAP_TYPE_PointerTons16__ArrayOfItineraryItem:
		return soap_in_PointerTons16__ArrayOfItineraryItem(soap, NULL, NULL, "ns16:ArrayOfItineraryItem");
	case SOAP_TYPE_PointerToPointerTons16__RouteLeg:
		return soap_in_PointerToPointerTons16__RouteLeg(soap, NULL, NULL, "ns16:RouteLeg");
	case SOAP_TYPE_PointerTons16__RouteLeg:
		return soap_in_PointerTons16__RouteLeg(soap, NULL, NULL, "ns16:RouteLeg");
	case SOAP_TYPE_PointerTons16__RouteSummary:
		return soap_in_PointerTons16__RouteSummary(soap, NULL, NULL, "ns16:RouteSummary");
	case SOAP_TYPE_PointerTons16__RoutePath:
		return soap_in_PointerTons16__RoutePath(soap, NULL, NULL, "ns16:RoutePath");
	case SOAP_TYPE_PointerTons16__ArrayOfRouteLeg:
		return soap_in_PointerTons16__ArrayOfRouteLeg(soap, NULL, NULL, "ns16:ArrayOfRouteLeg");
	case SOAP_TYPE_PointerToPointerTons16__Waypoint:
		return soap_in_PointerToPointerTons16__Waypoint(soap, NULL, NULL, "ns16:Waypoint");
	case SOAP_TYPE_PointerTons16__Waypoint:
		return soap_in_PointerTons16__Waypoint(soap, NULL, NULL, "ns16:Waypoint");
	case SOAP_TYPE_PointerTons16__TrafficUsage:
		return soap_in_PointerTons16__TrafficUsage(soap, NULL, NULL, "ns16:TrafficUsage");
	case SOAP_TYPE_PointerTons16__RoutePathType:
		return soap_in_PointerTons16__RoutePathType(soap, NULL, NULL, "ns16:RoutePathType");
	case SOAP_TYPE_PointerTons16__RouteOptimization:
		return soap_in_PointerTons16__RouteOptimization(soap, NULL, NULL, "ns16:RouteOptimization");
	case SOAP_TYPE_PointerTons16__TravelMode:
		return soap_in_PointerTons16__TravelMode(soap, NULL, NULL, "ns16:TravelMode");
	case SOAP_TYPE_PointerTons16__MajorRoutesResponse:
		return soap_in_PointerTons16__MajorRoutesResponse(soap, NULL, NULL, "ns16:MajorRoutesResponse");
	case SOAP_TYPE_PointerTons16__MajorRoutesRequest:
		return soap_in_PointerTons16__MajorRoutesRequest(soap, NULL, NULL, "ns16:MajorRoutesRequest");
	case SOAP_TYPE_PointerTons16__RouteResponse:
		return soap_in_PointerTons16__RouteResponse(soap, NULL, NULL, "ns16:RouteResponse");
	case SOAP_TYPE_PointerTons16__RouteRequest:
		return soap_in_PointerTons16__RouteRequest(soap, NULL, NULL, "ns16:RouteRequest");
	case SOAP_TYPE_PointerTons4__MapStyle:
		return soap_in_PointerTons4__MapStyle(soap, NULL, NULL, "ns4:MapStyle");
	case SOAP_TYPE_PointerTons4__ImageType:
		return soap_in_PointerTons4__ImageType(soap, NULL, NULL, "ns4:ImageType");
	case SOAP_TYPE_PointerToPointerTons13__CoverageArea:
		return soap_in_PointerToPointerTons13__CoverageArea(soap, NULL, NULL, "ns13:CoverageArea");
	case SOAP_TYPE_PointerTons13__CoverageArea:
		return soap_in_PointerTons13__CoverageArea(soap, NULL, NULL, "ns13:CoverageArea");
	case SOAP_TYPE_PointerTons13__ArrayOfCoverageArea:
		return soap_in_PointerTons13__ArrayOfCoverageArea(soap, NULL, NULL, "ns13:ArrayOfCoverageArea");
	case SOAP_TYPE_PointerToPointerTons13__ImageryProvider:
		return soap_in_PointerToPointerTons13__ImageryProvider(soap, NULL, NULL, "ns13:ImageryProvider");
	case SOAP_TYPE_PointerTons13__ImageryProvider:
		return soap_in_PointerTons13__ImageryProvider(soap, NULL, NULL, "ns13:ImageryProvider");
	case SOAP_TYPE_PointerTons4__RangeOfint:
		return soap_in_PointerTons4__RangeOfint(soap, NULL, NULL, "ns4:RangeOfint");
	case SOAP_TYPE_PointerTons4__RangeOfdateTime:
		return soap_in_PointerTons4__RangeOfdateTime(soap, NULL, NULL, "ns4:RangeOfdateTime");
	case SOAP_TYPE_PointerTons13__ArrayOfImageryProvider:
		return soap_in_PointerTons13__ArrayOfImageryProvider(soap, NULL, NULL, "ns13:ArrayOfImageryProvider");
	case SOAP_TYPE_PointerToPointerTons13__ImageryMetadataResult:
		return soap_in_PointerToPointerTons13__ImageryMetadataResult(soap, NULL, NULL, "ns13:ImageryMetadataResult");
	case SOAP_TYPE_PointerTons13__ImageryMetadataResult:
		return soap_in_PointerTons13__ImageryMetadataResult(soap, NULL, NULL, "ns13:ImageryMetadataResult");
	case SOAP_TYPE_PointerTons4__UriScheme:
		return soap_in_PointerTons4__UriScheme(soap, NULL, NULL, "ns4:UriScheme");
	case SOAP_TYPE_PointerTons13__MapUriResponse:
		return soap_in_PointerTons13__MapUriResponse(soap, NULL, NULL, "ns13:MapUriResponse");
	case SOAP_TYPE_PointerTons13__MapUriRequest:
		return soap_in_PointerTons13__MapUriRequest(soap, NULL, NULL, "ns13:MapUriRequest");
	case SOAP_TYPE_PointerTons13__ImageryMetadataResponse:
		return soap_in_PointerTons13__ImageryMetadataResponse(soap, NULL, NULL, "ns13:ImageryMetadataResponse");
	case SOAP_TYPE_PointerTons13__ImageryMetadataRequest:
		return soap_in_PointerTons13__ImageryMetadataRequest(soap, NULL, NULL, "ns13:ImageryMetadataRequest");
	case SOAP_TYPE_PointerToPointerTons10__FilterBase:
		return soap_in_PointerToPointerTons10__FilterBase(soap, NULL, NULL, "ns10:FilterBase");
	case SOAP_TYPE_PointerTons10__FilterBase:
		return soap_in_PointerTons10__FilterBase(soap, NULL, NULL, "ns10:FilterBase");
	case SOAP_TYPE_PointerTons10__ArrayOfFilterBase:
		return soap_in_PointerTons10__ArrayOfFilterBase(soap, NULL, NULL, "ns10:ArrayOfFilterBase");
	case SOAP_TYPE_PointerTons10__ReverseGeocodeRequest:
		return soap_in_PointerTons10__ReverseGeocodeRequest(soap, NULL, NULL, "ns10:ReverseGeocodeRequest");
	case SOAP_TYPE_PointerTons10__GeocodeResponse:
		return soap_in_PointerTons10__GeocodeResponse(soap, NULL, NULL, "ns10:GeocodeResponse");
	case SOAP_TYPE_PointerTons10__GeocodeRequest:
		return soap_in_PointerTons10__GeocodeRequest(soap, NULL, NULL, "ns10:GeocodeRequest");
	case SOAP_TYPE_PointerTo_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		return soap_in_PointerTo_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, NULL, NULL, "ns7:ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_P9s-KeyValueOfintCategorySpecificPropertySetn6Q9q_P9s");
	case SOAP_TYPE_PointerTons6__CategorySpecificPropertySet:
		return soap_in_PointerTons6__CategorySpecificPropertySet(soap, NULL, NULL, "ns6:CategorySpecificPropertySet");
	case SOAP_TYPE_PointerTo_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType:
		return soap_in_PointerTo_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(soap, NULL, NULL, "ns7:ArrayOfKeyValueOfstringanyType-KeyValueOfstringanyType");
	case SOAP_TYPE_PointerTo_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6:
		return soap_in_PointerTo_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(soap, NULL, NULL, "ns7:ArrayOfKeyValueOfNeighborhoodintkC8b0tr6-KeyValueOfNeighborhoodintkC8b0tr6");
	case SOAP_TYPE_PointerToPointerToxsd__anyType:
		return soap_in_PointerToPointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerToPointerTons6__Neighborhood:
		return soap_in_PointerToPointerTons6__Neighborhood(soap, NULL, NULL, "ns6:Neighborhood");
	case SOAP_TYPE_PointerTons6__Neighborhood:
		return soap_in_PointerTons6__Neighborhood(soap, NULL, NULL, "ns6:Neighborhood");
	case SOAP_TYPE_PointerTons7__ArrayOfKeyValueOfstringanyType:
		return soap_in_PointerTons7__ArrayOfKeyValueOfstringanyType(soap, NULL, NULL, "ns7:ArrayOfKeyValueOfstringanyType");
	case SOAP_TYPE_PointerToPointerTons6__Category:
		return soap_in_PointerToPointerTons6__Category(soap, NULL, NULL, "ns6:Category");
	case SOAP_TYPE_PointerTons6__LocationData:
		return soap_in_PointerTons6__LocationData(soap, NULL, NULL, "ns6:LocationData");
	case SOAP_TYPE_PointerToPointerTons6__SearchResultBase:
		return soap_in_PointerToPointerTons6__SearchResultBase(soap, NULL, NULL, "ns6:SearchResultBase");
	case SOAP_TYPE_PointerTons6__SearchResultBase:
		return soap_in_PointerTons6__SearchResultBase(soap, NULL, NULL, "ns6:SearchResultBase");
	case SOAP_TYPE_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6:
		return soap_in_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, NULL, NULL, "ns7:ArrayOfKeyValueOfNeighborhoodintkC8b0tr6");
	case SOAP_TYPE_PointerTons6__Category:
		return soap_in_PointerTons6__Category(soap, NULL, NULL, "ns6:Category");
	case SOAP_TYPE_PointerToPointerTons6__CategoryCount:
		return soap_in_PointerToPointerTons6__CategoryCount(soap, NULL, NULL, "ns6:CategoryCount");
	case SOAP_TYPE_PointerTons6__CategoryCount:
		return soap_in_PointerTons6__CategoryCount(soap, NULL, NULL, "ns6:CategoryCount");
	case SOAP_TYPE_PointerToPointerTons6__AvailableFilter:
		return soap_in_PointerToPointerTons6__AvailableFilter(soap, NULL, NULL, "ns6:AvailableFilter");
	case SOAP_TYPE_PointerTons6__AvailableFilter:
		return soap_in_PointerTons6__AvailableFilter(soap, NULL, NULL, "ns6:AvailableFilter");
	case SOAP_TYPE_PointerToPointerTons6__SearchRegion:
		return soap_in_PointerToPointerTons6__SearchRegion(soap, NULL, NULL, "ns6:SearchRegion");
	case SOAP_TYPE_PointerTons6__SearchRegion:
		return soap_in_PointerTons6__SearchRegion(soap, NULL, NULL, "ns6:SearchRegion");
	case SOAP_TYPE_PointerTons6__ArrayOfSearchResultBase:
		return soap_in_PointerTons6__ArrayOfSearchResultBase(soap, NULL, NULL, "ns6:ArrayOfSearchResultBase");
	case SOAP_TYPE_PointerTons6__Parse:
		return soap_in_PointerTons6__Parse(soap, NULL, NULL, "ns6:Parse");
	case SOAP_TYPE_PointerTons6__ArrayOfCategoryCount:
		return soap_in_PointerTons6__ArrayOfCategoryCount(soap, NULL, NULL, "ns6:ArrayOfCategoryCount");
	case SOAP_TYPE_PointerTons6__ArrayOfAvailableFilter:
		return soap_in_PointerTons6__ArrayOfAvailableFilter(soap, NULL, NULL, "ns6:ArrayOfAvailableFilter");
	case SOAP_TYPE_PointerTons6__ArrayOfSearchRegion:
		return soap_in_PointerTons6__ArrayOfSearchRegion(soap, NULL, NULL, "ns6:ArrayOfSearchRegion");
	case SOAP_TYPE_PointerToPointerTons6__SearchResultSet:
		return soap_in_PointerToPointerTons6__SearchResultSet(soap, NULL, NULL, "ns6:SearchResultSet");
	case SOAP_TYPE_PointerTons6__SearchResultSet:
		return soap_in_PointerTons6__SearchResultSet(soap, NULL, NULL, "ns6:SearchResultSet");
	case SOAP_TYPE_PointerTons6__StructuredSearchQuery:
		return soap_in_PointerTons6__StructuredSearchQuery(soap, NULL, NULL, "ns6:StructuredSearchQuery");
	case SOAP_TYPE_PointerTons6__SortOrder:
		return soap_in_PointerTons6__SortOrder(soap, NULL, NULL, "ns6:SortOrder");
	case SOAP_TYPE_PointerTons6__ListingType:
		return soap_in_PointerTons6__ListingType(soap, NULL, NULL, "ns6:ListingType");
	case SOAP_TYPE_PointerToPointerTons4__Pushpin:
		return soap_in_PointerToPointerTons4__Pushpin(soap, NULL, NULL, "ns4:Pushpin");
	case SOAP_TYPE_PointerTons4__Pushpin:
		return soap_in_PointerTons4__Pushpin(soap, NULL, NULL, "ns4:Pushpin");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerToPointerTons4__GeocodeResult:
		return soap_in_PointerToPointerTons4__GeocodeResult(soap, NULL, NULL, "ns4:GeocodeResult");
	case SOAP_TYPE_PointerTons4__GeocodeResult:
		return soap_in_PointerTons4__GeocodeResult(soap, NULL, NULL, "ns4:GeocodeResult");
	case SOAP_TYPE_PointerToPointerTons4__GeocodeLocation:
		return soap_in_PointerToPointerTons4__GeocodeLocation(soap, NULL, NULL, "ns4:GeocodeLocation");
	case SOAP_TYPE_PointerTons4__GeocodeLocation:
		return soap_in_PointerTons4__GeocodeLocation(soap, NULL, NULL, "ns4:GeocodeLocation");
	case SOAP_TYPE_PointerTons7__ArrayOfstring:
		return soap_in_PointerTons7__ArrayOfstring(soap, NULL, NULL, "ns7:ArrayOfstring");
	case SOAP_TYPE_PointerTons4__ArrayOfGeocodeLocation:
		return soap_in_PointerTons4__ArrayOfGeocodeLocation(soap, NULL, NULL, "ns4:ArrayOfGeocodeLocation");
	case SOAP_TYPE_PointerTons4__Confidence:
		return soap_in_PointerTons4__Confidence(soap, NULL, NULL, "ns4:Confidence");
	case SOAP_TYPE_PointerTons4__Rectangle:
		return soap_in_PointerTons4__Rectangle(soap, NULL, NULL, "ns4:Rectangle");
	case SOAP_TYPE_PointerTons4__Address:
		return soap_in_PointerTons4__Address(soap, NULL, NULL, "ns4:Address");
	case SOAP_TYPE_PointerTons4__ResponseStatusCode:
		return soap_in_PointerTons4__ResponseStatusCode(soap, NULL, NULL, "ns4:ResponseStatusCode");
	case SOAP_TYPE_PointerTons4__AuthenticationResultCode:
		return soap_in_PointerTons4__AuthenticationResultCode(soap, NULL, NULL, "ns4:AuthenticationResultCode");
	case SOAP_TYPE_PointerTons4__ResponseSummary:
		return soap_in_PointerTons4__ResponseSummary(soap, NULL, NULL, "ns4:ResponseSummary");
	case SOAP_TYPE_PointerToPointerTons4__FilterExpressionBase:
		return soap_in_PointerToPointerTons4__FilterExpressionBase(soap, NULL, NULL, "ns4:FilterExpressionBase");
	case SOAP_TYPE_PointerTons4__FilterExpressionBase:
		return soap_in_PointerTons4__FilterExpressionBase(soap, NULL, NULL, "ns4:FilterExpressionBase");
	case SOAP_TYPE_PointerToPointerTons4__Location:
		return soap_in_PointerToPointerTons4__Location(soap, NULL, NULL, "ns4:Location");
	case SOAP_TYPE_PointerTons4__Location:
		return soap_in_PointerTons4__Location(soap, NULL, NULL, "ns4:Location");
	case SOAP_TYPE_PointerTons4__SizeOfint:
		return soap_in_PointerTons4__SizeOfint(soap, NULL, NULL, "ns4:SizeOfint");
	case SOAP_TYPE_PointerTons4__ShapeBase:
		return soap_in_PointerTons4__ShapeBase(soap, NULL, NULL, "ns4:ShapeBase");
	case SOAP_TYPE_PointerTons4__DistanceUnit:
		return soap_in_PointerTons4__DistanceUnit(soap, NULL, NULL, "ns4:DistanceUnit");
	case SOAP_TYPE_PointerTons4__DeviceType:
		return soap_in_PointerTons4__DeviceType(soap, NULL, NULL, "ns4:DeviceType");
	case SOAP_TYPE_PointerTons4__UserLocation:
		return soap_in_PointerTons4__UserLocation(soap, NULL, NULL, "ns4:UserLocation");
	case SOAP_TYPE_PointerTons4__Heading:
		return soap_in_PointerTons4__Heading(soap, NULL, NULL, "ns4:Heading");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons4__UserProfile:
		return soap_in_PointerTons4__UserProfile(soap, NULL, NULL, "ns4:UserProfile");
	case SOAP_TYPE_PointerTons4__ExecutionOptions:
		return soap_in_PointerTons4__ExecutionOptions(soap, NULL, NULL, "ns4:ExecutionOptions");
	case SOAP_TYPE_PointerTons4__Credentials:
		return soap_in_PointerTons4__Credentials(soap, NULL, NULL, "ns4:Credentials");
	case SOAP_TYPE_PointerTons6__SearchResponse:
		return soap_in_PointerTons6__SearchResponse(soap, NULL, NULL, "ns6:SearchResponse");
	case SOAP_TYPE_PointerTons6__SearchRequest:
		return soap_in_PointerTons6__SearchRequest(soap, NULL, NULL, "ns6:SearchRequest");
	case SOAP_TYPE_PointerTons1__TokenSpecification:
		return soap_in_PointerTons1__TokenSpecification(soap, NULL, NULL, "ns1:TokenSpecification");
	case SOAP_TYPE_PointerTons1__ArrayOfDouble:
		return soap_in_PointerTons1__ArrayOfDouble(soap, NULL, NULL, "ns1:ArrayOfDouble");
	case SOAP_TYPE_PointerTons1__ArrayOfLatLong:
		return soap_in_PointerTons1__ArrayOfLatLong(soap, NULL, NULL, "ns1:ArrayOfLatLong");
	case SOAP_TYPE_PointerTons1__ArrayOfDataSource:
		return soap_in_PointerTons1__ArrayOfDataSource(soap, NULL, NULL, "ns1:ArrayOfDataSource");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_in_PointerTons1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTons1__ArrayOfEntityType:
		return soap_in_PointerTons1__ArrayOfEntityType(soap, NULL, NULL, "ns1:ArrayOfEntityType");
	case SOAP_TYPE_PointerTons1__ArrayOfCountryRegionInfo:
		return soap_in_PointerTons1__ArrayOfCountryRegionInfo(soap, NULL, NULL, "ns1:ArrayOfCountryRegionInfo");
	case SOAP_TYPE_PointerTons1__ArrayOfVersionInfo:
		return soap_in_PointerTons1__ArrayOfVersionInfo(soap, NULL, NULL, "ns1:ArrayOfVersionInfo");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerToPointerTons1__LatLong:
		return soap_in_PointerToPointerTons1__LatLong(soap, NULL, NULL, "ns1:LatLong");
	case SOAP_TYPE_PointerTons1__ArrayOfInt:
		return soap_in_PointerTons1__ArrayOfInt(soap, NULL, NULL, "ns1:ArrayOfInt");
	case SOAP_TYPE_PointerToPointerTons1__DataSource:
		return soap_in_PointerToPointerTons1__DataSource(soap, NULL, NULL, "ns1:DataSource");
	case SOAP_TYPE_PointerTons1__DataSource:
		return soap_in_PointerTons1__DataSource(soap, NULL, NULL, "ns1:DataSource");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__EntityProperty:
		return soap_in_PointerToPointerTons1__EntityProperty(soap, NULL, NULL, "ns1:EntityProperty");
	case SOAP_TYPE_PointerTons1__EntityProperty:
		return soap_in_PointerTons1__EntityProperty(soap, NULL, NULL, "ns1:EntityProperty");
	case SOAP_TYPE_PointerTons1__ArrayOfEntityProperty:
		return soap_in_PointerTons1__ArrayOfEntityProperty(soap, NULL, NULL, "ns1:ArrayOfEntityProperty");
	case SOAP_TYPE_PointerToPointerTons1__EntityType:
		return soap_in_PointerToPointerTons1__EntityType(soap, NULL, NULL, "ns1:EntityType");
	case SOAP_TYPE_PointerTons1__EntityType:
		return soap_in_PointerTons1__EntityType(soap, NULL, NULL, "ns1:EntityType");
	case SOAP_TYPE_PointerTons1__LatLong:
		return soap_in_PointerTons1__LatLong(soap, NULL, NULL, "ns1:LatLong");
	case SOAP_TYPE_PointerToPointerTons1__CountryRegionInfo:
		return soap_in_PointerToPointerTons1__CountryRegionInfo(soap, NULL, NULL, "ns1:CountryRegionInfo");
	case SOAP_TYPE_PointerTons1__CountryRegionInfo:
		return soap_in_PointerTons1__CountryRegionInfo(soap, NULL, NULL, "ns1:CountryRegionInfo");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons1__CountryRegionContext:
		return soap_in_PointerTons1__CountryRegionContext(soap, NULL, NULL, "ns1:CountryRegionContext");
	case SOAP_TYPE_PointerTons1__CultureInfo:
		return soap_in_PointerTons1__CultureInfo(soap, NULL, NULL, "ns1:CultureInfo");
	case SOAP_TYPE_PointerToPointerTons1__VersionInfo:
		return soap_in_PointerToPointerTons1__VersionInfo(soap, NULL, NULL, "ns1:VersionInfo");
	case SOAP_TYPE_PointerTons1__VersionInfo:
		return soap_in_PointerTons1__VersionInfo(soap, NULL, NULL, "ns1:VersionInfo");
	case SOAP_TYPE_ns5__guid:
	{	char **s;
		s = soap_in_ns5__guid(soap, NULL, NULL, "ns5:guid");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns5__duration:
	{	char **s;
		s = soap_in_ns5__duration(soap, NULL, NULL, "ns5:duration");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__duration:
	{	char **s;
		s = soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__decimal:
	{	char **s;
		s = soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns16:ItineraryWarningType"))
		{	*type = SOAP_TYPE_ns16__ItineraryWarningType_;
			return soap_in_ns16__ItineraryWarningType_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ItineraryWarningSeverity"))
		{	*type = SOAP_TYPE_ns16__ItineraryWarningSeverity_;
			return soap_in_ns16__ItineraryWarningSeverity_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ManeuverType"))
		{	*type = SOAP_TYPE_ns16__ManeuverType_;
			return soap_in_ns16__ManeuverType_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ItineraryItemHintType"))
		{	*type = SOAP_TYPE_ns16__ItineraryItemHintType_;
			return soap_in_ns16__ItineraryItemHintType_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:TrafficUsage"))
		{	*type = SOAP_TYPE_ns16__TrafficUsage_;
			return soap_in_ns16__TrafficUsage_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:RoutePathType"))
		{	*type = SOAP_TYPE_ns16__RoutePathType_;
			return soap_in_ns16__RoutePathType_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:RouteOptimization"))
		{	*type = SOAP_TYPE_ns16__RouteOptimization_;
			return soap_in_ns16__RouteOptimization_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:TravelMode"))
		{	*type = SOAP_TYPE_ns16__TravelMode_;
			return soap_in_ns16__TravelMode_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SortOrder"))
		{	*type = SOAP_TYPE_ns6__SortOrder_;
			return soap_in_ns6__SortOrder_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ListingType"))
		{	*type = SOAP_TYPE_ns6__ListingType_;
			return soap_in_ns6__ListingType_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:guid"))
		{	*type = SOAP_TYPE_ns5__guid__;
			return soap_in_ns5__guid__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:duration"))
		{	*type = SOAP_TYPE_ns5__duration__;
			return soap_in_ns5__duration__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:char"))
		{	*type = SOAP_TYPE_ns5__char__;
			return soap_in_ns5__char__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ImageType"))
		{	*type = SOAP_TYPE_ns4__ImageType_;
			return soap_in_ns4__ImageType_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:MapStyle"))
		{	*type = SOAP_TYPE_ns4__MapStyle_;
			return soap_in_ns4__MapStyle_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UriScheme"))
		{	*type = SOAP_TYPE_ns4__UriScheme_;
			return soap_in_ns4__UriScheme_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ResponseStatusCode"))
		{	*type = SOAP_TYPE_ns4__ResponseStatusCode_;
			return soap_in_ns4__ResponseStatusCode_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:AuthenticationResultCode"))
		{	*type = SOAP_TYPE_ns4__AuthenticationResultCode_;
			return soap_in_ns4__AuthenticationResultCode_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:LogicalOperator"))
		{	*type = SOAP_TYPE_ns4__LogicalOperator_;
			return soap_in_ns4__LogicalOperator_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:CompareOperator"))
		{	*type = SOAP_TYPE_ns4__CompareOperator_;
			return soap_in_ns4__CompareOperator_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:DistanceUnit"))
		{	*type = SOAP_TYPE_ns4__DistanceUnit_;
			return soap_in_ns4__DistanceUnit_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:DeviceType"))
		{	*type = SOAP_TYPE_ns4__DeviceType_;
			return soap_in_ns4__DeviceType_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Confidence"))
		{	*type = SOAP_TYPE_ns4__Confidence_;
			return soap_in_ns4__Confidence_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DistanceUnit"))
		{	*type = SOAP_TYPE_ns1__DistanceUnit_;
			return soap_in_ns1__DistanceUnit_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataSourceCapability"))
		{	*type = SOAP_TYPE_ns1__DataSourceCapability_;
			return soap_in_ns1__DataSourceCapability_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ArrayOfRouteResult"))
		{	*type = SOAP_TYPE_ns16__ArrayOfRouteResult;
			return soap_in_ns16__ArrayOfRouteResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:MajorRoutesResponse"))
		{	*type = SOAP_TYPE_ns16__MajorRoutesResponse;
			return soap_in_ns16__MajorRoutesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:MajorRoutesOptions"))
		{	*type = SOAP_TYPE_ns16__MajorRoutesOptions;
			return soap_in_ns16__MajorRoutesOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:MajorRoutesRequest"))
		{	*type = SOAP_TYPE_ns16__MajorRoutesRequest;
			return soap_in_ns16__MajorRoutesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:RoutePath"))
		{	*type = SOAP_TYPE_ns16__RoutePath;
			return soap_in_ns16__RoutePath(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ItineraryItemWarning"))
		{	*type = SOAP_TYPE_ns16__ItineraryItemWarning;
			return soap_in_ns16__ItineraryItemWarning(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ArrayOfItineraryItemWarning"))
		{	*type = SOAP_TYPE_ns16__ArrayOfItineraryItemWarning;
			return soap_in_ns16__ArrayOfItineraryItemWarning(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:RouteSummary"))
		{	*type = SOAP_TYPE_ns16__RouteSummary;
			return soap_in_ns16__RouteSummary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ItineraryItemHint"))
		{	*type = SOAP_TYPE_ns16__ItineraryItemHint;
			return soap_in_ns16__ItineraryItemHint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ArrayOfItineraryItemHint"))
		{	*type = SOAP_TYPE_ns16__ArrayOfItineraryItemHint;
			return soap_in_ns16__ArrayOfItineraryItemHint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ItineraryItem"))
		{	*type = SOAP_TYPE_ns16__ItineraryItem;
			return soap_in_ns16__ItineraryItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ArrayOfItineraryItem"))
		{	*type = SOAP_TYPE_ns16__ArrayOfItineraryItem;
			return soap_in_ns16__ArrayOfItineraryItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:RouteLeg"))
		{	*type = SOAP_TYPE_ns16__RouteLeg;
			return soap_in_ns16__RouteLeg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ArrayOfRouteLeg"))
		{	*type = SOAP_TYPE_ns16__ArrayOfRouteLeg;
			return soap_in_ns16__ArrayOfRouteLeg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:RouteResult"))
		{	*type = SOAP_TYPE_ns16__RouteResult;
			return soap_in_ns16__RouteResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:RouteResponse"))
		{	*type = SOAP_TYPE_ns16__RouteResponse;
			return soap_in_ns16__RouteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:Waypoint"))
		{	*type = SOAP_TYPE_ns16__Waypoint;
			return soap_in_ns16__Waypoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ArrayOfWaypoint"))
		{	*type = SOAP_TYPE_ns16__ArrayOfWaypoint;
			return soap_in_ns16__ArrayOfWaypoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:RouteOptions"))
		{	*type = SOAP_TYPE_ns16__RouteOptions;
			return soap_in_ns16__RouteOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:RouteRequest"))
		{	*type = SOAP_TYPE_ns16__RouteRequest;
			return soap_in_ns16__RouteRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns13:MapUriResponse"))
		{	*type = SOAP_TYPE_ns13__MapUriResponse;
			return soap_in_ns13__MapUriResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns13:MapUriOptions"))
		{	*type = SOAP_TYPE_ns13__MapUriOptions;
			return soap_in_ns13__MapUriOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns13:MapUriRequest"))
		{	*type = SOAP_TYPE_ns13__MapUriRequest;
			return soap_in_ns13__MapUriRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns13:ImageryMetadataBirdseyeResult"))
		{	*type = SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult;
			return soap_in_ns13__ImageryMetadataBirdseyeResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns13:CoverageArea"))
		{	*type = SOAP_TYPE_ns13__CoverageArea;
			return soap_in_ns13__CoverageArea(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns13:ArrayOfCoverageArea"))
		{	*type = SOAP_TYPE_ns13__ArrayOfCoverageArea;
			return soap_in_ns13__ArrayOfCoverageArea(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns13:ImageryProvider"))
		{	*type = SOAP_TYPE_ns13__ImageryProvider;
			return soap_in_ns13__ImageryProvider(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns13:ArrayOfImageryProvider"))
		{	*type = SOAP_TYPE_ns13__ArrayOfImageryProvider;
			return soap_in_ns13__ArrayOfImageryProvider(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns13:ImageryMetadataResult"))
		{	*type = SOAP_TYPE_ns13__ImageryMetadataResult;
			return soap_in_ns13__ImageryMetadataResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns13:ArrayOfImageryMetadataResult"))
		{	*type = SOAP_TYPE_ns13__ArrayOfImageryMetadataResult;
			return soap_in_ns13__ArrayOfImageryMetadataResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns13:ImageryMetadataResponse"))
		{	*type = SOAP_TYPE_ns13__ImageryMetadataResponse;
			return soap_in_ns13__ImageryMetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns13:ImageryMetadataOptions"))
		{	*type = SOAP_TYPE_ns13__ImageryMetadataOptions;
			return soap_in_ns13__ImageryMetadataOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns13:ImageryMetadataRequest"))
		{	*type = SOAP_TYPE_ns13__ImageryMetadataRequest;
			return soap_in_ns13__ImageryMetadataRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:ReverseGeocodeRequest"))
		{	*type = SOAP_TYPE_ns10__ReverseGeocodeRequest;
			return soap_in_ns10__ReverseGeocodeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:GeocodeResponse"))
		{	*type = SOAP_TYPE_ns10__GeocodeResponse;
			return soap_in_ns10__GeocodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:ConfidenceFilter"))
		{	*type = SOAP_TYPE_ns10__ConfidenceFilter;
			return soap_in_ns10__ConfidenceFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:FilterBase"))
		{	*type = SOAP_TYPE_ns10__FilterBase;
			return soap_in_ns10__FilterBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:ArrayOfFilterBase"))
		{	*type = SOAP_TYPE_ns10__ArrayOfFilterBase;
			return soap_in_ns10__ArrayOfFilterBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:GeocodeOptions"))
		{	*type = SOAP_TYPE_ns10__GeocodeOptions;
			return soap_in_ns10__GeocodeOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:GeocodeRequest"))
		{	*type = SOAP_TYPE_ns10__GeocodeRequest;
			return soap_in_ns10__GeocodeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_P9s"))
		{	*type = SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s;
			return soap_in_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ArrayOfKeyValueOfstringanyType"))
		{	*type = SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType;
			return soap_in_ns7__ArrayOfKeyValueOfstringanyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ArrayOfKeyValueOfNeighborhoodintkC8b0tr6"))
		{	*type = SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6;
			return soap_in_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ArrayOfanyType"))
		{	*type = SOAP_TYPE_ns7__ArrayOfanyType;
			return soap_in_ns7__ArrayOfanyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ArrayOfstring"))
		{	*type = SOAP_TYPE_ns7__ArrayOfstring;
			return soap_in_ns7__ArrayOfstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SearchPoint"))
		{	*type = SOAP_TYPE_ns6__SearchPoint;
			return soap_in_ns6__SearchPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:PersonSearchResult"))
		{	*type = SOAP_TYPE_ns6__PersonSearchResult;
			return soap_in_ns6__PersonSearchResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ArrayOfNeighborhood"))
		{	*type = SOAP_TYPE_ns6__ArrayOfNeighborhood;
			return soap_in_ns6__ArrayOfNeighborhood(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CategorySpecificPropertySet"))
		{	*type = SOAP_TYPE_ns6__CategorySpecificPropertySet;
			return soap_in_ns6__CategorySpecificPropertySet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ArrayOfCategory"))
		{	*type = SOAP_TYPE_ns6__ArrayOfCategory;
			return soap_in_ns6__ArrayOfCategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:BusinessSearchResult"))
		{	*type = SOAP_TYPE_ns6__BusinessSearchResult;
			return soap_in_ns6__BusinessSearchResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CommunityContentSearchResult"))
		{	*type = SOAP_TYPE_ns6__CommunityContentSearchResult;
			return soap_in_ns6__CommunityContentSearchResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:LocationData"))
		{	*type = SOAP_TYPE_ns6__LocationData;
			return soap_in_ns6__LocationData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SearchResultBase"))
		{	*type = SOAP_TYPE_ns6__SearchResultBase;
			return soap_in_ns6__SearchResultBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ArrayOfSearchResultBase"))
		{	*type = SOAP_TYPE_ns6__ArrayOfSearchResultBase;
			return soap_in_ns6__ArrayOfSearchResultBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:Parse"))
		{	*type = SOAP_TYPE_ns6__Parse;
			return soap_in_ns6__Parse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CategoryCount"))
		{	*type = SOAP_TYPE_ns6__CategoryCount;
			return soap_in_ns6__CategoryCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ArrayOfCategoryCount"))
		{	*type = SOAP_TYPE_ns6__ArrayOfCategoryCount;
			return soap_in_ns6__ArrayOfCategoryCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:FilterValue"))
		{	*type = SOAP_TYPE_ns6__FilterValue;
			return soap_in_ns6__FilterValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:Category"))
		{	*type = SOAP_TYPE_ns6__Category;
			return soap_in_ns6__Category(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:Neighborhood"))
		{	*type = SOAP_TYPE_ns6__Neighborhood;
			return soap_in_ns6__Neighborhood(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ValueListFilter"))
		{	*type = SOAP_TYPE_ns6__ValueListFilter;
			return soap_in_ns6__ValueListFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:RangeFilter"))
		{	*type = SOAP_TYPE_ns6__RangeFilter;
			return soap_in_ns6__RangeFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:AvailableFilter"))
		{	*type = SOAP_TYPE_ns6__AvailableFilter;
			return soap_in_ns6__AvailableFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ArrayOfAvailableFilter"))
		{	*type = SOAP_TYPE_ns6__ArrayOfAvailableFilter;
			return soap_in_ns6__ArrayOfAvailableFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SearchRegion"))
		{	*type = SOAP_TYPE_ns6__SearchRegion;
			return soap_in_ns6__SearchRegion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ArrayOfSearchRegion"))
		{	*type = SOAP_TYPE_ns6__ArrayOfSearchRegion;
			return soap_in_ns6__ArrayOfSearchRegion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SearchResultSet"))
		{	*type = SOAP_TYPE_ns6__SearchResultSet;
			return soap_in_ns6__SearchResultSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ArrayOfSearchResultSet"))
		{	*type = SOAP_TYPE_ns6__ArrayOfSearchResultSet;
			return soap_in_ns6__ArrayOfSearchResultSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:QuerySuggestion"))
		{	*type = SOAP_TYPE_ns6__QuerySuggestion;
			return soap_in_ns6__QuerySuggestion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SearchResponse"))
		{	*type = SOAP_TYPE_ns6__SearchResponse;
			return soap_in_ns6__SearchResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:StructuredSearchQuery"))
		{	*type = SOAP_TYPE_ns6__StructuredSearchQuery;
			return soap_in_ns6__StructuredSearchQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SearchOptions"))
		{	*type = SOAP_TYPE_ns6__SearchOptions;
			return soap_in_ns6__SearchOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SearchRequest"))
		{	*type = SOAP_TYPE_ns6__SearchRequest;
			return soap_in_ns6__SearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Pushpin"))
		{	*type = SOAP_TYPE_ns4__Pushpin;
			return soap_in_ns4__Pushpin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfPushpin"))
		{	*type = SOAP_TYPE_ns4__ArrayOfPushpin;
			return soap_in_ns4__ArrayOfPushpin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RangeOfdateTime"))
		{	*type = SOAP_TYPE_ns4__RangeOfdateTime;
			return soap_in_ns4__RangeOfdateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RangeOfint"))
		{	*type = SOAP_TYPE_ns4__RangeOfint;
			return soap_in_ns4__RangeOfint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfGeocodeResult"))
		{	*type = SOAP_TYPE_ns4__ArrayOfGeocodeResult;
			return soap_in_ns4__ArrayOfGeocodeResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfGeocodeLocation"))
		{	*type = SOAP_TYPE_ns4__ArrayOfGeocodeLocation;
			return soap_in_ns4__ArrayOfGeocodeLocation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Address"))
		{	*type = SOAP_TYPE_ns4__Address;
			return soap_in_ns4__Address(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GeocodeResult"))
		{	*type = SOAP_TYPE_ns4__GeocodeResult;
			return soap_in_ns4__GeocodeResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ResponseSummary"))
		{	*type = SOAP_TYPE_ns4__ResponseSummary;
			return soap_in_ns4__ResponseSummary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ResponseBase"))
		{	*type = SOAP_TYPE_ns4__ResponseBase;
			return soap_in_ns4__ResponseBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfFilterExpressionBase"))
		{	*type = SOAP_TYPE_ns4__ArrayOfFilterExpressionBase;
			return soap_in_ns4__ArrayOfFilterExpressionBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:FilterExpressionClause"))
		{	*type = SOAP_TYPE_ns4__FilterExpressionClause;
			return soap_in_ns4__FilterExpressionClause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:FilterExpression"))
		{	*type = SOAP_TYPE_ns4__FilterExpression;
			return soap_in_ns4__FilterExpression(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:FilterExpressionBase"))
		{	*type = SOAP_TYPE_ns4__FilterExpressionBase;
			return soap_in_ns4__FilterExpressionBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SizeOfint"))
		{	*type = SOAP_TYPE_ns4__SizeOfint;
			return soap_in_ns4__SizeOfint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfLocation"))
		{	*type = SOAP_TYPE_ns4__ArrayOfLocation;
			return soap_in_ns4__ArrayOfLocation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Polygon"))
		{	*type = SOAP_TYPE_ns4__Polygon;
			return soap_in_ns4__Polygon(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Circle"))
		{	*type = SOAP_TYPE_ns4__Circle;
			return soap_in_ns4__Circle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Rectangle"))
		{	*type = SOAP_TYPE_ns4__Rectangle;
			return soap_in_ns4__Rectangle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ShapeBase"))
		{	*type = SOAP_TYPE_ns4__ShapeBase;
			return soap_in_ns4__ShapeBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GeocodeLocation"))
		{	*type = SOAP_TYPE_ns4__GeocodeLocation;
			return soap_in_ns4__GeocodeLocation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Location"))
		{	*type = SOAP_TYPE_ns4__Location;
			return soap_in_ns4__Location(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UserLocation"))
		{	*type = SOAP_TYPE_ns4__UserLocation;
			return soap_in_ns4__UserLocation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Heading"))
		{	*type = SOAP_TYPE_ns4__Heading;
			return soap_in_ns4__Heading(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UserProfile"))
		{	*type = SOAP_TYPE_ns4__UserProfile;
			return soap_in_ns4__UserProfile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ExecutionOptions"))
		{	*type = SOAP_TYPE_ns4__ExecutionOptions;
			return soap_in_ns4__ExecutionOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Credentials"))
		{	*type = SOAP_TYPE_ns4__Credentials;
			return soap_in_ns4__Credentials(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RequestBase"))
		{	*type = SOAP_TYPE_ns4__RequestBase;
			return soap_in_ns4__RequestBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TokenSpecification"))
		{	*type = SOAP_TYPE_ns1__TokenSpecification;
			return soap_in_ns1__TokenSpecification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDouble"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDouble;
			return soap_in_ns1__ArrayOfDouble(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfLatLong"))
		{	*type = SOAP_TYPE_ns1__ArrayOfLatLong;
			return soap_in_ns1__ArrayOfLatLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataSource"))
		{	*type = SOAP_TYPE_ns1__DataSource;
			return soap_in_ns1__DataSource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDataSource"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDataSource;
			return soap_in_ns1__ArrayOfDataSource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfString"))
		{	*type = SOAP_TYPE_ns1__ArrayOfString;
			return soap_in_ns1__ArrayOfString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EntityProperty"))
		{	*type = SOAP_TYPE_ns1__EntityProperty;
			return soap_in_ns1__EntityProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfEntityProperty"))
		{	*type = SOAP_TYPE_ns1__ArrayOfEntityProperty;
			return soap_in_ns1__ArrayOfEntityProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EntityType"))
		{	*type = SOAP_TYPE_ns1__EntityType;
			return soap_in_ns1__EntityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfEntityType"))
		{	*type = SOAP_TYPE_ns1__ArrayOfEntityType;
			return soap_in_ns1__ArrayOfEntityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LatLong"))
		{	*type = SOAP_TYPE_ns1__LatLong;
			return soap_in_ns1__LatLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CountryRegionInfo"))
		{	*type = SOAP_TYPE_ns1__CountryRegionInfo;
			return soap_in_ns1__CountryRegionInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfCountryRegionInfo"))
		{	*type = SOAP_TYPE_ns1__ArrayOfCountryRegionInfo;
			return soap_in_ns1__ArrayOfCountryRegionInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfInt"))
		{	*type = SOAP_TYPE_ns1__ArrayOfInt;
			return soap_in_ns1__ArrayOfInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CountryRegionContext"))
		{	*type = SOAP_TYPE_ns1__CountryRegionContext;
			return soap_in_ns1__CountryRegionContext(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CultureInfo"))
		{	*type = SOAP_TYPE_ns1__CultureInfo;
			return soap_in_ns1__CultureInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UserInfoHeader"))
		{	*type = SOAP_TYPE_ns1__UserInfoHeader;
			return soap_in_ns1__UserInfoHeader(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CustomerInfoHeader"))
		{	*type = SOAP_TYPE_ns1__CustomerInfoHeader;
			return soap_in_ns1__CustomerInfoHeader(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VersionInfo"))
		{	*type = SOAP_TYPE_ns1__VersionInfo;
			return soap_in_ns1__VersionInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfVersionInfo"))
		{	*type = SOAP_TYPE_ns1__ArrayOfVersionInfo;
			return soap_in_ns1__ArrayOfVersionInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_xsd__unsignedShort;
			return soap_in_xsd__unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_xsd__unsignedLong;
			return soap_in_xsd__unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_xsd__unsignedInt;
			return soap_in_xsd__unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_xsd__unsignedByte_;
			return soap_in_xsd__unsignedByte_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string;
			return soap_in_xsd__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_xsd__short;
			return soap_in_xsd__short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long;
			return soap_in_xsd__long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_xsd__float;
			return soap_in_xsd__float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration_;
			return soap_in_xsd__duration_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double;
			return soap_in_xsd__double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal_;
			return soap_in_xsd__decimal_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte_;
			return soap_in_xsd__byte_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary_;
			return soap_in_xsd__base64Binary_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI_;
			return soap_in_xsd__anyURI_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte;
			return soap_in_xsd__byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:char"))
		{	*type = SOAP_TYPE_ns5__char;
			return soap_in_ns5__char(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_xsd__unsignedByte;
			return soap_in_xsd__unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_unsignedShort;
			return soap_in_unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ItineraryWarningType"))
		{	*type = SOAP_TYPE_ns16__ItineraryWarningType;
			return soap_in_ns16__ItineraryWarningType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ItineraryWarningSeverity"))
		{	*type = SOAP_TYPE_ns16__ItineraryWarningSeverity;
			return soap_in_ns16__ItineraryWarningSeverity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ManeuverType"))
		{	*type = SOAP_TYPE_ns16__ManeuverType;
			return soap_in_ns16__ManeuverType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:ItineraryItemHintType"))
		{	*type = SOAP_TYPE_ns16__ItineraryItemHintType;
			return soap_in_ns16__ItineraryItemHintType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:TrafficUsage"))
		{	*type = SOAP_TYPE_ns16__TrafficUsage;
			return soap_in_ns16__TrafficUsage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:RoutePathType"))
		{	*type = SOAP_TYPE_ns16__RoutePathType;
			return soap_in_ns16__RoutePathType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:RouteOptimization"))
		{	*type = SOAP_TYPE_ns16__RouteOptimization;
			return soap_in_ns16__RouteOptimization(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:TravelMode"))
		{	*type = SOAP_TYPE_ns16__TravelMode;
			return soap_in_ns16__TravelMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SortOrder"))
		{	*type = SOAP_TYPE_ns6__SortOrder;
			return soap_in_ns6__SortOrder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ListingType"))
		{	*type = SOAP_TYPE_ns6__ListingType;
			return soap_in_ns6__ListingType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ImageType"))
		{	*type = SOAP_TYPE_ns4__ImageType;
			return soap_in_ns4__ImageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:MapStyle"))
		{	*type = SOAP_TYPE_ns4__MapStyle;
			return soap_in_ns4__MapStyle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UriScheme"))
		{	*type = SOAP_TYPE_ns4__UriScheme;
			return soap_in_ns4__UriScheme(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ResponseStatusCode"))
		{	*type = SOAP_TYPE_ns4__ResponseStatusCode;
			return soap_in_ns4__ResponseStatusCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:AuthenticationResultCode"))
		{	*type = SOAP_TYPE_ns4__AuthenticationResultCode;
			return soap_in_ns4__AuthenticationResultCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:LogicalOperator"))
		{	*type = SOAP_TYPE_ns4__LogicalOperator;
			return soap_in_ns4__LogicalOperator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:CompareOperator"))
		{	*type = SOAP_TYPE_ns4__CompareOperator;
			return soap_in_ns4__CompareOperator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:DistanceUnit"))
		{	*type = SOAP_TYPE_ns4__DistanceUnit;
			return soap_in_ns4__DistanceUnit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:DeviceType"))
		{	*type = SOAP_TYPE_ns4__DeviceType;
			return soap_in_ns4__DeviceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Confidence"))
		{	*type = SOAP_TYPE_ns4__Confidence;
			return soap_in_ns4__Confidence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DistanceUnit"))
		{	*type = SOAP_TYPE_ns1__DistanceUnit;
			return soap_in_ns1__DistanceUnit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataSourceCapability"))
		{	*type = SOAP_TYPE_ns1__DataSourceCapability;
			return soap_in_ns1__DataSourceCapability(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:guid"))
		{	char **s;
			*type = SOAP_TYPE_ns5__guid;
			s = soap_in_ns5__guid(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns5:duration"))
		{	char **s;
			*type = SOAP_TYPE_ns5__duration;
			s = soap_in_ns5__duration(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	char **s;
			*type = SOAP_TYPE_xsd__duration;
			s = soap_in_xsd__duration(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	char **s;
			*type = SOAP_TYPE_xsd__decimal;
			s = soap_in_xsd__decimal(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns7:ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_P9s-KeyValueOfintCategorySpecificPropertySetn6Q9q_P9s"))
		{	*type = SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s;
			return soap_in__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ArrayOfKeyValueOfstringanyType-KeyValueOfstringanyType"))
		{	*type = SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType;
			return soap_in__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ArrayOfKeyValueOfNeighborhoodintkC8b0tr6-KeyValueOfNeighborhoodintkC8b0tr6"))
		{	*type = SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6;
			return soap_in__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns15:CalculateRoutesFromMajorRoadsResponse"))
		{	*type = SOAP_TYPE__ns15__CalculateRoutesFromMajorRoadsResponse;
			return soap_in__ns15__CalculateRoutesFromMajorRoadsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns15:CalculateRoutesFromMajorRoads"))
		{	*type = SOAP_TYPE__ns15__CalculateRoutesFromMajorRoads;
			return soap_in__ns15__CalculateRoutesFromMajorRoads(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns15:CalculateRouteResponse"))
		{	*type = SOAP_TYPE__ns15__CalculateRouteResponse;
			return soap_in__ns15__CalculateRouteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns15:CalculateRoute"))
		{	*type = SOAP_TYPE__ns15__CalculateRoute;
			return soap_in__ns15__CalculateRoute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns12:GetMapUriResponse"))
		{	*type = SOAP_TYPE__ns12__GetMapUriResponse;
			return soap_in__ns12__GetMapUriResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns12:GetMapUri"))
		{	*type = SOAP_TYPE__ns12__GetMapUri;
			return soap_in__ns12__GetMapUri(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns12:GetImageryMetadataResponse"))
		{	*type = SOAP_TYPE__ns12__GetImageryMetadataResponse;
			return soap_in__ns12__GetImageryMetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns12:GetImageryMetadata"))
		{	*type = SOAP_TYPE__ns12__GetImageryMetadata;
			return soap_in__ns12__GetImageryMetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns9:ReverseGeocodeResponse"))
		{	*type = SOAP_TYPE__ns9__ReverseGeocodeResponse;
			return soap_in__ns9__ReverseGeocodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns9:ReverseGeocode"))
		{	*type = SOAP_TYPE__ns9__ReverseGeocode;
			return soap_in__ns9__ReverseGeocode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns9:GeocodeResponse"))
		{	*type = SOAP_TYPE__ns9__GeocodeResponse;
			return soap_in__ns9__GeocodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns9:Geocode"))
		{	*type = SOAP_TYPE__ns9__Geocode;
			return soap_in__ns9__Geocode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SearchResponse"))
		{	*type = SOAP_TYPE__ns3__SearchResponse;
			return soap_in__ns3__SearchResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Search"))
		{	*type = SOAP_TYPE__ns3__Search;
			return soap_in__ns3__Search(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetClientTokenResponse"))
		{	*type = SOAP_TYPE__ns1__GetClientTokenResponse;
			return soap_in__ns1__GetClientTokenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetClientToken"))
		{	*type = SOAP_TYPE__ns1__GetClientToken;
			return soap_in__ns1__GetClientToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetGreatCircleDistancesResponse"))
		{	*type = SOAP_TYPE__ns1__GetGreatCircleDistancesResponse;
			return soap_in__ns1__GetGreatCircleDistancesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetGreatCircleDistances"))
		{	*type = SOAP_TYPE__ns1__GetGreatCircleDistances;
			return soap_in__ns1__GetGreatCircleDistances(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDataSourceInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetDataSourceInfoResponse;
			return soap_in__ns1__GetDataSourceInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDataSourceInfo"))
		{	*type = SOAP_TYPE__ns1__GetDataSourceInfo;
			return soap_in__ns1__GetDataSourceInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetEntityTypesResponse"))
		{	*type = SOAP_TYPE__ns1__GetEntityTypesResponse;
			return soap_in__ns1__GetEntityTypesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetEntityTypes"))
		{	*type = SOAP_TYPE__ns1__GetEntityTypes;
			return soap_in__ns1__GetEntityTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCountryRegionInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetCountryRegionInfoResponse;
			return soap_in__ns1__GetCountryRegionInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCountryRegionInfo"))
		{	*type = SOAP_TYPE__ns1__GetCountryRegionInfo;
			return soap_in__ns1__GetCountryRegionInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVersionInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetVersionInfoResponse;
			return soap_in__ns1__GetVersionInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVersionInfo"))
		{	*type = SOAP_TYPE__ns1__GetVersionInfo;
			return soap_in__ns1__GetVersionInfo(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_out_xsd__byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_ns5__char:
		return soap_out_ns5__char(soap, tag, id, (const int *)ptr, "ns5:char");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_out_xsd__unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedShort:
		return soap_out_unsignedShort(soap, tag, id, (const unsigned short *)ptr, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ns16__ItineraryWarningType:
		return soap_out_ns16__ItineraryWarningType(soap, tag, id, (const enum ns16__ItineraryWarningType *)ptr, "ns16:ItineraryWarningType");
	case SOAP_TYPE_ns16__ItineraryWarningSeverity:
		return soap_out_ns16__ItineraryWarningSeverity(soap, tag, id, (const enum ns16__ItineraryWarningSeverity *)ptr, "ns16:ItineraryWarningSeverity");
	case SOAP_TYPE_ns16__ManeuverType:
		return soap_out_ns16__ManeuverType(soap, tag, id, (const enum ns16__ManeuverType *)ptr, "ns16:ManeuverType");
	case SOAP_TYPE_ns16__ItineraryItemHintType:
		return soap_out_ns16__ItineraryItemHintType(soap, tag, id, (const enum ns16__ItineraryItemHintType *)ptr, "ns16:ItineraryItemHintType");
	case SOAP_TYPE_ns16__TrafficUsage:
		return soap_out_ns16__TrafficUsage(soap, tag, id, (const enum ns16__TrafficUsage *)ptr, "ns16:TrafficUsage");
	case SOAP_TYPE_ns16__RoutePathType:
		return soap_out_ns16__RoutePathType(soap, tag, id, (const enum ns16__RoutePathType *)ptr, "ns16:RoutePathType");
	case SOAP_TYPE_ns16__RouteOptimization:
		return soap_out_ns16__RouteOptimization(soap, tag, id, (const enum ns16__RouteOptimization *)ptr, "ns16:RouteOptimization");
	case SOAP_TYPE_ns16__TravelMode:
		return soap_out_ns16__TravelMode(soap, tag, id, (const enum ns16__TravelMode *)ptr, "ns16:TravelMode");
	case SOAP_TYPE_ns6__SortOrder:
		return soap_out_ns6__SortOrder(soap, tag, id, (const enum ns6__SortOrder *)ptr, "ns6:SortOrder");
	case SOAP_TYPE_ns6__ListingType:
		return soap_out_ns6__ListingType(soap, tag, id, (const enum ns6__ListingType *)ptr, "ns6:ListingType");
	case SOAP_TYPE_ns4__ImageType:
		return soap_out_ns4__ImageType(soap, tag, id, (const enum ns4__ImageType *)ptr, "ns4:ImageType");
	case SOAP_TYPE_ns4__MapStyle:
		return soap_out_ns4__MapStyle(soap, tag, id, (const enum ns4__MapStyle *)ptr, "ns4:MapStyle");
	case SOAP_TYPE_ns4__UriScheme:
		return soap_out_ns4__UriScheme(soap, tag, id, (const enum ns4__UriScheme *)ptr, "ns4:UriScheme");
	case SOAP_TYPE_ns4__ResponseStatusCode:
		return soap_out_ns4__ResponseStatusCode(soap, tag, id, (const enum ns4__ResponseStatusCode *)ptr, "ns4:ResponseStatusCode");
	case SOAP_TYPE_ns4__AuthenticationResultCode:
		return soap_out_ns4__AuthenticationResultCode(soap, tag, id, (const enum ns4__AuthenticationResultCode *)ptr, "ns4:AuthenticationResultCode");
	case SOAP_TYPE_ns4__LogicalOperator:
		return soap_out_ns4__LogicalOperator(soap, tag, id, (const enum ns4__LogicalOperator *)ptr, "ns4:LogicalOperator");
	case SOAP_TYPE_ns4__CompareOperator:
		return soap_out_ns4__CompareOperator(soap, tag, id, (const enum ns4__CompareOperator *)ptr, "ns4:CompareOperator");
	case SOAP_TYPE_ns4__DistanceUnit:
		return soap_out_ns4__DistanceUnit(soap, tag, id, (const enum ns4__DistanceUnit *)ptr, "ns4:DistanceUnit");
	case SOAP_TYPE_ns4__DeviceType:
		return soap_out_ns4__DeviceType(soap, tag, id, (const enum ns4__DeviceType *)ptr, "ns4:DeviceType");
	case SOAP_TYPE_ns4__Confidence:
		return soap_out_ns4__Confidence(soap, tag, id, (const enum ns4__Confidence *)ptr, "ns4:Confidence");
	case SOAP_TYPE_ns1__DistanceUnit:
		return soap_out_ns1__DistanceUnit(soap, tag, id, (const enum ns1__DistanceUnit *)ptr, "ns1:DistanceUnit");
	case SOAP_TYPE_ns1__DataSourceCapability:
		return soap_out_ns1__DataSourceCapability(soap, tag, id, (const enum ns1__DataSourceCapability *)ptr, "ns1:DataSourceCapability");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		return ((_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *)ptr)->soap_out(soap, "ns7:ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_P9s-KeyValueOfintCategorySpecificPropertySetn6Q9q_P9s", id, NULL);
	case SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType:
		return ((_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *)ptr)->soap_out(soap, "ns7:ArrayOfKeyValueOfstringanyType-KeyValueOfstringanyType", id, NULL);
	case SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6:
		return ((_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *)ptr)->soap_out(soap, "ns7:ArrayOfKeyValueOfNeighborhoodintkC8b0tr6-KeyValueOfNeighborhoodintkC8b0tr6", id, NULL);
	case SOAP_TYPE_ns16__ItineraryWarningType_:
		return ((ns16__ItineraryWarningType_ *)ptr)->soap_out(soap, tag, id, "ns16:ItineraryWarningType");
	case SOAP_TYPE_ns16__ItineraryWarningSeverity_:
		return ((ns16__ItineraryWarningSeverity_ *)ptr)->soap_out(soap, tag, id, "ns16:ItineraryWarningSeverity");
	case SOAP_TYPE_ns16__ManeuverType_:
		return ((ns16__ManeuverType_ *)ptr)->soap_out(soap, tag, id, "ns16:ManeuverType");
	case SOAP_TYPE_ns16__ItineraryItemHintType_:
		return ((ns16__ItineraryItemHintType_ *)ptr)->soap_out(soap, tag, id, "ns16:ItineraryItemHintType");
	case SOAP_TYPE_ns16__TrafficUsage_:
		return ((ns16__TrafficUsage_ *)ptr)->soap_out(soap, tag, id, "ns16:TrafficUsage");
	case SOAP_TYPE_ns16__RoutePathType_:
		return ((ns16__RoutePathType_ *)ptr)->soap_out(soap, tag, id, "ns16:RoutePathType");
	case SOAP_TYPE_ns16__RouteOptimization_:
		return ((ns16__RouteOptimization_ *)ptr)->soap_out(soap, tag, id, "ns16:RouteOptimization");
	case SOAP_TYPE_ns16__TravelMode_:
		return ((ns16__TravelMode_ *)ptr)->soap_out(soap, tag, id, "ns16:TravelMode");
	case SOAP_TYPE_ns6__SortOrder_:
		return ((ns6__SortOrder_ *)ptr)->soap_out(soap, tag, id, "ns6:SortOrder");
	case SOAP_TYPE_ns6__ListingType_:
		return ((ns6__ListingType_ *)ptr)->soap_out(soap, tag, id, "ns6:ListingType");
	case SOAP_TYPE_ns5__guid__:
		return ((ns5__guid__ *)ptr)->soap_out(soap, tag, id, "ns5:guid");
	case SOAP_TYPE_ns5__duration__:
		return ((ns5__duration__ *)ptr)->soap_out(soap, tag, id, "ns5:duration");
	case SOAP_TYPE_ns5__char__:
		return ((ns5__char__ *)ptr)->soap_out(soap, tag, id, "ns5:char");
	case SOAP_TYPE_ns4__ImageType_:
		return ((ns4__ImageType_ *)ptr)->soap_out(soap, tag, id, "ns4:ImageType");
	case SOAP_TYPE_ns4__MapStyle_:
		return ((ns4__MapStyle_ *)ptr)->soap_out(soap, tag, id, "ns4:MapStyle");
	case SOAP_TYPE_ns4__UriScheme_:
		return ((ns4__UriScheme_ *)ptr)->soap_out(soap, tag, id, "ns4:UriScheme");
	case SOAP_TYPE_ns4__ResponseStatusCode_:
		return ((ns4__ResponseStatusCode_ *)ptr)->soap_out(soap, tag, id, "ns4:ResponseStatusCode");
	case SOAP_TYPE_ns4__AuthenticationResultCode_:
		return ((ns4__AuthenticationResultCode_ *)ptr)->soap_out(soap, tag, id, "ns4:AuthenticationResultCode");
	case SOAP_TYPE_ns4__LogicalOperator_:
		return ((ns4__LogicalOperator_ *)ptr)->soap_out(soap, tag, id, "ns4:LogicalOperator");
	case SOAP_TYPE_ns4__CompareOperator_:
		return ((ns4__CompareOperator_ *)ptr)->soap_out(soap, tag, id, "ns4:CompareOperator");
	case SOAP_TYPE_ns4__DistanceUnit_:
		return ((ns4__DistanceUnit_ *)ptr)->soap_out(soap, tag, id, "ns4:DistanceUnit");
	case SOAP_TYPE_ns4__DeviceType_:
		return ((ns4__DeviceType_ *)ptr)->soap_out(soap, tag, id, "ns4:DeviceType");
	case SOAP_TYPE_ns4__Confidence_:
		return ((ns4__Confidence_ *)ptr)->soap_out(soap, tag, id, "ns4:Confidence");
	case SOAP_TYPE_ns1__DistanceUnit_:
		return ((ns1__DistanceUnit_ *)ptr)->soap_out(soap, tag, id, "ns1:DistanceUnit");
	case SOAP_TYPE_ns1__DataSourceCapability_:
		return ((ns1__DataSourceCapability_ *)ptr)->soap_out(soap, tag, id, "ns1:DataSourceCapability");
	case SOAP_TYPE_ns16__ArrayOfRouteResult:
		return ((ns16__ArrayOfRouteResult *)ptr)->soap_out(soap, tag, id, "ns16:ArrayOfRouteResult");
	case SOAP_TYPE_ns16__MajorRoutesResponse:
		return ((ns16__MajorRoutesResponse *)ptr)->soap_out(soap, tag, id, "ns16:MajorRoutesResponse");
	case SOAP_TYPE_ns16__MajorRoutesOptions:
		return ((ns16__MajorRoutesOptions *)ptr)->soap_out(soap, tag, id, "ns16:MajorRoutesOptions");
	case SOAP_TYPE_ns16__MajorRoutesRequest:
		return ((ns16__MajorRoutesRequest *)ptr)->soap_out(soap, tag, id, "ns16:MajorRoutesRequest");
	case SOAP_TYPE_ns16__RoutePath:
		return ((ns16__RoutePath *)ptr)->soap_out(soap, tag, id, "ns16:RoutePath");
	case SOAP_TYPE_ns16__ItineraryItemWarning:
		return ((ns16__ItineraryItemWarning *)ptr)->soap_out(soap, tag, id, "ns16:ItineraryItemWarning");
	case SOAP_TYPE_ns16__ArrayOfItineraryItemWarning:
		return ((ns16__ArrayOfItineraryItemWarning *)ptr)->soap_out(soap, tag, id, "ns16:ArrayOfItineraryItemWarning");
	case SOAP_TYPE_ns16__RouteSummary:
		return ((ns16__RouteSummary *)ptr)->soap_out(soap, tag, id, "ns16:RouteSummary");
	case SOAP_TYPE_ns16__ItineraryItemHint:
		return ((ns16__ItineraryItemHint *)ptr)->soap_out(soap, tag, id, "ns16:ItineraryItemHint");
	case SOAP_TYPE_ns16__ArrayOfItineraryItemHint:
		return ((ns16__ArrayOfItineraryItemHint *)ptr)->soap_out(soap, tag, id, "ns16:ArrayOfItineraryItemHint");
	case SOAP_TYPE_ns16__ItineraryItem:
		return ((ns16__ItineraryItem *)ptr)->soap_out(soap, tag, id, "ns16:ItineraryItem");
	case SOAP_TYPE_ns16__ArrayOfItineraryItem:
		return ((ns16__ArrayOfItineraryItem *)ptr)->soap_out(soap, tag, id, "ns16:ArrayOfItineraryItem");
	case SOAP_TYPE_ns16__RouteLeg:
		return ((ns16__RouteLeg *)ptr)->soap_out(soap, tag, id, "ns16:RouteLeg");
	case SOAP_TYPE_ns16__ArrayOfRouteLeg:
		return ((ns16__ArrayOfRouteLeg *)ptr)->soap_out(soap, tag, id, "ns16:ArrayOfRouteLeg");
	case SOAP_TYPE_ns16__RouteResult:
		return ((ns16__RouteResult *)ptr)->soap_out(soap, tag, id, "ns16:RouteResult");
	case SOAP_TYPE_ns16__RouteResponse:
		return ((ns16__RouteResponse *)ptr)->soap_out(soap, tag, id, "ns16:RouteResponse");
	case SOAP_TYPE_ns16__Waypoint:
		return ((ns16__Waypoint *)ptr)->soap_out(soap, tag, id, "ns16:Waypoint");
	case SOAP_TYPE_ns16__ArrayOfWaypoint:
		return ((ns16__ArrayOfWaypoint *)ptr)->soap_out(soap, tag, id, "ns16:ArrayOfWaypoint");
	case SOAP_TYPE_ns16__RouteOptions:
		return ((ns16__RouteOptions *)ptr)->soap_out(soap, tag, id, "ns16:RouteOptions");
	case SOAP_TYPE_ns16__RouteRequest:
		return ((ns16__RouteRequest *)ptr)->soap_out(soap, tag, id, "ns16:RouteRequest");
	case SOAP_TYPE__ns15__CalculateRoutesFromMajorRoadsResponse:
		return ((_ns15__CalculateRoutesFromMajorRoadsResponse *)ptr)->soap_out(soap, "ns15:CalculateRoutesFromMajorRoadsResponse", id, NULL);
	case SOAP_TYPE__ns15__CalculateRoutesFromMajorRoads:
		return ((_ns15__CalculateRoutesFromMajorRoads *)ptr)->soap_out(soap, "ns15:CalculateRoutesFromMajorRoads", id, NULL);
	case SOAP_TYPE__ns15__CalculateRouteResponse:
		return ((_ns15__CalculateRouteResponse *)ptr)->soap_out(soap, "ns15:CalculateRouteResponse", id, NULL);
	case SOAP_TYPE__ns15__CalculateRoute:
		return ((_ns15__CalculateRoute *)ptr)->soap_out(soap, "ns15:CalculateRoute", id, NULL);
	case SOAP_TYPE_ns13__MapUriResponse:
		return ((ns13__MapUriResponse *)ptr)->soap_out(soap, tag, id, "ns13:MapUriResponse");
	case SOAP_TYPE_ns13__MapUriOptions:
		return ((ns13__MapUriOptions *)ptr)->soap_out(soap, tag, id, "ns13:MapUriOptions");
	case SOAP_TYPE_ns13__MapUriRequest:
		return ((ns13__MapUriRequest *)ptr)->soap_out(soap, tag, id, "ns13:MapUriRequest");
	case SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult:
		return ((ns13__ImageryMetadataBirdseyeResult *)ptr)->soap_out(soap, tag, id, "ns13:ImageryMetadataBirdseyeResult");
	case SOAP_TYPE_ns13__CoverageArea:
		return ((ns13__CoverageArea *)ptr)->soap_out(soap, tag, id, "ns13:CoverageArea");
	case SOAP_TYPE_ns13__ArrayOfCoverageArea:
		return ((ns13__ArrayOfCoverageArea *)ptr)->soap_out(soap, tag, id, "ns13:ArrayOfCoverageArea");
	case SOAP_TYPE_ns13__ImageryProvider:
		return ((ns13__ImageryProvider *)ptr)->soap_out(soap, tag, id, "ns13:ImageryProvider");
	case SOAP_TYPE_ns13__ArrayOfImageryProvider:
		return ((ns13__ArrayOfImageryProvider *)ptr)->soap_out(soap, tag, id, "ns13:ArrayOfImageryProvider");
	case SOAP_TYPE_ns13__ImageryMetadataResult:
		return ((ns13__ImageryMetadataResult *)ptr)->soap_out(soap, tag, id, "ns13:ImageryMetadataResult");
	case SOAP_TYPE_ns13__ArrayOfImageryMetadataResult:
		return ((ns13__ArrayOfImageryMetadataResult *)ptr)->soap_out(soap, tag, id, "ns13:ArrayOfImageryMetadataResult");
	case SOAP_TYPE_ns13__ImageryMetadataResponse:
		return ((ns13__ImageryMetadataResponse *)ptr)->soap_out(soap, tag, id, "ns13:ImageryMetadataResponse");
	case SOAP_TYPE_ns13__ImageryMetadataOptions:
		return ((ns13__ImageryMetadataOptions *)ptr)->soap_out(soap, tag, id, "ns13:ImageryMetadataOptions");
	case SOAP_TYPE_ns13__ImageryMetadataRequest:
		return ((ns13__ImageryMetadataRequest *)ptr)->soap_out(soap, tag, id, "ns13:ImageryMetadataRequest");
	case SOAP_TYPE__ns12__GetMapUriResponse:
		return ((_ns12__GetMapUriResponse *)ptr)->soap_out(soap, "ns12:GetMapUriResponse", id, NULL);
	case SOAP_TYPE__ns12__GetMapUri:
		return ((_ns12__GetMapUri *)ptr)->soap_out(soap, "ns12:GetMapUri", id, NULL);
	case SOAP_TYPE__ns12__GetImageryMetadataResponse:
		return ((_ns12__GetImageryMetadataResponse *)ptr)->soap_out(soap, "ns12:GetImageryMetadataResponse", id, NULL);
	case SOAP_TYPE__ns12__GetImageryMetadata:
		return ((_ns12__GetImageryMetadata *)ptr)->soap_out(soap, "ns12:GetImageryMetadata", id, NULL);
	case SOAP_TYPE_ns10__ReverseGeocodeRequest:
		return ((ns10__ReverseGeocodeRequest *)ptr)->soap_out(soap, tag, id, "ns10:ReverseGeocodeRequest");
	case SOAP_TYPE_ns10__GeocodeResponse:
		return ((ns10__GeocodeResponse *)ptr)->soap_out(soap, tag, id, "ns10:GeocodeResponse");
	case SOAP_TYPE_ns10__ConfidenceFilter:
		return ((ns10__ConfidenceFilter *)ptr)->soap_out(soap, tag, id, "ns10:ConfidenceFilter");
	case SOAP_TYPE_ns10__FilterBase:
		return ((ns10__FilterBase *)ptr)->soap_out(soap, tag, id, "ns10:FilterBase");
	case SOAP_TYPE_ns10__ArrayOfFilterBase:
		return ((ns10__ArrayOfFilterBase *)ptr)->soap_out(soap, tag, id, "ns10:ArrayOfFilterBase");
	case SOAP_TYPE_ns10__GeocodeOptions:
		return ((ns10__GeocodeOptions *)ptr)->soap_out(soap, tag, id, "ns10:GeocodeOptions");
	case SOAP_TYPE_ns10__GeocodeRequest:
		return ((ns10__GeocodeRequest *)ptr)->soap_out(soap, tag, id, "ns10:GeocodeRequest");
	case SOAP_TYPE__ns9__ReverseGeocodeResponse:
		return ((_ns9__ReverseGeocodeResponse *)ptr)->soap_out(soap, "ns9:ReverseGeocodeResponse", id, NULL);
	case SOAP_TYPE__ns9__ReverseGeocode:
		return ((_ns9__ReverseGeocode *)ptr)->soap_out(soap, "ns9:ReverseGeocode", id, NULL);
	case SOAP_TYPE__ns9__GeocodeResponse:
		return ((_ns9__GeocodeResponse *)ptr)->soap_out(soap, "ns9:GeocodeResponse", id, NULL);
	case SOAP_TYPE__ns9__Geocode:
		return ((_ns9__Geocode *)ptr)->soap_out(soap, "ns9:Geocode", id, NULL);
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		return ((ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *)ptr)->soap_out(soap, tag, id, "ns7:ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_P9s");
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType:
		return ((ns7__ArrayOfKeyValueOfstringanyType *)ptr)->soap_out(soap, tag, id, "ns7:ArrayOfKeyValueOfstringanyType");
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6:
		return ((ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *)ptr)->soap_out(soap, tag, id, "ns7:ArrayOfKeyValueOfNeighborhoodintkC8b0tr6");
	case SOAP_TYPE_ns7__ArrayOfanyType:
		return ((ns7__ArrayOfanyType *)ptr)->soap_out(soap, tag, id, "ns7:ArrayOfanyType");
	case SOAP_TYPE_ns7__ArrayOfstring:
		return ((ns7__ArrayOfstring *)ptr)->soap_out(soap, tag, id, "ns7:ArrayOfstring");
	case SOAP_TYPE_ns6__SearchPoint:
		return ((ns6__SearchPoint *)ptr)->soap_out(soap, tag, id, "ns6:SearchPoint");
	case SOAP_TYPE_ns6__PersonSearchResult:
		return ((ns6__PersonSearchResult *)ptr)->soap_out(soap, tag, id, "ns6:PersonSearchResult");
	case SOAP_TYPE_ns6__ArrayOfNeighborhood:
		return ((ns6__ArrayOfNeighborhood *)ptr)->soap_out(soap, tag, id, "ns6:ArrayOfNeighborhood");
	case SOAP_TYPE_ns6__CategorySpecificPropertySet:
		return ((ns6__CategorySpecificPropertySet *)ptr)->soap_out(soap, tag, id, "ns6:CategorySpecificPropertySet");
	case SOAP_TYPE_ns6__ArrayOfCategory:
		return ((ns6__ArrayOfCategory *)ptr)->soap_out(soap, tag, id, "ns6:ArrayOfCategory");
	case SOAP_TYPE_ns6__BusinessSearchResult:
		return ((ns6__BusinessSearchResult *)ptr)->soap_out(soap, tag, id, "ns6:BusinessSearchResult");
	case SOAP_TYPE_ns6__CommunityContentSearchResult:
		return ((ns6__CommunityContentSearchResult *)ptr)->soap_out(soap, tag, id, "ns6:CommunityContentSearchResult");
	case SOAP_TYPE_ns6__LocationData:
		return ((ns6__LocationData *)ptr)->soap_out(soap, tag, id, "ns6:LocationData");
	case SOAP_TYPE_ns6__SearchResultBase:
		return ((ns6__SearchResultBase *)ptr)->soap_out(soap, tag, id, "ns6:SearchResultBase");
	case SOAP_TYPE_ns6__ArrayOfSearchResultBase:
		return ((ns6__ArrayOfSearchResultBase *)ptr)->soap_out(soap, tag, id, "ns6:ArrayOfSearchResultBase");
	case SOAP_TYPE_ns6__Parse:
		return ((ns6__Parse *)ptr)->soap_out(soap, tag, id, "ns6:Parse");
	case SOAP_TYPE_ns6__CategoryCount:
		return ((ns6__CategoryCount *)ptr)->soap_out(soap, tag, id, "ns6:CategoryCount");
	case SOAP_TYPE_ns6__ArrayOfCategoryCount:
		return ((ns6__ArrayOfCategoryCount *)ptr)->soap_out(soap, tag, id, "ns6:ArrayOfCategoryCount");
	case SOAP_TYPE_ns6__FilterValue:
		return ((ns6__FilterValue *)ptr)->soap_out(soap, tag, id, "ns6:FilterValue");
	case SOAP_TYPE_ns6__Category:
		return ((ns6__Category *)ptr)->soap_out(soap, tag, id, "ns6:Category");
	case SOAP_TYPE_ns6__Neighborhood:
		return ((ns6__Neighborhood *)ptr)->soap_out(soap, tag, id, "ns6:Neighborhood");
	case SOAP_TYPE_ns6__ValueListFilter:
		return ((ns6__ValueListFilter *)ptr)->soap_out(soap, tag, id, "ns6:ValueListFilter");
	case SOAP_TYPE_ns6__RangeFilter:
		return ((ns6__RangeFilter *)ptr)->soap_out(soap, tag, id, "ns6:RangeFilter");
	case SOAP_TYPE_ns6__AvailableFilter:
		return ((ns6__AvailableFilter *)ptr)->soap_out(soap, tag, id, "ns6:AvailableFilter");
	case SOAP_TYPE_ns6__ArrayOfAvailableFilter:
		return ((ns6__ArrayOfAvailableFilter *)ptr)->soap_out(soap, tag, id, "ns6:ArrayOfAvailableFilter");
	case SOAP_TYPE_ns6__SearchRegion:
		return ((ns6__SearchRegion *)ptr)->soap_out(soap, tag, id, "ns6:SearchRegion");
	case SOAP_TYPE_ns6__ArrayOfSearchRegion:
		return ((ns6__ArrayOfSearchRegion *)ptr)->soap_out(soap, tag, id, "ns6:ArrayOfSearchRegion");
	case SOAP_TYPE_ns6__SearchResultSet:
		return ((ns6__SearchResultSet *)ptr)->soap_out(soap, tag, id, "ns6:SearchResultSet");
	case SOAP_TYPE_ns6__ArrayOfSearchResultSet:
		return ((ns6__ArrayOfSearchResultSet *)ptr)->soap_out(soap, tag, id, "ns6:ArrayOfSearchResultSet");
	case SOAP_TYPE_ns6__QuerySuggestion:
		return ((ns6__QuerySuggestion *)ptr)->soap_out(soap, tag, id, "ns6:QuerySuggestion");
	case SOAP_TYPE_ns6__SearchResponse:
		return ((ns6__SearchResponse *)ptr)->soap_out(soap, tag, id, "ns6:SearchResponse");
	case SOAP_TYPE_ns6__StructuredSearchQuery:
		return ((ns6__StructuredSearchQuery *)ptr)->soap_out(soap, tag, id, "ns6:StructuredSearchQuery");
	case SOAP_TYPE_ns6__SearchOptions:
		return ((ns6__SearchOptions *)ptr)->soap_out(soap, tag, id, "ns6:SearchOptions");
	case SOAP_TYPE_ns6__SearchRequest:
		return ((ns6__SearchRequest *)ptr)->soap_out(soap, tag, id, "ns6:SearchRequest");
	case SOAP_TYPE_ns4__Pushpin:
		return ((ns4__Pushpin *)ptr)->soap_out(soap, tag, id, "ns4:Pushpin");
	case SOAP_TYPE_ns4__ArrayOfPushpin:
		return ((ns4__ArrayOfPushpin *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfPushpin");
	case SOAP_TYPE_ns4__RangeOfdateTime:
		return ((ns4__RangeOfdateTime *)ptr)->soap_out(soap, tag, id, "ns4:RangeOfdateTime");
	case SOAP_TYPE_ns4__RangeOfint:
		return ((ns4__RangeOfint *)ptr)->soap_out(soap, tag, id, "ns4:RangeOfint");
	case SOAP_TYPE_ns4__ArrayOfGeocodeResult:
		return ((ns4__ArrayOfGeocodeResult *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfGeocodeResult");
	case SOAP_TYPE_ns4__ArrayOfGeocodeLocation:
		return ((ns4__ArrayOfGeocodeLocation *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfGeocodeLocation");
	case SOAP_TYPE_ns4__Address:
		return ((ns4__Address *)ptr)->soap_out(soap, tag, id, "ns4:Address");
	case SOAP_TYPE_ns4__GeocodeResult:
		return ((ns4__GeocodeResult *)ptr)->soap_out(soap, tag, id, "ns4:GeocodeResult");
	case SOAP_TYPE_ns4__ResponseSummary:
		return ((ns4__ResponseSummary *)ptr)->soap_out(soap, tag, id, "ns4:ResponseSummary");
	case SOAP_TYPE_ns4__ResponseBase:
		return ((ns4__ResponseBase *)ptr)->soap_out(soap, tag, id, "ns4:ResponseBase");
	case SOAP_TYPE_ns4__ArrayOfFilterExpressionBase:
		return ((ns4__ArrayOfFilterExpressionBase *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfFilterExpressionBase");
	case SOAP_TYPE_ns4__FilterExpressionClause:
		return ((ns4__FilterExpressionClause *)ptr)->soap_out(soap, tag, id, "ns4:FilterExpressionClause");
	case SOAP_TYPE_ns4__FilterExpression:
		return ((ns4__FilterExpression *)ptr)->soap_out(soap, tag, id, "ns4:FilterExpression");
	case SOAP_TYPE_ns4__FilterExpressionBase:
		return ((ns4__FilterExpressionBase *)ptr)->soap_out(soap, tag, id, "ns4:FilterExpressionBase");
	case SOAP_TYPE_ns4__SizeOfint:
		return ((ns4__SizeOfint *)ptr)->soap_out(soap, tag, id, "ns4:SizeOfint");
	case SOAP_TYPE_ns4__ArrayOfLocation:
		return ((ns4__ArrayOfLocation *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfLocation");
	case SOAP_TYPE_ns4__Polygon:
		return ((ns4__Polygon *)ptr)->soap_out(soap, tag, id, "ns4:Polygon");
	case SOAP_TYPE_ns4__Circle:
		return ((ns4__Circle *)ptr)->soap_out(soap, tag, id, "ns4:Circle");
	case SOAP_TYPE_ns4__Rectangle:
		return ((ns4__Rectangle *)ptr)->soap_out(soap, tag, id, "ns4:Rectangle");
	case SOAP_TYPE_ns4__ShapeBase:
		return ((ns4__ShapeBase *)ptr)->soap_out(soap, tag, id, "ns4:ShapeBase");
	case SOAP_TYPE_ns4__GeocodeLocation:
		return ((ns4__GeocodeLocation *)ptr)->soap_out(soap, tag, id, "ns4:GeocodeLocation");
	case SOAP_TYPE_ns4__Location:
		return ((ns4__Location *)ptr)->soap_out(soap, tag, id, "ns4:Location");
	case SOAP_TYPE_ns4__UserLocation:
		return ((ns4__UserLocation *)ptr)->soap_out(soap, tag, id, "ns4:UserLocation");
	case SOAP_TYPE_ns4__Heading:
		return ((ns4__Heading *)ptr)->soap_out(soap, tag, id, "ns4:Heading");
	case SOAP_TYPE_ns4__UserProfile:
		return ((ns4__UserProfile *)ptr)->soap_out(soap, tag, id, "ns4:UserProfile");
	case SOAP_TYPE_ns4__ExecutionOptions:
		return ((ns4__ExecutionOptions *)ptr)->soap_out(soap, tag, id, "ns4:ExecutionOptions");
	case SOAP_TYPE_ns4__Credentials:
		return ((ns4__Credentials *)ptr)->soap_out(soap, tag, id, "ns4:Credentials");
	case SOAP_TYPE_ns4__RequestBase:
		return ((ns4__RequestBase *)ptr)->soap_out(soap, tag, id, "ns4:RequestBase");
	case SOAP_TYPE__ns3__SearchResponse:
		return ((_ns3__SearchResponse *)ptr)->soap_out(soap, "ns3:SearchResponse", id, NULL);
	case SOAP_TYPE__ns3__Search:
		return ((_ns3__Search *)ptr)->soap_out(soap, "ns3:Search", id, NULL);
	case SOAP_TYPE__ns1__GetClientTokenResponse:
		return ((_ns1__GetClientTokenResponse *)ptr)->soap_out(soap, "ns1:GetClientTokenResponse", id, NULL);
	case SOAP_TYPE__ns1__GetClientToken:
		return ((_ns1__GetClientToken *)ptr)->soap_out(soap, "ns1:GetClientToken", id, NULL);
	case SOAP_TYPE__ns1__GetGreatCircleDistancesResponse:
		return ((_ns1__GetGreatCircleDistancesResponse *)ptr)->soap_out(soap, "ns1:GetGreatCircleDistancesResponse", id, NULL);
	case SOAP_TYPE__ns1__GetGreatCircleDistances:
		return ((_ns1__GetGreatCircleDistances *)ptr)->soap_out(soap, "ns1:GetGreatCircleDistances", id, NULL);
	case SOAP_TYPE__ns1__GetDataSourceInfoResponse:
		return ((_ns1__GetDataSourceInfoResponse *)ptr)->soap_out(soap, "ns1:GetDataSourceInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetDataSourceInfo:
		return ((_ns1__GetDataSourceInfo *)ptr)->soap_out(soap, "ns1:GetDataSourceInfo", id, NULL);
	case SOAP_TYPE__ns1__GetEntityTypesResponse:
		return ((_ns1__GetEntityTypesResponse *)ptr)->soap_out(soap, "ns1:GetEntityTypesResponse", id, NULL);
	case SOAP_TYPE__ns1__GetEntityTypes:
		return ((_ns1__GetEntityTypes *)ptr)->soap_out(soap, "ns1:GetEntityTypes", id, NULL);
	case SOAP_TYPE__ns1__GetCountryRegionInfoResponse:
		return ((_ns1__GetCountryRegionInfoResponse *)ptr)->soap_out(soap, "ns1:GetCountryRegionInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetCountryRegionInfo:
		return ((_ns1__GetCountryRegionInfo *)ptr)->soap_out(soap, "ns1:GetCountryRegionInfo", id, NULL);
	case SOAP_TYPE__ns1__GetVersionInfoResponse:
		return ((_ns1__GetVersionInfoResponse *)ptr)->soap_out(soap, "ns1:GetVersionInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetVersionInfo:
		return ((_ns1__GetVersionInfo *)ptr)->soap_out(soap, "ns1:GetVersionInfo", id, NULL);
	case SOAP_TYPE_ns1__TokenSpecification:
		return ((ns1__TokenSpecification *)ptr)->soap_out(soap, tag, id, "ns1:TokenSpecification");
	case SOAP_TYPE_ns1__ArrayOfDouble:
		return ((ns1__ArrayOfDouble *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfDouble");
	case SOAP_TYPE_ns1__ArrayOfLatLong:
		return ((ns1__ArrayOfLatLong *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfLatLong");
	case SOAP_TYPE_ns1__DataSource:
		return ((ns1__DataSource *)ptr)->soap_out(soap, tag, id, "ns1:DataSource");
	case SOAP_TYPE_ns1__ArrayOfDataSource:
		return ((ns1__ArrayOfDataSource *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfDataSource");
	case SOAP_TYPE_ns1__ArrayOfString:
		return ((ns1__ArrayOfString *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__EntityProperty:
		return ((ns1__EntityProperty *)ptr)->soap_out(soap, tag, id, "ns1:EntityProperty");
	case SOAP_TYPE_ns1__ArrayOfEntityProperty:
		return ((ns1__ArrayOfEntityProperty *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfEntityProperty");
	case SOAP_TYPE_ns1__EntityType:
		return ((ns1__EntityType *)ptr)->soap_out(soap, tag, id, "ns1:EntityType");
	case SOAP_TYPE_ns1__ArrayOfEntityType:
		return ((ns1__ArrayOfEntityType *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfEntityType");
	case SOAP_TYPE_ns1__LatLong:
		return ((ns1__LatLong *)ptr)->soap_out(soap, tag, id, "ns1:LatLong");
	case SOAP_TYPE_ns1__CountryRegionInfo:
		return ((ns1__CountryRegionInfo *)ptr)->soap_out(soap, tag, id, "ns1:CountryRegionInfo");
	case SOAP_TYPE_ns1__ArrayOfCountryRegionInfo:
		return ((ns1__ArrayOfCountryRegionInfo *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfCountryRegionInfo");
	case SOAP_TYPE_ns1__ArrayOfInt:
		return ((ns1__ArrayOfInt *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfInt");
	case SOAP_TYPE_ns1__CountryRegionContext:
		return ((ns1__CountryRegionContext *)ptr)->soap_out(soap, tag, id, "ns1:CountryRegionContext");
	case SOAP_TYPE_ns1__CultureInfo:
		return ((ns1__CultureInfo *)ptr)->soap_out(soap, tag, id, "ns1:CultureInfo");
	case SOAP_TYPE_ns1__UserInfoHeader:
		return ((ns1__UserInfoHeader *)ptr)->soap_out(soap, tag, id, "ns1:UserInfoHeader");
	case SOAP_TYPE_ns1__CustomerInfoHeader:
		return ((ns1__CustomerInfoHeader *)ptr)->soap_out(soap, tag, id, "ns1:CustomerInfoHeader");
	case SOAP_TYPE_ns1__VersionInfo:
		return ((ns1__VersionInfo *)ptr)->soap_out(soap, tag, id, "ns1:VersionInfo");
	case SOAP_TYPE_ns1__ArrayOfVersionInfo:
		return ((ns1__ArrayOfVersionInfo *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfVersionInfo");
	case SOAP_TYPE_xsd__unsignedShort:
		return ((xsd__unsignedShort *)ptr)->soap_out(soap, tag, id, "xsd:unsignedShort");
	case SOAP_TYPE_xsd__unsignedLong:
		return ((xsd__unsignedLong *)ptr)->soap_out(soap, tag, id, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedInt:
		return ((xsd__unsignedInt *)ptr)->soap_out(soap, tag, id, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedByte_:
		return ((xsd__unsignedByte_ *)ptr)->soap_out(soap, tag, id, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__string:
		return ((xsd__string *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__short:
		return ((xsd__short *)ptr)->soap_out(soap, tag, id, "xsd:short");
	case SOAP_TYPE_xsd__long:
		return ((xsd__long *)ptr)->soap_out(soap, tag, id, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return ((xsd__int *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__float:
		return ((xsd__float *)ptr)->soap_out(soap, tag, id, "xsd:float");
	case SOAP_TYPE_xsd__duration_:
		return ((xsd__duration_ *)ptr)->soap_out(soap, tag, id, "xsd:duration");
	case SOAP_TYPE_xsd__double:
		return ((xsd__double *)ptr)->soap_out(soap, tag, id, "xsd:double");
	case SOAP_TYPE_xsd__decimal_:
		return ((xsd__decimal_ *)ptr)->soap_out(soap, tag, id, "xsd:decimal");
	case SOAP_TYPE_xsd__dateTime:
		return ((xsd__dateTime *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__byte_:
		return ((xsd__byte_ *)ptr)->soap_out(soap, tag, id, "xsd:byte");
	case SOAP_TYPE_xsd__boolean:
		return ((xsd__boolean *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__base64Binary_:
		return ((xsd__base64Binary_ *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI_:
		return ((xsd__anyURI_ *)ptr)->soap_out(soap, tag, id, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName:
		return ((xsd__QName *)ptr)->soap_out(soap, tag, id, "xsd:QName");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_PointerTo_ns3__SearchResponse:
		return soap_out_PointerTo_ns3__SearchResponse(soap, tag, id, (_ns3__SearchResponse *const*)ptr, "ns3:SearchResponse");
	case SOAP_TYPE_PointerTo_ns3__Search:
		return soap_out_PointerTo_ns3__Search(soap, tag, id, (_ns3__Search *const*)ptr, "ns3:Search");
	case SOAP_TYPE_PointerTo_ns15__CalculateRoutesFromMajorRoadsResponse:
		return soap_out_PointerTo_ns15__CalculateRoutesFromMajorRoadsResponse(soap, tag, id, (_ns15__CalculateRoutesFromMajorRoadsResponse *const*)ptr, "ns15:CalculateRoutesFromMajorRoadsResponse");
	case SOAP_TYPE_PointerTo_ns15__CalculateRoutesFromMajorRoads:
		return soap_out_PointerTo_ns15__CalculateRoutesFromMajorRoads(soap, tag, id, (_ns15__CalculateRoutesFromMajorRoads *const*)ptr, "ns15:CalculateRoutesFromMajorRoads");
	case SOAP_TYPE_PointerTo_ns15__CalculateRouteResponse:
		return soap_out_PointerTo_ns15__CalculateRouteResponse(soap, tag, id, (_ns15__CalculateRouteResponse *const*)ptr, "ns15:CalculateRouteResponse");
	case SOAP_TYPE_PointerTo_ns15__CalculateRoute:
		return soap_out_PointerTo_ns15__CalculateRoute(soap, tag, id, (_ns15__CalculateRoute *const*)ptr, "ns15:CalculateRoute");
	case SOAP_TYPE_PointerTo_ns12__GetMapUriResponse:
		return soap_out_PointerTo_ns12__GetMapUriResponse(soap, tag, id, (_ns12__GetMapUriResponse *const*)ptr, "ns12:GetMapUriResponse");
	case SOAP_TYPE_PointerTo_ns12__GetMapUri:
		return soap_out_PointerTo_ns12__GetMapUri(soap, tag, id, (_ns12__GetMapUri *const*)ptr, "ns12:GetMapUri");
	case SOAP_TYPE_PointerTo_ns12__GetImageryMetadataResponse:
		return soap_out_PointerTo_ns12__GetImageryMetadataResponse(soap, tag, id, (_ns12__GetImageryMetadataResponse *const*)ptr, "ns12:GetImageryMetadataResponse");
	case SOAP_TYPE_PointerTo_ns12__GetImageryMetadata:
		return soap_out_PointerTo_ns12__GetImageryMetadata(soap, tag, id, (_ns12__GetImageryMetadata *const*)ptr, "ns12:GetImageryMetadata");
	case SOAP_TYPE_PointerTo_ns9__ReverseGeocodeResponse:
		return soap_out_PointerTo_ns9__ReverseGeocodeResponse(soap, tag, id, (_ns9__ReverseGeocodeResponse *const*)ptr, "ns9:ReverseGeocodeResponse");
	case SOAP_TYPE_PointerTo_ns9__ReverseGeocode:
		return soap_out_PointerTo_ns9__ReverseGeocode(soap, tag, id, (_ns9__ReverseGeocode *const*)ptr, "ns9:ReverseGeocode");
	case SOAP_TYPE_PointerTo_ns9__GeocodeResponse:
		return soap_out_PointerTo_ns9__GeocodeResponse(soap, tag, id, (_ns9__GeocodeResponse *const*)ptr, "ns9:GeocodeResponse");
	case SOAP_TYPE_PointerTo_ns9__Geocode:
		return soap_out_PointerTo_ns9__Geocode(soap, tag, id, (_ns9__Geocode *const*)ptr, "ns9:Geocode");
	case SOAP_TYPE_PointerTo_ns1__GetClientTokenResponse:
		return soap_out_PointerTo_ns1__GetClientTokenResponse(soap, tag, id, (_ns1__GetClientTokenResponse *const*)ptr, "ns1:GetClientTokenResponse");
	case SOAP_TYPE_PointerTo_ns1__GetClientToken:
		return soap_out_PointerTo_ns1__GetClientToken(soap, tag, id, (_ns1__GetClientToken *const*)ptr, "ns1:GetClientToken");
	case SOAP_TYPE_PointerTo_ns1__GetGreatCircleDistancesResponse:
		return soap_out_PointerTo_ns1__GetGreatCircleDistancesResponse(soap, tag, id, (_ns1__GetGreatCircleDistancesResponse *const*)ptr, "ns1:GetGreatCircleDistancesResponse");
	case SOAP_TYPE_PointerTo_ns1__GetGreatCircleDistances:
		return soap_out_PointerTo_ns1__GetGreatCircleDistances(soap, tag, id, (_ns1__GetGreatCircleDistances *const*)ptr, "ns1:GetGreatCircleDistances");
	case SOAP_TYPE_PointerTo_ns1__GetDataSourceInfoResponse:
		return soap_out_PointerTo_ns1__GetDataSourceInfoResponse(soap, tag, id, (_ns1__GetDataSourceInfoResponse *const*)ptr, "ns1:GetDataSourceInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetDataSourceInfo:
		return soap_out_PointerTo_ns1__GetDataSourceInfo(soap, tag, id, (_ns1__GetDataSourceInfo *const*)ptr, "ns1:GetDataSourceInfo");
	case SOAP_TYPE_PointerTo_ns1__GetEntityTypesResponse:
		return soap_out_PointerTo_ns1__GetEntityTypesResponse(soap, tag, id, (_ns1__GetEntityTypesResponse *const*)ptr, "ns1:GetEntityTypesResponse");
	case SOAP_TYPE_PointerTo_ns1__GetEntityTypes:
		return soap_out_PointerTo_ns1__GetEntityTypes(soap, tag, id, (_ns1__GetEntityTypes *const*)ptr, "ns1:GetEntityTypes");
	case SOAP_TYPE_PointerTo_ns1__GetCountryRegionInfoResponse:
		return soap_out_PointerTo_ns1__GetCountryRegionInfoResponse(soap, tag, id, (_ns1__GetCountryRegionInfoResponse *const*)ptr, "ns1:GetCountryRegionInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetCountryRegionInfo:
		return soap_out_PointerTo_ns1__GetCountryRegionInfo(soap, tag, id, (_ns1__GetCountryRegionInfo *const*)ptr, "ns1:GetCountryRegionInfo");
	case SOAP_TYPE_PointerTo_ns1__GetVersionInfoResponse:
		return soap_out_PointerTo_ns1__GetVersionInfoResponse(soap, tag, id, (_ns1__GetVersionInfoResponse *const*)ptr, "ns1:GetVersionInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetVersionInfo:
		return soap_out_PointerTo_ns1__GetVersionInfo(soap, tag, id, (_ns1__GetVersionInfo *const*)ptr, "ns1:GetVersionInfo");
	case SOAP_TYPE_PointerTons1__UserInfoHeader:
		return soap_out_PointerTons1__UserInfoHeader(soap, tag, id, (ns1__UserInfoHeader *const*)ptr, "ns1:UserInfoHeader");
	case SOAP_TYPE_PointerTons1__CustomerInfoHeader:
		return soap_out_PointerTons1__CustomerInfoHeader(soap, tag, id, (ns1__CustomerInfoHeader *const*)ptr, "ns1:CustomerInfoHeader");
	case SOAP_TYPE_PointerTons16__ArrayOfRouteResult:
		return soap_out_PointerTons16__ArrayOfRouteResult(soap, tag, id, (ns16__ArrayOfRouteResult *const*)ptr, "ns16:ArrayOfRouteResult");
	case SOAP_TYPE_PointerTons16__MajorRoutesOptions:
		return soap_out_PointerTons16__MajorRoutesOptions(soap, tag, id, (ns16__MajorRoutesOptions *const*)ptr, "ns16:MajorRoutesOptions");
	case SOAP_TYPE_PointerTons16__ArrayOfWaypoint:
		return soap_out_PointerTons16__ArrayOfWaypoint(soap, tag, id, (ns16__ArrayOfWaypoint *const*)ptr, "ns16:ArrayOfWaypoint");
	case SOAP_TYPE_PointerTons16__RouteOptions:
		return soap_out_PointerTons16__RouteOptions(soap, tag, id, (ns16__RouteOptions *const*)ptr, "ns16:RouteOptions");
	case SOAP_TYPE_PointerTons4__ArrayOfPushpin:
		return soap_out_PointerTons4__ArrayOfPushpin(soap, tag, id, (ns4__ArrayOfPushpin *const*)ptr, "ns4:ArrayOfPushpin");
	case SOAP_TYPE_PointerTons13__MapUriOptions:
		return soap_out_PointerTons13__MapUriOptions(soap, tag, id, (ns13__MapUriOptions *const*)ptr, "ns13:MapUriOptions");
	case SOAP_TYPE_PointerTons13__ArrayOfImageryMetadataResult:
		return soap_out_PointerTons13__ArrayOfImageryMetadataResult(soap, tag, id, (ns13__ArrayOfImageryMetadataResult *const*)ptr, "ns13:ArrayOfImageryMetadataResult");
	case SOAP_TYPE_PointerTons13__ImageryMetadataOptions:
		return soap_out_PointerTons13__ImageryMetadataOptions(soap, tag, id, (ns13__ImageryMetadataOptions *const*)ptr, "ns13:ImageryMetadataOptions");
	case SOAP_TYPE_PointerTons4__ArrayOfGeocodeResult:
		return soap_out_PointerTons4__ArrayOfGeocodeResult(soap, tag, id, (ns4__ArrayOfGeocodeResult *const*)ptr, "ns4:ArrayOfGeocodeResult");
	case SOAP_TYPE_PointerTons10__GeocodeOptions:
		return soap_out_PointerTons10__GeocodeOptions(soap, tag, id, (ns10__GeocodeOptions *const*)ptr, "ns10:GeocodeOptions");
	case SOAP_TYPE_PointerTons6__ArrayOfNeighborhood:
		return soap_out_PointerTons6__ArrayOfNeighborhood(soap, tag, id, (ns6__ArrayOfNeighborhood *const*)ptr, "ns6:ArrayOfNeighborhood");
	case SOAP_TYPE_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		return soap_out_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, tag, id, (ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *const*)ptr, "ns7:ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_P9s");
	case SOAP_TYPE_PointerTons6__ArrayOfCategory:
		return soap_out_PointerTons6__ArrayOfCategory(soap, tag, id, (ns6__ArrayOfCategory *const*)ptr, "ns6:ArrayOfCategory");
	case SOAP_TYPE_PointerTons7__ArrayOfanyType:
		return soap_out_PointerTons7__ArrayOfanyType(soap, tag, id, (ns7__ArrayOfanyType *const*)ptr, "ns7:ArrayOfanyType");
	case SOAP_TYPE_PointerTons6__ArrayOfSearchResultSet:
		return soap_out_PointerTons6__ArrayOfSearchResultSet(soap, tag, id, (ns6__ArrayOfSearchResultSet *const*)ptr, "ns6:ArrayOfSearchResultSet");
	case SOAP_TYPE_PointerTons6__QuerySuggestion:
		return soap_out_PointerTons6__QuerySuggestion(soap, tag, id, (ns6__QuerySuggestion *const*)ptr, "ns6:QuerySuggestion");
	case SOAP_TYPE_PointerTons6__SearchOptions:
		return soap_out_PointerTons6__SearchOptions(soap, tag, id, (ns6__SearchOptions *const*)ptr, "ns6:SearchOptions");
	case SOAP_TYPE_PointerTons4__LogicalOperator:
		return soap_out_PointerTons4__LogicalOperator(soap, tag, id, (enum ns4__LogicalOperator *const*)ptr, "ns4:LogicalOperator");
	case SOAP_TYPE_PointerTons4__ArrayOfFilterExpressionBase:
		return soap_out_PointerTons4__ArrayOfFilterExpressionBase(soap, tag, id, (ns4__ArrayOfFilterExpressionBase *const*)ptr, "ns4:ArrayOfFilterExpressionBase");
	case SOAP_TYPE_PointerTons4__CompareOperator:
		return soap_out_PointerTons4__CompareOperator(soap, tag, id, (enum ns4__CompareOperator *const*)ptr, "ns4:CompareOperator");
	case SOAP_TYPE_PointerToPointerTons16__RouteResult:
		return soap_out_PointerToPointerTons16__RouteResult(soap, tag, id, (ns16__RouteResult **const*)ptr, "ns16:RouteResult");
	case SOAP_TYPE_PointerTons16__RouteResult:
		return soap_out_PointerTons16__RouteResult(soap, tag, id, (ns16__RouteResult *const*)ptr, "ns16:RouteResult");
	case SOAP_TYPE_PointerTons4__ArrayOfLocation:
		return soap_out_PointerTons4__ArrayOfLocation(soap, tag, id, (ns4__ArrayOfLocation *const*)ptr, "ns4:ArrayOfLocation");
	case SOAP_TYPE_PointerTons16__ItineraryWarningType:
		return soap_out_PointerTons16__ItineraryWarningType(soap, tag, id, (enum ns16__ItineraryWarningType *const*)ptr, "ns16:ItineraryWarningType");
	case SOAP_TYPE_PointerTons16__ItineraryWarningSeverity:
		return soap_out_PointerTons16__ItineraryWarningSeverity(soap, tag, id, (enum ns16__ItineraryWarningSeverity *const*)ptr, "ns16:ItineraryWarningSeverity");
	case SOAP_TYPE_PointerToPointerTons16__ItineraryItemWarning:
		return soap_out_PointerToPointerTons16__ItineraryItemWarning(soap, tag, id, (ns16__ItineraryItemWarning **const*)ptr, "ns16:ItineraryItemWarning");
	case SOAP_TYPE_PointerTons16__ItineraryItemWarning:
		return soap_out_PointerTons16__ItineraryItemWarning(soap, tag, id, (ns16__ItineraryItemWarning *const*)ptr, "ns16:ItineraryItemWarning");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerTons16__ItineraryItemHintType:
		return soap_out_PointerTons16__ItineraryItemHintType(soap, tag, id, (enum ns16__ItineraryItemHintType *const*)ptr, "ns16:ItineraryItemHintType");
	case SOAP_TYPE_PointerToPointerTons16__ItineraryItemHint:
		return soap_out_PointerToPointerTons16__ItineraryItemHint(soap, tag, id, (ns16__ItineraryItemHint **const*)ptr, "ns16:ItineraryItemHint");
	case SOAP_TYPE_PointerTons16__ItineraryItemHint:
		return soap_out_PointerTons16__ItineraryItemHint(soap, tag, id, (ns16__ItineraryItemHint *const*)ptr, "ns16:ItineraryItemHint");
	case SOAP_TYPE_PointerTons16__ArrayOfItineraryItemWarning:
		return soap_out_PointerTons16__ArrayOfItineraryItemWarning(soap, tag, id, (ns16__ArrayOfItineraryItemWarning *const*)ptr, "ns16:ArrayOfItineraryItemWarning");
	case SOAP_TYPE_PointerTons16__ManeuverType:
		return soap_out_PointerTons16__ManeuverType(soap, tag, id, (enum ns16__ManeuverType *const*)ptr, "ns16:ManeuverType");
	case SOAP_TYPE_PointerTons16__ArrayOfItineraryItemHint:
		return soap_out_PointerTons16__ArrayOfItineraryItemHint(soap, tag, id, (ns16__ArrayOfItineraryItemHint *const*)ptr, "ns16:ArrayOfItineraryItemHint");
	case SOAP_TYPE_PointerToPointerTons16__ItineraryItem:
		return soap_out_PointerToPointerTons16__ItineraryItem(soap, tag, id, (ns16__ItineraryItem **const*)ptr, "ns16:ItineraryItem");
	case SOAP_TYPE_PointerTons16__ItineraryItem:
		return soap_out_PointerTons16__ItineraryItem(soap, tag, id, (ns16__ItineraryItem *const*)ptr, "ns16:ItineraryItem");
	case SOAP_TYPE_PointerTons16__ArrayOfItineraryItem:
		return soap_out_PointerTons16__ArrayOfItineraryItem(soap, tag, id, (ns16__ArrayOfItineraryItem *const*)ptr, "ns16:ArrayOfItineraryItem");
	case SOAP_TYPE_PointerToPointerTons16__RouteLeg:
		return soap_out_PointerToPointerTons16__RouteLeg(soap, tag, id, (ns16__RouteLeg **const*)ptr, "ns16:RouteLeg");
	case SOAP_TYPE_PointerTons16__RouteLeg:
		return soap_out_PointerTons16__RouteLeg(soap, tag, id, (ns16__RouteLeg *const*)ptr, "ns16:RouteLeg");
	case SOAP_TYPE_PointerTons16__RouteSummary:
		return soap_out_PointerTons16__RouteSummary(soap, tag, id, (ns16__RouteSummary *const*)ptr, "ns16:RouteSummary");
	case SOAP_TYPE_PointerTons16__RoutePath:
		return soap_out_PointerTons16__RoutePath(soap, tag, id, (ns16__RoutePath *const*)ptr, "ns16:RoutePath");
	case SOAP_TYPE_PointerTons16__ArrayOfRouteLeg:
		return soap_out_PointerTons16__ArrayOfRouteLeg(soap, tag, id, (ns16__ArrayOfRouteLeg *const*)ptr, "ns16:ArrayOfRouteLeg");
	case SOAP_TYPE_PointerToPointerTons16__Waypoint:
		return soap_out_PointerToPointerTons16__Waypoint(soap, tag, id, (ns16__Waypoint **const*)ptr, "ns16:Waypoint");
	case SOAP_TYPE_PointerTons16__Waypoint:
		return soap_out_PointerTons16__Waypoint(soap, tag, id, (ns16__Waypoint *const*)ptr, "ns16:Waypoint");
	case SOAP_TYPE_PointerTons16__TrafficUsage:
		return soap_out_PointerTons16__TrafficUsage(soap, tag, id, (enum ns16__TrafficUsage *const*)ptr, "ns16:TrafficUsage");
	case SOAP_TYPE_PointerTons16__RoutePathType:
		return soap_out_PointerTons16__RoutePathType(soap, tag, id, (enum ns16__RoutePathType *const*)ptr, "ns16:RoutePathType");
	case SOAP_TYPE_PointerTons16__RouteOptimization:
		return soap_out_PointerTons16__RouteOptimization(soap, tag, id, (enum ns16__RouteOptimization *const*)ptr, "ns16:RouteOptimization");
	case SOAP_TYPE_PointerTons16__TravelMode:
		return soap_out_PointerTons16__TravelMode(soap, tag, id, (enum ns16__TravelMode *const*)ptr, "ns16:TravelMode");
	case SOAP_TYPE_PointerTons16__MajorRoutesResponse:
		return soap_out_PointerTons16__MajorRoutesResponse(soap, tag, id, (ns16__MajorRoutesResponse *const*)ptr, "ns16:MajorRoutesResponse");
	case SOAP_TYPE_PointerTons16__MajorRoutesRequest:
		return soap_out_PointerTons16__MajorRoutesRequest(soap, tag, id, (ns16__MajorRoutesRequest *const*)ptr, "ns16:MajorRoutesRequest");
	case SOAP_TYPE_PointerTons16__RouteResponse:
		return soap_out_PointerTons16__RouteResponse(soap, tag, id, (ns16__RouteResponse *const*)ptr, "ns16:RouteResponse");
	case SOAP_TYPE_PointerTons16__RouteRequest:
		return soap_out_PointerTons16__RouteRequest(soap, tag, id, (ns16__RouteRequest *const*)ptr, "ns16:RouteRequest");
	case SOAP_TYPE_PointerTons4__MapStyle:
		return soap_out_PointerTons4__MapStyle(soap, tag, id, (enum ns4__MapStyle *const*)ptr, "ns4:MapStyle");
	case SOAP_TYPE_PointerTons4__ImageType:
		return soap_out_PointerTons4__ImageType(soap, tag, id, (enum ns4__ImageType *const*)ptr, "ns4:ImageType");
	case SOAP_TYPE_PointerToPointerTons13__CoverageArea:
		return soap_out_PointerToPointerTons13__CoverageArea(soap, tag, id, (ns13__CoverageArea **const*)ptr, "ns13:CoverageArea");
	case SOAP_TYPE_PointerTons13__CoverageArea:
		return soap_out_PointerTons13__CoverageArea(soap, tag, id, (ns13__CoverageArea *const*)ptr, "ns13:CoverageArea");
	case SOAP_TYPE_PointerTons13__ArrayOfCoverageArea:
		return soap_out_PointerTons13__ArrayOfCoverageArea(soap, tag, id, (ns13__ArrayOfCoverageArea *const*)ptr, "ns13:ArrayOfCoverageArea");
	case SOAP_TYPE_PointerToPointerTons13__ImageryProvider:
		return soap_out_PointerToPointerTons13__ImageryProvider(soap, tag, id, (ns13__ImageryProvider **const*)ptr, "ns13:ImageryProvider");
	case SOAP_TYPE_PointerTons13__ImageryProvider:
		return soap_out_PointerTons13__ImageryProvider(soap, tag, id, (ns13__ImageryProvider *const*)ptr, "ns13:ImageryProvider");
	case SOAP_TYPE_PointerTons4__RangeOfint:
		return soap_out_PointerTons4__RangeOfint(soap, tag, id, (ns4__RangeOfint *const*)ptr, "ns4:RangeOfint");
	case SOAP_TYPE_PointerTons4__RangeOfdateTime:
		return soap_out_PointerTons4__RangeOfdateTime(soap, tag, id, (ns4__RangeOfdateTime *const*)ptr, "ns4:RangeOfdateTime");
	case SOAP_TYPE_PointerTons13__ArrayOfImageryProvider:
		return soap_out_PointerTons13__ArrayOfImageryProvider(soap, tag, id, (ns13__ArrayOfImageryProvider *const*)ptr, "ns13:ArrayOfImageryProvider");
	case SOAP_TYPE_PointerToPointerTons13__ImageryMetadataResult:
		return soap_out_PointerToPointerTons13__ImageryMetadataResult(soap, tag, id, (ns13__ImageryMetadataResult **const*)ptr, "ns13:ImageryMetadataResult");
	case SOAP_TYPE_PointerTons13__ImageryMetadataResult:
		return soap_out_PointerTons13__ImageryMetadataResult(soap, tag, id, (ns13__ImageryMetadataResult *const*)ptr, "ns13:ImageryMetadataResult");
	case SOAP_TYPE_PointerTons4__UriScheme:
		return soap_out_PointerTons4__UriScheme(soap, tag, id, (enum ns4__UriScheme *const*)ptr, "ns4:UriScheme");
	case SOAP_TYPE_PointerTons13__MapUriResponse:
		return soap_out_PointerTons13__MapUriResponse(soap, tag, id, (ns13__MapUriResponse *const*)ptr, "ns13:MapUriResponse");
	case SOAP_TYPE_PointerTons13__MapUriRequest:
		return soap_out_PointerTons13__MapUriRequest(soap, tag, id, (ns13__MapUriRequest *const*)ptr, "ns13:MapUriRequest");
	case SOAP_TYPE_PointerTons13__ImageryMetadataResponse:
		return soap_out_PointerTons13__ImageryMetadataResponse(soap, tag, id, (ns13__ImageryMetadataResponse *const*)ptr, "ns13:ImageryMetadataResponse");
	case SOAP_TYPE_PointerTons13__ImageryMetadataRequest:
		return soap_out_PointerTons13__ImageryMetadataRequest(soap, tag, id, (ns13__ImageryMetadataRequest *const*)ptr, "ns13:ImageryMetadataRequest");
	case SOAP_TYPE_PointerToPointerTons10__FilterBase:
		return soap_out_PointerToPointerTons10__FilterBase(soap, tag, id, (ns10__FilterBase **const*)ptr, "ns10:FilterBase");
	case SOAP_TYPE_PointerTons10__FilterBase:
		return soap_out_PointerTons10__FilterBase(soap, tag, id, (ns10__FilterBase *const*)ptr, "ns10:FilterBase");
	case SOAP_TYPE_PointerTons10__ArrayOfFilterBase:
		return soap_out_PointerTons10__ArrayOfFilterBase(soap, tag, id, (ns10__ArrayOfFilterBase *const*)ptr, "ns10:ArrayOfFilterBase");
	case SOAP_TYPE_PointerTons10__ReverseGeocodeRequest:
		return soap_out_PointerTons10__ReverseGeocodeRequest(soap, tag, id, (ns10__ReverseGeocodeRequest *const*)ptr, "ns10:ReverseGeocodeRequest");
	case SOAP_TYPE_PointerTons10__GeocodeResponse:
		return soap_out_PointerTons10__GeocodeResponse(soap, tag, id, (ns10__GeocodeResponse *const*)ptr, "ns10:GeocodeResponse");
	case SOAP_TYPE_PointerTons10__GeocodeRequest:
		return soap_out_PointerTons10__GeocodeRequest(soap, tag, id, (ns10__GeocodeRequest *const*)ptr, "ns10:GeocodeRequest");
	case SOAP_TYPE_PointerTo_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		return soap_out_PointerTo_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, tag, id, (_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *const*)ptr, "ns7:ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_P9s-KeyValueOfintCategorySpecificPropertySetn6Q9q_P9s");
	case SOAP_TYPE_PointerTons6__CategorySpecificPropertySet:
		return soap_out_PointerTons6__CategorySpecificPropertySet(soap, tag, id, (ns6__CategorySpecificPropertySet *const*)ptr, "ns6:CategorySpecificPropertySet");
	case SOAP_TYPE_PointerTo_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType:
		return soap_out_PointerTo_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(soap, tag, id, (_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *const*)ptr, "ns7:ArrayOfKeyValueOfstringanyType-KeyValueOfstringanyType");
	case SOAP_TYPE_PointerTo_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6:
		return soap_out_PointerTo_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(soap, tag, id, (_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *const*)ptr, "ns7:ArrayOfKeyValueOfNeighborhoodintkC8b0tr6-KeyValueOfNeighborhoodintkC8b0tr6");
	case SOAP_TYPE_PointerToPointerToxsd__anyType:
		return soap_out_PointerToPointerToxsd__anyType(soap, tag, id, (xsd__anyType **const*)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_out_PointerToxsd__anyType(soap, tag, id, (xsd__anyType *const*)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerToPointerTons6__Neighborhood:
		return soap_out_PointerToPointerTons6__Neighborhood(soap, tag, id, (ns6__Neighborhood **const*)ptr, "ns6:Neighborhood");
	case SOAP_TYPE_PointerTons6__Neighborhood:
		return soap_out_PointerTons6__Neighborhood(soap, tag, id, (ns6__Neighborhood *const*)ptr, "ns6:Neighborhood");
	case SOAP_TYPE_PointerTons7__ArrayOfKeyValueOfstringanyType:
		return soap_out_PointerTons7__ArrayOfKeyValueOfstringanyType(soap, tag, id, (ns7__ArrayOfKeyValueOfstringanyType *const*)ptr, "ns7:ArrayOfKeyValueOfstringanyType");
	case SOAP_TYPE_PointerToPointerTons6__Category:
		return soap_out_PointerToPointerTons6__Category(soap, tag, id, (ns6__Category **const*)ptr, "ns6:Category");
	case SOAP_TYPE_PointerTons6__LocationData:
		return soap_out_PointerTons6__LocationData(soap, tag, id, (ns6__LocationData *const*)ptr, "ns6:LocationData");
	case SOAP_TYPE_PointerToPointerTons6__SearchResultBase:
		return soap_out_PointerToPointerTons6__SearchResultBase(soap, tag, id, (ns6__SearchResultBase **const*)ptr, "ns6:SearchResultBase");
	case SOAP_TYPE_PointerTons6__SearchResultBase:
		return soap_out_PointerTons6__SearchResultBase(soap, tag, id, (ns6__SearchResultBase *const*)ptr, "ns6:SearchResultBase");
	case SOAP_TYPE_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6:
		return soap_out_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, tag, id, (ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *const*)ptr, "ns7:ArrayOfKeyValueOfNeighborhoodintkC8b0tr6");
	case SOAP_TYPE_PointerTons6__Category:
		return soap_out_PointerTons6__Category(soap, tag, id, (ns6__Category *const*)ptr, "ns6:Category");
	case SOAP_TYPE_PointerToPointerTons6__CategoryCount:
		return soap_out_PointerToPointerTons6__CategoryCount(soap, tag, id, (ns6__CategoryCount **const*)ptr, "ns6:CategoryCount");
	case SOAP_TYPE_PointerTons6__CategoryCount:
		return soap_out_PointerTons6__CategoryCount(soap, tag, id, (ns6__CategoryCount *const*)ptr, "ns6:CategoryCount");
	case SOAP_TYPE_PointerToPointerTons6__AvailableFilter:
		return soap_out_PointerToPointerTons6__AvailableFilter(soap, tag, id, (ns6__AvailableFilter **const*)ptr, "ns6:AvailableFilter");
	case SOAP_TYPE_PointerTons6__AvailableFilter:
		return soap_out_PointerTons6__AvailableFilter(soap, tag, id, (ns6__AvailableFilter *const*)ptr, "ns6:AvailableFilter");
	case SOAP_TYPE_PointerToPointerTons6__SearchRegion:
		return soap_out_PointerToPointerTons6__SearchRegion(soap, tag, id, (ns6__SearchRegion **const*)ptr, "ns6:SearchRegion");
	case SOAP_TYPE_PointerTons6__SearchRegion:
		return soap_out_PointerTons6__SearchRegion(soap, tag, id, (ns6__SearchRegion *const*)ptr, "ns6:SearchRegion");
	case SOAP_TYPE_PointerTons6__ArrayOfSearchResultBase:
		return soap_out_PointerTons6__ArrayOfSearchResultBase(soap, tag, id, (ns6__ArrayOfSearchResultBase *const*)ptr, "ns6:ArrayOfSearchResultBase");
	case SOAP_TYPE_PointerTons6__Parse:
		return soap_out_PointerTons6__Parse(soap, tag, id, (ns6__Parse *const*)ptr, "ns6:Parse");
	case SOAP_TYPE_PointerTons6__ArrayOfCategoryCount:
		return soap_out_PointerTons6__ArrayOfCategoryCount(soap, tag, id, (ns6__ArrayOfCategoryCount *const*)ptr, "ns6:ArrayOfCategoryCount");
	case SOAP_TYPE_PointerTons6__ArrayOfAvailableFilter:
		return soap_out_PointerTons6__ArrayOfAvailableFilter(soap, tag, id, (ns6__ArrayOfAvailableFilter *const*)ptr, "ns6:ArrayOfAvailableFilter");
	case SOAP_TYPE_PointerTons6__ArrayOfSearchRegion:
		return soap_out_PointerTons6__ArrayOfSearchRegion(soap, tag, id, (ns6__ArrayOfSearchRegion *const*)ptr, "ns6:ArrayOfSearchRegion");
	case SOAP_TYPE_PointerToPointerTons6__SearchResultSet:
		return soap_out_PointerToPointerTons6__SearchResultSet(soap, tag, id, (ns6__SearchResultSet **const*)ptr, "ns6:SearchResultSet");
	case SOAP_TYPE_PointerTons6__SearchResultSet:
		return soap_out_PointerTons6__SearchResultSet(soap, tag, id, (ns6__SearchResultSet *const*)ptr, "ns6:SearchResultSet");
	case SOAP_TYPE_PointerTons6__StructuredSearchQuery:
		return soap_out_PointerTons6__StructuredSearchQuery(soap, tag, id, (ns6__StructuredSearchQuery *const*)ptr, "ns6:StructuredSearchQuery");
	case SOAP_TYPE_PointerTons6__SortOrder:
		return soap_out_PointerTons6__SortOrder(soap, tag, id, (enum ns6__SortOrder *const*)ptr, "ns6:SortOrder");
	case SOAP_TYPE_PointerTons6__ListingType:
		return soap_out_PointerTons6__ListingType(soap, tag, id, (enum ns6__ListingType *const*)ptr, "ns6:ListingType");
	case SOAP_TYPE_PointerToPointerTons4__Pushpin:
		return soap_out_PointerToPointerTons4__Pushpin(soap, tag, id, (ns4__Pushpin **const*)ptr, "ns4:Pushpin");
	case SOAP_TYPE_PointerTons4__Pushpin:
		return soap_out_PointerTons4__Pushpin(soap, tag, id, (ns4__Pushpin *const*)ptr, "ns4:Pushpin");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerToPointerTons4__GeocodeResult:
		return soap_out_PointerToPointerTons4__GeocodeResult(soap, tag, id, (ns4__GeocodeResult **const*)ptr, "ns4:GeocodeResult");
	case SOAP_TYPE_PointerTons4__GeocodeResult:
		return soap_out_PointerTons4__GeocodeResult(soap, tag, id, (ns4__GeocodeResult *const*)ptr, "ns4:GeocodeResult");
	case SOAP_TYPE_PointerToPointerTons4__GeocodeLocation:
		return soap_out_PointerToPointerTons4__GeocodeLocation(soap, tag, id, (ns4__GeocodeLocation **const*)ptr, "ns4:GeocodeLocation");
	case SOAP_TYPE_PointerTons4__GeocodeLocation:
		return soap_out_PointerTons4__GeocodeLocation(soap, tag, id, (ns4__GeocodeLocation *const*)ptr, "ns4:GeocodeLocation");
	case SOAP_TYPE_PointerTons7__ArrayOfstring:
		return soap_out_PointerTons7__ArrayOfstring(soap, tag, id, (ns7__ArrayOfstring *const*)ptr, "ns7:ArrayOfstring");
	case SOAP_TYPE_PointerTons4__ArrayOfGeocodeLocation:
		return soap_out_PointerTons4__ArrayOfGeocodeLocation(soap, tag, id, (ns4__ArrayOfGeocodeLocation *const*)ptr, "ns4:ArrayOfGeocodeLocation");
	case SOAP_TYPE_PointerTons4__Confidence:
		return soap_out_PointerTons4__Confidence(soap, tag, id, (enum ns4__Confidence *const*)ptr, "ns4:Confidence");
	case SOAP_TYPE_PointerTons4__Rectangle:
		return soap_out_PointerTons4__Rectangle(soap, tag, id, (ns4__Rectangle *const*)ptr, "ns4:Rectangle");
	case SOAP_TYPE_PointerTons4__Address:
		return soap_out_PointerTons4__Address(soap, tag, id, (ns4__Address *const*)ptr, "ns4:Address");
	case SOAP_TYPE_PointerTons4__ResponseStatusCode:
		return soap_out_PointerTons4__ResponseStatusCode(soap, tag, id, (enum ns4__ResponseStatusCode *const*)ptr, "ns4:ResponseStatusCode");
	case SOAP_TYPE_PointerTons4__AuthenticationResultCode:
		return soap_out_PointerTons4__AuthenticationResultCode(soap, tag, id, (enum ns4__AuthenticationResultCode *const*)ptr, "ns4:AuthenticationResultCode");
	case SOAP_TYPE_PointerTons4__ResponseSummary:
		return soap_out_PointerTons4__ResponseSummary(soap, tag, id, (ns4__ResponseSummary *const*)ptr, "ns4:ResponseSummary");
	case SOAP_TYPE_PointerToPointerTons4__FilterExpressionBase:
		return soap_out_PointerToPointerTons4__FilterExpressionBase(soap, tag, id, (ns4__FilterExpressionBase **const*)ptr, "ns4:FilterExpressionBase");
	case SOAP_TYPE_PointerTons4__FilterExpressionBase:
		return soap_out_PointerTons4__FilterExpressionBase(soap, tag, id, (ns4__FilterExpressionBase *const*)ptr, "ns4:FilterExpressionBase");
	case SOAP_TYPE_PointerToPointerTons4__Location:
		return soap_out_PointerToPointerTons4__Location(soap, tag, id, (ns4__Location **const*)ptr, "ns4:Location");
	case SOAP_TYPE_PointerTons4__Location:
		return soap_out_PointerTons4__Location(soap, tag, id, (ns4__Location *const*)ptr, "ns4:Location");
	case SOAP_TYPE_PointerTons4__SizeOfint:
		return soap_out_PointerTons4__SizeOfint(soap, tag, id, (ns4__SizeOfint *const*)ptr, "ns4:SizeOfint");
	case SOAP_TYPE_PointerTons4__ShapeBase:
		return soap_out_PointerTons4__ShapeBase(soap, tag, id, (ns4__ShapeBase *const*)ptr, "ns4:ShapeBase");
	case SOAP_TYPE_PointerTons4__DistanceUnit:
		return soap_out_PointerTons4__DistanceUnit(soap, tag, id, (enum ns4__DistanceUnit *const*)ptr, "ns4:DistanceUnit");
	case SOAP_TYPE_PointerTons4__DeviceType:
		return soap_out_PointerTons4__DeviceType(soap, tag, id, (enum ns4__DeviceType *const*)ptr, "ns4:DeviceType");
	case SOAP_TYPE_PointerTons4__UserLocation:
		return soap_out_PointerTons4__UserLocation(soap, tag, id, (ns4__UserLocation *const*)ptr, "ns4:UserLocation");
	case SOAP_TYPE_PointerTons4__Heading:
		return soap_out_PointerTons4__Heading(soap, tag, id, (ns4__Heading *const*)ptr, "ns4:Heading");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons4__UserProfile:
		return soap_out_PointerTons4__UserProfile(soap, tag, id, (ns4__UserProfile *const*)ptr, "ns4:UserProfile");
	case SOAP_TYPE_PointerTons4__ExecutionOptions:
		return soap_out_PointerTons4__ExecutionOptions(soap, tag, id, (ns4__ExecutionOptions *const*)ptr, "ns4:ExecutionOptions");
	case SOAP_TYPE_PointerTons4__Credentials:
		return soap_out_PointerTons4__Credentials(soap, tag, id, (ns4__Credentials *const*)ptr, "ns4:Credentials");
	case SOAP_TYPE_PointerTons6__SearchResponse:
		return soap_out_PointerTons6__SearchResponse(soap, tag, id, (ns6__SearchResponse *const*)ptr, "ns6:SearchResponse");
	case SOAP_TYPE_PointerTons6__SearchRequest:
		return soap_out_PointerTons6__SearchRequest(soap, tag, id, (ns6__SearchRequest *const*)ptr, "ns6:SearchRequest");
	case SOAP_TYPE_PointerTons1__TokenSpecification:
		return soap_out_PointerTons1__TokenSpecification(soap, tag, id, (ns1__TokenSpecification *const*)ptr, "ns1:TokenSpecification");
	case SOAP_TYPE_PointerTons1__ArrayOfDouble:
		return soap_out_PointerTons1__ArrayOfDouble(soap, tag, id, (ns1__ArrayOfDouble *const*)ptr, "ns1:ArrayOfDouble");
	case SOAP_TYPE_PointerTons1__ArrayOfLatLong:
		return soap_out_PointerTons1__ArrayOfLatLong(soap, tag, id, (ns1__ArrayOfLatLong *const*)ptr, "ns1:ArrayOfLatLong");
	case SOAP_TYPE_PointerTons1__ArrayOfDataSource:
		return soap_out_PointerTons1__ArrayOfDataSource(soap, tag, id, (ns1__ArrayOfDataSource *const*)ptr, "ns1:ArrayOfDataSource");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_out_PointerTons1__ArrayOfString(soap, tag, id, (ns1__ArrayOfString *const*)ptr, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTons1__ArrayOfEntityType:
		return soap_out_PointerTons1__ArrayOfEntityType(soap, tag, id, (ns1__ArrayOfEntityType *const*)ptr, "ns1:ArrayOfEntityType");
	case SOAP_TYPE_PointerTons1__ArrayOfCountryRegionInfo:
		return soap_out_PointerTons1__ArrayOfCountryRegionInfo(soap, tag, id, (ns1__ArrayOfCountryRegionInfo *const*)ptr, "ns1:ArrayOfCountryRegionInfo");
	case SOAP_TYPE_PointerTons1__ArrayOfVersionInfo:
		return soap_out_PointerTons1__ArrayOfVersionInfo(soap, tag, id, (ns1__ArrayOfVersionInfo *const*)ptr, "ns1:ArrayOfVersionInfo");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerToPointerTons1__LatLong:
		return soap_out_PointerToPointerTons1__LatLong(soap, tag, id, (ns1__LatLong **const*)ptr, "ns1:LatLong");
	case SOAP_TYPE_PointerTons1__ArrayOfInt:
		return soap_out_PointerTons1__ArrayOfInt(soap, tag, id, (ns1__ArrayOfInt *const*)ptr, "ns1:ArrayOfInt");
	case SOAP_TYPE_PointerToPointerTons1__DataSource:
		return soap_out_PointerToPointerTons1__DataSource(soap, tag, id, (ns1__DataSource **const*)ptr, "ns1:DataSource");
	case SOAP_TYPE_PointerTons1__DataSource:
		return soap_out_PointerTons1__DataSource(soap, tag, id, (ns1__DataSource *const*)ptr, "ns1:DataSource");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__EntityProperty:
		return soap_out_PointerToPointerTons1__EntityProperty(soap, tag, id, (ns1__EntityProperty **const*)ptr, "ns1:EntityProperty");
	case SOAP_TYPE_PointerTons1__EntityProperty:
		return soap_out_PointerTons1__EntityProperty(soap, tag, id, (ns1__EntityProperty *const*)ptr, "ns1:EntityProperty");
	case SOAP_TYPE_PointerTons1__ArrayOfEntityProperty:
		return soap_out_PointerTons1__ArrayOfEntityProperty(soap, tag, id, (ns1__ArrayOfEntityProperty *const*)ptr, "ns1:ArrayOfEntityProperty");
	case SOAP_TYPE_PointerToPointerTons1__EntityType:
		return soap_out_PointerToPointerTons1__EntityType(soap, tag, id, (ns1__EntityType **const*)ptr, "ns1:EntityType");
	case SOAP_TYPE_PointerTons1__EntityType:
		return soap_out_PointerTons1__EntityType(soap, tag, id, (ns1__EntityType *const*)ptr, "ns1:EntityType");
	case SOAP_TYPE_PointerTons1__LatLong:
		return soap_out_PointerTons1__LatLong(soap, tag, id, (ns1__LatLong *const*)ptr, "ns1:LatLong");
	case SOAP_TYPE_PointerToPointerTons1__CountryRegionInfo:
		return soap_out_PointerToPointerTons1__CountryRegionInfo(soap, tag, id, (ns1__CountryRegionInfo **const*)ptr, "ns1:CountryRegionInfo");
	case SOAP_TYPE_PointerTons1__CountryRegionInfo:
		return soap_out_PointerTons1__CountryRegionInfo(soap, tag, id, (ns1__CountryRegionInfo *const*)ptr, "ns1:CountryRegionInfo");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons1__CountryRegionContext:
		return soap_out_PointerTons1__CountryRegionContext(soap, tag, id, (ns1__CountryRegionContext *const*)ptr, "ns1:CountryRegionContext");
	case SOAP_TYPE_PointerTons1__CultureInfo:
		return soap_out_PointerTons1__CultureInfo(soap, tag, id, (ns1__CultureInfo *const*)ptr, "ns1:CultureInfo");
	case SOAP_TYPE_PointerToPointerTons1__VersionInfo:
		return soap_out_PointerToPointerTons1__VersionInfo(soap, tag, id, (ns1__VersionInfo **const*)ptr, "ns1:VersionInfo");
	case SOAP_TYPE_PointerTons1__VersionInfo:
		return soap_out_PointerTons1__VersionInfo(soap, tag, id, (ns1__VersionInfo *const*)ptr, "ns1:VersionInfo");
	case SOAP_TYPE_ns5__guid:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns5:guid");
	case SOAP_TYPE_ns5__duration:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns5:duration");
	case SOAP_TYPE_xsd__duration:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:duration");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:decimal");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:anyURI");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		((_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType:
		((_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6:
		((_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__ItineraryWarningType_:
		((ns16__ItineraryWarningType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__ItineraryWarningSeverity_:
		((ns16__ItineraryWarningSeverity_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__ManeuverType_:
		((ns16__ManeuverType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__ItineraryItemHintType_:
		((ns16__ItineraryItemHintType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__TrafficUsage_:
		((ns16__TrafficUsage_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__RoutePathType_:
		((ns16__RoutePathType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__RouteOptimization_:
		((ns16__RouteOptimization_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__TravelMode_:
		((ns16__TravelMode_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__SortOrder_:
		((ns6__SortOrder_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ListingType_:
		((ns6__ListingType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__guid__:
		((ns5__guid__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__duration__:
		((ns5__duration__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__char__:
		((ns5__char__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ImageType_:
		((ns4__ImageType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__MapStyle_:
		((ns4__MapStyle_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__UriScheme_:
		((ns4__UriScheme_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ResponseStatusCode_:
		((ns4__ResponseStatusCode_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__AuthenticationResultCode_:
		((ns4__AuthenticationResultCode_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__LogicalOperator_:
		((ns4__LogicalOperator_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__CompareOperator_:
		((ns4__CompareOperator_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__DistanceUnit_:
		((ns4__DistanceUnit_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__DeviceType_:
		((ns4__DeviceType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Confidence_:
		((ns4__Confidence_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DistanceUnit_:
		((ns1__DistanceUnit_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DataSourceCapability_:
		((ns1__DataSourceCapability_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__ArrayOfRouteResult:
		((ns16__ArrayOfRouteResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__MajorRoutesResponse:
		((ns16__MajorRoutesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__MajorRoutesOptions:
		((ns16__MajorRoutesOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__MajorRoutesRequest:
		((ns16__MajorRoutesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__RoutePath:
		((ns16__RoutePath *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__ItineraryItemWarning:
		((ns16__ItineraryItemWarning *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__ArrayOfItineraryItemWarning:
		((ns16__ArrayOfItineraryItemWarning *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__RouteSummary:
		((ns16__RouteSummary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__ItineraryItemHint:
		((ns16__ItineraryItemHint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__ArrayOfItineraryItemHint:
		((ns16__ArrayOfItineraryItemHint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__ItineraryItem:
		((ns16__ItineraryItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__ArrayOfItineraryItem:
		((ns16__ArrayOfItineraryItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__RouteLeg:
		((ns16__RouteLeg *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__ArrayOfRouteLeg:
		((ns16__ArrayOfRouteLeg *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__RouteResult:
		((ns16__RouteResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__RouteResponse:
		((ns16__RouteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__Waypoint:
		((ns16__Waypoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__ArrayOfWaypoint:
		((ns16__ArrayOfWaypoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__RouteOptions:
		((ns16__RouteOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__RouteRequest:
		((ns16__RouteRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns15__CalculateRoutesFromMajorRoadsResponse:
		((_ns15__CalculateRoutesFromMajorRoadsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns15__CalculateRoutesFromMajorRoads:
		((_ns15__CalculateRoutesFromMajorRoads *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns15__CalculateRouteResponse:
		((_ns15__CalculateRouteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns15__CalculateRoute:
		((_ns15__CalculateRoute *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns13__MapUriResponse:
		((ns13__MapUriResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns13__MapUriOptions:
		((ns13__MapUriOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns13__MapUriRequest:
		((ns13__MapUriRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult:
		((ns13__ImageryMetadataBirdseyeResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns13__CoverageArea:
		((ns13__CoverageArea *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns13__ArrayOfCoverageArea:
		((ns13__ArrayOfCoverageArea *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns13__ImageryProvider:
		((ns13__ImageryProvider *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns13__ArrayOfImageryProvider:
		((ns13__ArrayOfImageryProvider *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns13__ImageryMetadataResult:
		((ns13__ImageryMetadataResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns13__ArrayOfImageryMetadataResult:
		((ns13__ArrayOfImageryMetadataResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns13__ImageryMetadataResponse:
		((ns13__ImageryMetadataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns13__ImageryMetadataOptions:
		((ns13__ImageryMetadataOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns13__ImageryMetadataRequest:
		((ns13__ImageryMetadataRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns12__GetMapUriResponse:
		((_ns12__GetMapUriResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns12__GetMapUri:
		((_ns12__GetMapUri *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns12__GetImageryMetadataResponse:
		((_ns12__GetImageryMetadataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns12__GetImageryMetadata:
		((_ns12__GetImageryMetadata *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns10__ReverseGeocodeRequest:
		((ns10__ReverseGeocodeRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns10__GeocodeResponse:
		((ns10__GeocodeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns10__ConfidenceFilter:
		((ns10__ConfidenceFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns10__FilterBase:
		((ns10__FilterBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns10__ArrayOfFilterBase:
		((ns10__ArrayOfFilterBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns10__GeocodeOptions:
		((ns10__GeocodeOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns10__GeocodeRequest:
		((ns10__GeocodeRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns9__ReverseGeocodeResponse:
		((_ns9__ReverseGeocodeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns9__ReverseGeocode:
		((_ns9__ReverseGeocode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns9__GeocodeResponse:
		((_ns9__GeocodeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns9__Geocode:
		((_ns9__Geocode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		((ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType:
		((ns7__ArrayOfKeyValueOfstringanyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6:
		((ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__ArrayOfanyType:
		((ns7__ArrayOfanyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__ArrayOfstring:
		((ns7__ArrayOfstring *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__SearchPoint:
		((ns6__SearchPoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__PersonSearchResult:
		((ns6__PersonSearchResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ArrayOfNeighborhood:
		((ns6__ArrayOfNeighborhood *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__CategorySpecificPropertySet:
		((ns6__CategorySpecificPropertySet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ArrayOfCategory:
		((ns6__ArrayOfCategory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__BusinessSearchResult:
		((ns6__BusinessSearchResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__CommunityContentSearchResult:
		((ns6__CommunityContentSearchResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__LocationData:
		((ns6__LocationData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__SearchResultBase:
		((ns6__SearchResultBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ArrayOfSearchResultBase:
		((ns6__ArrayOfSearchResultBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__Parse:
		((ns6__Parse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__CategoryCount:
		((ns6__CategoryCount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ArrayOfCategoryCount:
		((ns6__ArrayOfCategoryCount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__FilterValue:
		((ns6__FilterValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__Category:
		((ns6__Category *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__Neighborhood:
		((ns6__Neighborhood *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ValueListFilter:
		((ns6__ValueListFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__RangeFilter:
		((ns6__RangeFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__AvailableFilter:
		((ns6__AvailableFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ArrayOfAvailableFilter:
		((ns6__ArrayOfAvailableFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__SearchRegion:
		((ns6__SearchRegion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ArrayOfSearchRegion:
		((ns6__ArrayOfSearchRegion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__SearchResultSet:
		((ns6__SearchResultSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ArrayOfSearchResultSet:
		((ns6__ArrayOfSearchResultSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__QuerySuggestion:
		((ns6__QuerySuggestion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__SearchResponse:
		((ns6__SearchResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__StructuredSearchQuery:
		((ns6__StructuredSearchQuery *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__SearchOptions:
		((ns6__SearchOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__SearchRequest:
		((ns6__SearchRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Pushpin:
		((ns4__Pushpin *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfPushpin:
		((ns4__ArrayOfPushpin *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__RangeOfdateTime:
		((ns4__RangeOfdateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__RangeOfint:
		((ns4__RangeOfint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfGeocodeResult:
		((ns4__ArrayOfGeocodeResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfGeocodeLocation:
		((ns4__ArrayOfGeocodeLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Address:
		((ns4__Address *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__GeocodeResult:
		((ns4__GeocodeResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ResponseSummary:
		((ns4__ResponseSummary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ResponseBase:
		((ns4__ResponseBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfFilterExpressionBase:
		((ns4__ArrayOfFilterExpressionBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__FilterExpressionClause:
		((ns4__FilterExpressionClause *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__FilterExpression:
		((ns4__FilterExpression *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__FilterExpressionBase:
		((ns4__FilterExpressionBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__SizeOfint:
		((ns4__SizeOfint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfLocation:
		((ns4__ArrayOfLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Polygon:
		((ns4__Polygon *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Circle:
		((ns4__Circle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Rectangle:
		((ns4__Rectangle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ShapeBase:
		((ns4__ShapeBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__GeocodeLocation:
		((ns4__GeocodeLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Location:
		((ns4__Location *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__UserLocation:
		((ns4__UserLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Heading:
		((ns4__Heading *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__UserProfile:
		((ns4__UserProfile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ExecutionOptions:
		((ns4__ExecutionOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__Credentials:
		((ns4__Credentials *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__RequestBase:
		((ns4__RequestBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__SearchResponse:
		((_ns3__SearchResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__Search:
		((_ns3__Search *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetClientTokenResponse:
		((_ns1__GetClientTokenResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetClientToken:
		((_ns1__GetClientToken *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetGreatCircleDistancesResponse:
		((_ns1__GetGreatCircleDistancesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetGreatCircleDistances:
		((_ns1__GetGreatCircleDistances *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDataSourceInfoResponse:
		((_ns1__GetDataSourceInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDataSourceInfo:
		((_ns1__GetDataSourceInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetEntityTypesResponse:
		((_ns1__GetEntityTypesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetEntityTypes:
		((_ns1__GetEntityTypes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetCountryRegionInfoResponse:
		((_ns1__GetCountryRegionInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetCountryRegionInfo:
		((_ns1__GetCountryRegionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetVersionInfoResponse:
		((_ns1__GetVersionInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetVersionInfo:
		((_ns1__GetVersionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TokenSpecification:
		((ns1__TokenSpecification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfDouble:
		((ns1__ArrayOfDouble *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfLatLong:
		((ns1__ArrayOfLatLong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DataSource:
		((ns1__DataSource *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfDataSource:
		((ns1__ArrayOfDataSource *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		((ns1__ArrayOfString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__EntityProperty:
		((ns1__EntityProperty *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfEntityProperty:
		((ns1__ArrayOfEntityProperty *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__EntityType:
		((ns1__EntityType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfEntityType:
		((ns1__ArrayOfEntityType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LatLong:
		((ns1__LatLong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CountryRegionInfo:
		((ns1__CountryRegionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfCountryRegionInfo:
		((ns1__ArrayOfCountryRegionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfInt:
		((ns1__ArrayOfInt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CountryRegionContext:
		((ns1__CountryRegionContext *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CultureInfo:
		((ns1__CultureInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UserInfoHeader:
		((ns1__UserInfoHeader *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CustomerInfoHeader:
		((ns1__CustomerInfoHeader *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__VersionInfo:
		((ns1__VersionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfVersionInfo:
		((ns1__ArrayOfVersionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedShort:
		((xsd__unsignedShort *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedLong:
		((xsd__unsignedLong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedInt:
		((xsd__unsignedInt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedByte_:
		((xsd__unsignedByte_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__string:
		((xsd__string *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__short:
		((xsd__short *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__long:
		((xsd__long *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__int:
		((xsd__int *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__float:
		((xsd__float *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__duration_:
		((xsd__duration_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__double:
		((xsd__double *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal_:
		((xsd__decimal_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__dateTime:
		((xsd__dateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__byte_:
		((xsd__byte_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__boolean:
		((xsd__boolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary_:
		((xsd__base64Binary_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI_:
		((xsd__anyURI_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__QName:
		((xsd__QName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns6__Search:
		soap_serialize___ns6__Search(soap, (const struct __ns6__Search *)ptr);
		break;
	case SOAP_TYPE___ns16__CalculateRoutesFromMajorRoads:
		soap_serialize___ns16__CalculateRoutesFromMajorRoads(soap, (const struct __ns16__CalculateRoutesFromMajorRoads *)ptr);
		break;
	case SOAP_TYPE___ns16__CalculateRoute:
		soap_serialize___ns16__CalculateRoute(soap, (const struct __ns16__CalculateRoute *)ptr);
		break;
	case SOAP_TYPE___ns13__GetMapUri:
		soap_serialize___ns13__GetMapUri(soap, (const struct __ns13__GetMapUri *)ptr);
		break;
	case SOAP_TYPE___ns13__GetImageryMetadata:
		soap_serialize___ns13__GetImageryMetadata(soap, (const struct __ns13__GetImageryMetadata *)ptr);
		break;
	case SOAP_TYPE___ns10__ReverseGeocode:
		soap_serialize___ns10__ReverseGeocode(soap, (const struct __ns10__ReverseGeocode *)ptr);
		break;
	case SOAP_TYPE___ns10__Geocode:
		soap_serialize___ns10__Geocode(soap, (const struct __ns10__Geocode *)ptr);
		break;
	case SOAP_TYPE___ns1__GetClientToken:
		soap_serialize___ns1__GetClientToken(soap, (const struct __ns1__GetClientToken *)ptr);
		break;
	case SOAP_TYPE___ns1__GetGreatCircleDistances:
		soap_serialize___ns1__GetGreatCircleDistances(soap, (const struct __ns1__GetGreatCircleDistances *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDataSourceInfo:
		soap_serialize___ns1__GetDataSourceInfo(soap, (const struct __ns1__GetDataSourceInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetEntityTypes:
		soap_serialize___ns1__GetEntityTypes(soap, (const struct __ns1__GetEntityTypes *)ptr);
		break;
	case SOAP_TYPE___ns1__GetCountryRegionInfo:
		soap_serialize___ns1__GetCountryRegionInfo(soap, (const struct __ns1__GetCountryRegionInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetVersionInfo:
		soap_serialize___ns1__GetVersionInfo(soap, (const struct __ns1__GetVersionInfo *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__SearchResponse:
		soap_serialize_PointerTo_ns3__SearchResponse(soap, (_ns3__SearchResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__Search:
		soap_serialize_PointerTo_ns3__Search(soap, (_ns3__Search *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns15__CalculateRoutesFromMajorRoadsResponse:
		soap_serialize_PointerTo_ns15__CalculateRoutesFromMajorRoadsResponse(soap, (_ns15__CalculateRoutesFromMajorRoadsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns15__CalculateRoutesFromMajorRoads:
		soap_serialize_PointerTo_ns15__CalculateRoutesFromMajorRoads(soap, (_ns15__CalculateRoutesFromMajorRoads *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns15__CalculateRouteResponse:
		soap_serialize_PointerTo_ns15__CalculateRouteResponse(soap, (_ns15__CalculateRouteResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns15__CalculateRoute:
		soap_serialize_PointerTo_ns15__CalculateRoute(soap, (_ns15__CalculateRoute *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns12__GetMapUriResponse:
		soap_serialize_PointerTo_ns12__GetMapUriResponse(soap, (_ns12__GetMapUriResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns12__GetMapUri:
		soap_serialize_PointerTo_ns12__GetMapUri(soap, (_ns12__GetMapUri *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns12__GetImageryMetadataResponse:
		soap_serialize_PointerTo_ns12__GetImageryMetadataResponse(soap, (_ns12__GetImageryMetadataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns12__GetImageryMetadata:
		soap_serialize_PointerTo_ns12__GetImageryMetadata(soap, (_ns12__GetImageryMetadata *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns9__ReverseGeocodeResponse:
		soap_serialize_PointerTo_ns9__ReverseGeocodeResponse(soap, (_ns9__ReverseGeocodeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns9__ReverseGeocode:
		soap_serialize_PointerTo_ns9__ReverseGeocode(soap, (_ns9__ReverseGeocode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns9__GeocodeResponse:
		soap_serialize_PointerTo_ns9__GeocodeResponse(soap, (_ns9__GeocodeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns9__Geocode:
		soap_serialize_PointerTo_ns9__Geocode(soap, (_ns9__Geocode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetClientTokenResponse:
		soap_serialize_PointerTo_ns1__GetClientTokenResponse(soap, (_ns1__GetClientTokenResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetClientToken:
		soap_serialize_PointerTo_ns1__GetClientToken(soap, (_ns1__GetClientToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetGreatCircleDistancesResponse:
		soap_serialize_PointerTo_ns1__GetGreatCircleDistancesResponse(soap, (_ns1__GetGreatCircleDistancesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetGreatCircleDistances:
		soap_serialize_PointerTo_ns1__GetGreatCircleDistances(soap, (_ns1__GetGreatCircleDistances *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDataSourceInfoResponse:
		soap_serialize_PointerTo_ns1__GetDataSourceInfoResponse(soap, (_ns1__GetDataSourceInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDataSourceInfo:
		soap_serialize_PointerTo_ns1__GetDataSourceInfo(soap, (_ns1__GetDataSourceInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetEntityTypesResponse:
		soap_serialize_PointerTo_ns1__GetEntityTypesResponse(soap, (_ns1__GetEntityTypesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetEntityTypes:
		soap_serialize_PointerTo_ns1__GetEntityTypes(soap, (_ns1__GetEntityTypes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetCountryRegionInfoResponse:
		soap_serialize_PointerTo_ns1__GetCountryRegionInfoResponse(soap, (_ns1__GetCountryRegionInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetCountryRegionInfo:
		soap_serialize_PointerTo_ns1__GetCountryRegionInfo(soap, (_ns1__GetCountryRegionInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetVersionInfoResponse:
		soap_serialize_PointerTo_ns1__GetVersionInfoResponse(soap, (_ns1__GetVersionInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetVersionInfo:
		soap_serialize_PointerTo_ns1__GetVersionInfo(soap, (_ns1__GetVersionInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UserInfoHeader:
		soap_serialize_PointerTons1__UserInfoHeader(soap, (ns1__UserInfoHeader *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CustomerInfoHeader:
		soap_serialize_PointerTons1__CustomerInfoHeader(soap, (ns1__CustomerInfoHeader *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__ArrayOfRouteResult:
		soap_serialize_PointerTons16__ArrayOfRouteResult(soap, (ns16__ArrayOfRouteResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__MajorRoutesOptions:
		soap_serialize_PointerTons16__MajorRoutesOptions(soap, (ns16__MajorRoutesOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__ArrayOfWaypoint:
		soap_serialize_PointerTons16__ArrayOfWaypoint(soap, (ns16__ArrayOfWaypoint *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__RouteOptions:
		soap_serialize_PointerTons16__RouteOptions(soap, (ns16__RouteOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfPushpin:
		soap_serialize_PointerTons4__ArrayOfPushpin(soap, (ns4__ArrayOfPushpin *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons13__MapUriOptions:
		soap_serialize_PointerTons13__MapUriOptions(soap, (ns13__MapUriOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons13__ArrayOfImageryMetadataResult:
		soap_serialize_PointerTons13__ArrayOfImageryMetadataResult(soap, (ns13__ArrayOfImageryMetadataResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons13__ImageryMetadataOptions:
		soap_serialize_PointerTons13__ImageryMetadataOptions(soap, (ns13__ImageryMetadataOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfGeocodeResult:
		soap_serialize_PointerTons4__ArrayOfGeocodeResult(soap, (ns4__ArrayOfGeocodeResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__GeocodeOptions:
		soap_serialize_PointerTons10__GeocodeOptions(soap, (ns10__GeocodeOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ArrayOfNeighborhood:
		soap_serialize_PointerTons6__ArrayOfNeighborhood(soap, (ns6__ArrayOfNeighborhood *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		soap_serialize_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, (ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ArrayOfCategory:
		soap_serialize_PointerTons6__ArrayOfCategory(soap, (ns6__ArrayOfCategory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__ArrayOfanyType:
		soap_serialize_PointerTons7__ArrayOfanyType(soap, (ns7__ArrayOfanyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ArrayOfSearchResultSet:
		soap_serialize_PointerTons6__ArrayOfSearchResultSet(soap, (ns6__ArrayOfSearchResultSet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__QuerySuggestion:
		soap_serialize_PointerTons6__QuerySuggestion(soap, (ns6__QuerySuggestion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__SearchOptions:
		soap_serialize_PointerTons6__SearchOptions(soap, (ns6__SearchOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__LogicalOperator:
		soap_serialize_PointerTons4__LogicalOperator(soap, (enum ns4__LogicalOperator *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfFilterExpressionBase:
		soap_serialize_PointerTons4__ArrayOfFilterExpressionBase(soap, (ns4__ArrayOfFilterExpressionBase *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__CompareOperator:
		soap_serialize_PointerTons4__CompareOperator(soap, (enum ns4__CompareOperator *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons16__RouteResult:
		soap_serialize_PointerToPointerTons16__RouteResult(soap, (ns16__RouteResult **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__RouteResult:
		soap_serialize_PointerTons16__RouteResult(soap, (ns16__RouteResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfLocation:
		soap_serialize_PointerTons4__ArrayOfLocation(soap, (ns4__ArrayOfLocation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__ItineraryWarningType:
		soap_serialize_PointerTons16__ItineraryWarningType(soap, (enum ns16__ItineraryWarningType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__ItineraryWarningSeverity:
		soap_serialize_PointerTons16__ItineraryWarningSeverity(soap, (enum ns16__ItineraryWarningSeverity *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons16__ItineraryItemWarning:
		soap_serialize_PointerToPointerTons16__ItineraryItemWarning(soap, (ns16__ItineraryItemWarning **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__ItineraryItemWarning:
		soap_serialize_PointerTons16__ItineraryItemWarning(soap, (ns16__ItineraryItemWarning *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__ItineraryItemHintType:
		soap_serialize_PointerTons16__ItineraryItemHintType(soap, (enum ns16__ItineraryItemHintType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons16__ItineraryItemHint:
		soap_serialize_PointerToPointerTons16__ItineraryItemHint(soap, (ns16__ItineraryItemHint **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__ItineraryItemHint:
		soap_serialize_PointerTons16__ItineraryItemHint(soap, (ns16__ItineraryItemHint *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__ArrayOfItineraryItemWarning:
		soap_serialize_PointerTons16__ArrayOfItineraryItemWarning(soap, (ns16__ArrayOfItineraryItemWarning *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__ManeuverType:
		soap_serialize_PointerTons16__ManeuverType(soap, (enum ns16__ManeuverType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__ArrayOfItineraryItemHint:
		soap_serialize_PointerTons16__ArrayOfItineraryItemHint(soap, (ns16__ArrayOfItineraryItemHint *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons16__ItineraryItem:
		soap_serialize_PointerToPointerTons16__ItineraryItem(soap, (ns16__ItineraryItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__ItineraryItem:
		soap_serialize_PointerTons16__ItineraryItem(soap, (ns16__ItineraryItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__ArrayOfItineraryItem:
		soap_serialize_PointerTons16__ArrayOfItineraryItem(soap, (ns16__ArrayOfItineraryItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons16__RouteLeg:
		soap_serialize_PointerToPointerTons16__RouteLeg(soap, (ns16__RouteLeg **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__RouteLeg:
		soap_serialize_PointerTons16__RouteLeg(soap, (ns16__RouteLeg *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__RouteSummary:
		soap_serialize_PointerTons16__RouteSummary(soap, (ns16__RouteSummary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__RoutePath:
		soap_serialize_PointerTons16__RoutePath(soap, (ns16__RoutePath *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__ArrayOfRouteLeg:
		soap_serialize_PointerTons16__ArrayOfRouteLeg(soap, (ns16__ArrayOfRouteLeg *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons16__Waypoint:
		soap_serialize_PointerToPointerTons16__Waypoint(soap, (ns16__Waypoint **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__Waypoint:
		soap_serialize_PointerTons16__Waypoint(soap, (ns16__Waypoint *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__TrafficUsage:
		soap_serialize_PointerTons16__TrafficUsage(soap, (enum ns16__TrafficUsage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__RoutePathType:
		soap_serialize_PointerTons16__RoutePathType(soap, (enum ns16__RoutePathType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__RouteOptimization:
		soap_serialize_PointerTons16__RouteOptimization(soap, (enum ns16__RouteOptimization *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__TravelMode:
		soap_serialize_PointerTons16__TravelMode(soap, (enum ns16__TravelMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__MajorRoutesResponse:
		soap_serialize_PointerTons16__MajorRoutesResponse(soap, (ns16__MajorRoutesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__MajorRoutesRequest:
		soap_serialize_PointerTons16__MajorRoutesRequest(soap, (ns16__MajorRoutesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__RouteResponse:
		soap_serialize_PointerTons16__RouteResponse(soap, (ns16__RouteResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__RouteRequest:
		soap_serialize_PointerTons16__RouteRequest(soap, (ns16__RouteRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__MapStyle:
		soap_serialize_PointerTons4__MapStyle(soap, (enum ns4__MapStyle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ImageType:
		soap_serialize_PointerTons4__ImageType(soap, (enum ns4__ImageType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons13__CoverageArea:
		soap_serialize_PointerToPointerTons13__CoverageArea(soap, (ns13__CoverageArea **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons13__CoverageArea:
		soap_serialize_PointerTons13__CoverageArea(soap, (ns13__CoverageArea *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons13__ArrayOfCoverageArea:
		soap_serialize_PointerTons13__ArrayOfCoverageArea(soap, (ns13__ArrayOfCoverageArea *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons13__ImageryProvider:
		soap_serialize_PointerToPointerTons13__ImageryProvider(soap, (ns13__ImageryProvider **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons13__ImageryProvider:
		soap_serialize_PointerTons13__ImageryProvider(soap, (ns13__ImageryProvider *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__RangeOfint:
		soap_serialize_PointerTons4__RangeOfint(soap, (ns4__RangeOfint *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__RangeOfdateTime:
		soap_serialize_PointerTons4__RangeOfdateTime(soap, (ns4__RangeOfdateTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons13__ArrayOfImageryProvider:
		soap_serialize_PointerTons13__ArrayOfImageryProvider(soap, (ns13__ArrayOfImageryProvider *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons13__ImageryMetadataResult:
		soap_serialize_PointerToPointerTons13__ImageryMetadataResult(soap, (ns13__ImageryMetadataResult **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons13__ImageryMetadataResult:
		soap_serialize_PointerTons13__ImageryMetadataResult(soap, (ns13__ImageryMetadataResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__UriScheme:
		soap_serialize_PointerTons4__UriScheme(soap, (enum ns4__UriScheme *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons13__MapUriResponse:
		soap_serialize_PointerTons13__MapUriResponse(soap, (ns13__MapUriResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons13__MapUriRequest:
		soap_serialize_PointerTons13__MapUriRequest(soap, (ns13__MapUriRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons13__ImageryMetadataResponse:
		soap_serialize_PointerTons13__ImageryMetadataResponse(soap, (ns13__ImageryMetadataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons13__ImageryMetadataRequest:
		soap_serialize_PointerTons13__ImageryMetadataRequest(soap, (ns13__ImageryMetadataRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons10__FilterBase:
		soap_serialize_PointerToPointerTons10__FilterBase(soap, (ns10__FilterBase **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__FilterBase:
		soap_serialize_PointerTons10__FilterBase(soap, (ns10__FilterBase *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__ArrayOfFilterBase:
		soap_serialize_PointerTons10__ArrayOfFilterBase(soap, (ns10__ArrayOfFilterBase *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__ReverseGeocodeRequest:
		soap_serialize_PointerTons10__ReverseGeocodeRequest(soap, (ns10__ReverseGeocodeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__GeocodeResponse:
		soap_serialize_PointerTons10__GeocodeResponse(soap, (ns10__GeocodeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__GeocodeRequest:
		soap_serialize_PointerTons10__GeocodeRequest(soap, (ns10__GeocodeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		soap_serialize_PointerTo_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, (_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__CategorySpecificPropertySet:
		soap_serialize_PointerTons6__CategorySpecificPropertySet(soap, (ns6__CategorySpecificPropertySet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType:
		soap_serialize_PointerTo_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(soap, (_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6:
		soap_serialize_PointerTo_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(soap, (_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToxsd__anyType:
		soap_serialize_PointerToPointerToxsd__anyType(soap, (xsd__anyType **const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyType:
		soap_serialize_PointerToxsd__anyType(soap, (xsd__anyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons6__Neighborhood:
		soap_serialize_PointerToPointerTons6__Neighborhood(soap, (ns6__Neighborhood **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__Neighborhood:
		soap_serialize_PointerTons6__Neighborhood(soap, (ns6__Neighborhood *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__ArrayOfKeyValueOfstringanyType:
		soap_serialize_PointerTons7__ArrayOfKeyValueOfstringanyType(soap, (ns7__ArrayOfKeyValueOfstringanyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons6__Category:
		soap_serialize_PointerToPointerTons6__Category(soap, (ns6__Category **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__LocationData:
		soap_serialize_PointerTons6__LocationData(soap, (ns6__LocationData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons6__SearchResultBase:
		soap_serialize_PointerToPointerTons6__SearchResultBase(soap, (ns6__SearchResultBase **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__SearchResultBase:
		soap_serialize_PointerTons6__SearchResultBase(soap, (ns6__SearchResultBase *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6:
		soap_serialize_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, (ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__Category:
		soap_serialize_PointerTons6__Category(soap, (ns6__Category *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons6__CategoryCount:
		soap_serialize_PointerToPointerTons6__CategoryCount(soap, (ns6__CategoryCount **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__CategoryCount:
		soap_serialize_PointerTons6__CategoryCount(soap, (ns6__CategoryCount *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons6__AvailableFilter:
		soap_serialize_PointerToPointerTons6__AvailableFilter(soap, (ns6__AvailableFilter **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__AvailableFilter:
		soap_serialize_PointerTons6__AvailableFilter(soap, (ns6__AvailableFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons6__SearchRegion:
		soap_serialize_PointerToPointerTons6__SearchRegion(soap, (ns6__SearchRegion **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__SearchRegion:
		soap_serialize_PointerTons6__SearchRegion(soap, (ns6__SearchRegion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ArrayOfSearchResultBase:
		soap_serialize_PointerTons6__ArrayOfSearchResultBase(soap, (ns6__ArrayOfSearchResultBase *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__Parse:
		soap_serialize_PointerTons6__Parse(soap, (ns6__Parse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ArrayOfCategoryCount:
		soap_serialize_PointerTons6__ArrayOfCategoryCount(soap, (ns6__ArrayOfCategoryCount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ArrayOfAvailableFilter:
		soap_serialize_PointerTons6__ArrayOfAvailableFilter(soap, (ns6__ArrayOfAvailableFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ArrayOfSearchRegion:
		soap_serialize_PointerTons6__ArrayOfSearchRegion(soap, (ns6__ArrayOfSearchRegion *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons6__SearchResultSet:
		soap_serialize_PointerToPointerTons6__SearchResultSet(soap, (ns6__SearchResultSet **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__SearchResultSet:
		soap_serialize_PointerTons6__SearchResultSet(soap, (ns6__SearchResultSet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__StructuredSearchQuery:
		soap_serialize_PointerTons6__StructuredSearchQuery(soap, (ns6__StructuredSearchQuery *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__SortOrder:
		soap_serialize_PointerTons6__SortOrder(soap, (enum ns6__SortOrder *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ListingType:
		soap_serialize_PointerTons6__ListingType(soap, (enum ns6__ListingType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__Pushpin:
		soap_serialize_PointerToPointerTons4__Pushpin(soap, (ns4__Pushpin **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Pushpin:
		soap_serialize_PointerTons4__Pushpin(soap, (ns4__Pushpin *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__GeocodeResult:
		soap_serialize_PointerToPointerTons4__GeocodeResult(soap, (ns4__GeocodeResult **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GeocodeResult:
		soap_serialize_PointerTons4__GeocodeResult(soap, (ns4__GeocodeResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__GeocodeLocation:
		soap_serialize_PointerToPointerTons4__GeocodeLocation(soap, (ns4__GeocodeLocation **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GeocodeLocation:
		soap_serialize_PointerTons4__GeocodeLocation(soap, (ns4__GeocodeLocation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__ArrayOfstring:
		soap_serialize_PointerTons7__ArrayOfstring(soap, (ns7__ArrayOfstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfGeocodeLocation:
		soap_serialize_PointerTons4__ArrayOfGeocodeLocation(soap, (ns4__ArrayOfGeocodeLocation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Confidence:
		soap_serialize_PointerTons4__Confidence(soap, (enum ns4__Confidence *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Rectangle:
		soap_serialize_PointerTons4__Rectangle(soap, (ns4__Rectangle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Address:
		soap_serialize_PointerTons4__Address(soap, (ns4__Address *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ResponseStatusCode:
		soap_serialize_PointerTons4__ResponseStatusCode(soap, (enum ns4__ResponseStatusCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__AuthenticationResultCode:
		soap_serialize_PointerTons4__AuthenticationResultCode(soap, (enum ns4__AuthenticationResultCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ResponseSummary:
		soap_serialize_PointerTons4__ResponseSummary(soap, (ns4__ResponseSummary *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__FilterExpressionBase:
		soap_serialize_PointerToPointerTons4__FilterExpressionBase(soap, (ns4__FilterExpressionBase **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__FilterExpressionBase:
		soap_serialize_PointerTons4__FilterExpressionBase(soap, (ns4__FilterExpressionBase *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__Location:
		soap_serialize_PointerToPointerTons4__Location(soap, (ns4__Location **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Location:
		soap_serialize_PointerTons4__Location(soap, (ns4__Location *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__SizeOfint:
		soap_serialize_PointerTons4__SizeOfint(soap, (ns4__SizeOfint *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ShapeBase:
		soap_serialize_PointerTons4__ShapeBase(soap, (ns4__ShapeBase *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__DistanceUnit:
		soap_serialize_PointerTons4__DistanceUnit(soap, (enum ns4__DistanceUnit *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__DeviceType:
		soap_serialize_PointerTons4__DeviceType(soap, (enum ns4__DeviceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__UserLocation:
		soap_serialize_PointerTons4__UserLocation(soap, (ns4__UserLocation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Heading:
		soap_serialize_PointerTons4__Heading(soap, (ns4__Heading *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__UserProfile:
		soap_serialize_PointerTons4__UserProfile(soap, (ns4__UserProfile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ExecutionOptions:
		soap_serialize_PointerTons4__ExecutionOptions(soap, (ns4__ExecutionOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__Credentials:
		soap_serialize_PointerTons4__Credentials(soap, (ns4__Credentials *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__SearchResponse:
		soap_serialize_PointerTons6__SearchResponse(soap, (ns6__SearchResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__SearchRequest:
		soap_serialize_PointerTons6__SearchRequest(soap, (ns6__SearchRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TokenSpecification:
		soap_serialize_PointerTons1__TokenSpecification(soap, (ns1__TokenSpecification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfDouble:
		soap_serialize_PointerTons1__ArrayOfDouble(soap, (ns1__ArrayOfDouble *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfLatLong:
		soap_serialize_PointerTons1__ArrayOfLatLong(soap, (ns1__ArrayOfLatLong *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfDataSource:
		soap_serialize_PointerTons1__ArrayOfDataSource(soap, (ns1__ArrayOfDataSource *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		soap_serialize_PointerTons1__ArrayOfString(soap, (ns1__ArrayOfString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfEntityType:
		soap_serialize_PointerTons1__ArrayOfEntityType(soap, (ns1__ArrayOfEntityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfCountryRegionInfo:
		soap_serialize_PointerTons1__ArrayOfCountryRegionInfo(soap, (ns1__ArrayOfCountryRegionInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfVersionInfo:
		soap_serialize_PointerTons1__ArrayOfVersionInfo(soap, (ns1__ArrayOfVersionInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__LatLong:
		soap_serialize_PointerToPointerTons1__LatLong(soap, (ns1__LatLong **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfInt:
		soap_serialize_PointerTons1__ArrayOfInt(soap, (ns1__ArrayOfInt *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__DataSource:
		soap_serialize_PointerToPointerTons1__DataSource(soap, (ns1__DataSource **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DataSource:
		soap_serialize_PointerTons1__DataSource(soap, (ns1__DataSource *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__EntityProperty:
		soap_serialize_PointerToPointerTons1__EntityProperty(soap, (ns1__EntityProperty **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EntityProperty:
		soap_serialize_PointerTons1__EntityProperty(soap, (ns1__EntityProperty *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfEntityProperty:
		soap_serialize_PointerTons1__ArrayOfEntityProperty(soap, (ns1__ArrayOfEntityProperty *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__EntityType:
		soap_serialize_PointerToPointerTons1__EntityType(soap, (ns1__EntityType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EntityType:
		soap_serialize_PointerTons1__EntityType(soap, (ns1__EntityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LatLong:
		soap_serialize_PointerTons1__LatLong(soap, (ns1__LatLong *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CountryRegionInfo:
		soap_serialize_PointerToPointerTons1__CountryRegionInfo(soap, (ns1__CountryRegionInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CountryRegionInfo:
		soap_serialize_PointerTons1__CountryRegionInfo(soap, (ns1__CountryRegionInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CountryRegionContext:
		soap_serialize_PointerTons1__CountryRegionContext(soap, (ns1__CountryRegionContext *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CultureInfo:
		soap_serialize_PointerTons1__CultureInfo(soap, (ns1__CultureInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__VersionInfo:
		soap_serialize_PointerToPointerTons1__VersionInfo(soap, (ns1__VersionInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__VersionInfo:
		soap_serialize_PointerTons1__VersionInfo(soap, (ns1__VersionInfo *const*)ptr);
		break;
	case SOAP_TYPE_ns5__guid:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_ns5__duration:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__duration:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI_:
		return (void*)soap_instantiate_xsd__anyURI_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary_:
		return (void*)soap_instantiate_xsd__base64Binary_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean:
		return (void*)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__byte_:
		return (void*)soap_instantiate_xsd__byte_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime:
		return (void*)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal_:
		return (void*)soap_instantiate_xsd__decimal_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__double:
		return (void*)soap_instantiate_xsd__double(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__duration_:
		return (void*)soap_instantiate_xsd__duration_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__float:
		return (void*)soap_instantiate_xsd__float(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int:
		return (void*)soap_instantiate_xsd__int(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__long:
		return (void*)soap_instantiate_xsd__long(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__short:
		return (void*)soap_instantiate_xsd__short(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string:
		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedByte_:
		return (void*)soap_instantiate_xsd__unsignedByte_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedInt:
		return (void*)soap_instantiate_xsd__unsignedInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedLong:
		return (void*)soap_instantiate_xsd__unsignedLong(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedShort:
		return (void*)soap_instantiate_xsd__unsignedShort(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DataSourceCapability_:
		return (void*)soap_instantiate_ns1__DataSourceCapability_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DistanceUnit_:
		return (void*)soap_instantiate_ns1__DistanceUnit_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Confidence_:
		return (void*)soap_instantiate_ns4__Confidence_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__DeviceType_:
		return (void*)soap_instantiate_ns4__DeviceType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__DistanceUnit_:
		return (void*)soap_instantiate_ns4__DistanceUnit_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__CompareOperator_:
		return (void*)soap_instantiate_ns4__CompareOperator_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__LogicalOperator_:
		return (void*)soap_instantiate_ns4__LogicalOperator_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__AuthenticationResultCode_:
		return (void*)soap_instantiate_ns4__AuthenticationResultCode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ResponseStatusCode_:
		return (void*)soap_instantiate_ns4__ResponseStatusCode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__UriScheme_:
		return (void*)soap_instantiate_ns4__UriScheme_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__MapStyle_:
		return (void*)soap_instantiate_ns4__MapStyle_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ImageType_:
		return (void*)soap_instantiate_ns4__ImageType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__char__:
		return (void*)soap_instantiate_ns5__char__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__duration__:
		return (void*)soap_instantiate_ns5__duration__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__guid__:
		return (void*)soap_instantiate_ns5__guid__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ListingType_:
		return (void*)soap_instantiate_ns6__ListingType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SortOrder_:
		return (void*)soap_instantiate_ns6__SortOrder_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__TravelMode_:
		return (void*)soap_instantiate_ns16__TravelMode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__RouteOptimization_:
		return (void*)soap_instantiate_ns16__RouteOptimization_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__RoutePathType_:
		return (void*)soap_instantiate_ns16__RoutePathType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__TrafficUsage_:
		return (void*)soap_instantiate_ns16__TrafficUsage_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__ItineraryItemHintType_:
		return (void*)soap_instantiate_ns16__ItineraryItemHintType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__ManeuverType_:
		return (void*)soap_instantiate_ns16__ManeuverType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__ItineraryWarningSeverity_:
		return (void*)soap_instantiate_ns16__ItineraryWarningSeverity_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__ItineraryWarningType_:
		return (void*)soap_instantiate_ns16__ItineraryWarningType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfVersionInfo:
		return (void*)soap_instantiate_ns1__ArrayOfVersionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__VersionInfo:
		return (void*)soap_instantiate_ns1__VersionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CustomerInfoHeader:
		return (void*)soap_instantiate_ns1__CustomerInfoHeader(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UserInfoHeader:
		return (void*)soap_instantiate_ns1__UserInfoHeader(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CultureInfo:
		return (void*)soap_instantiate_ns1__CultureInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CountryRegionContext:
		return (void*)soap_instantiate_ns1__CountryRegionContext(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfInt:
		return (void*)soap_instantiate_ns1__ArrayOfInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfCountryRegionInfo:
		return (void*)soap_instantiate_ns1__ArrayOfCountryRegionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CountryRegionInfo:
		return (void*)soap_instantiate_ns1__CountryRegionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LatLong:
		return (void*)soap_instantiate_ns1__LatLong(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfEntityType:
		return (void*)soap_instantiate_ns1__ArrayOfEntityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EntityType:
		return (void*)soap_instantiate_ns1__EntityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfEntityProperty:
		return (void*)soap_instantiate_ns1__ArrayOfEntityProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EntityProperty:
		return (void*)soap_instantiate_ns1__EntityProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfString:
		return (void*)soap_instantiate_ns1__ArrayOfString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfDataSource:
		return (void*)soap_instantiate_ns1__ArrayOfDataSource(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DataSource:
		return (void*)soap_instantiate_ns1__DataSource(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfLatLong:
		return (void*)soap_instantiate_ns1__ArrayOfLatLong(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfDouble:
		return (void*)soap_instantiate_ns1__ArrayOfDouble(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TokenSpecification:
		return (void*)soap_instantiate_ns1__TokenSpecification(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetVersionInfo:
		return (void*)soap_instantiate__ns1__GetVersionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetVersionInfoResponse:
		return (void*)soap_instantiate__ns1__GetVersionInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetCountryRegionInfo:
		return (void*)soap_instantiate__ns1__GetCountryRegionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetCountryRegionInfoResponse:
		return (void*)soap_instantiate__ns1__GetCountryRegionInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetEntityTypes:
		return (void*)soap_instantiate__ns1__GetEntityTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetEntityTypesResponse:
		return (void*)soap_instantiate__ns1__GetEntityTypesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDataSourceInfo:
		return (void*)soap_instantiate__ns1__GetDataSourceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDataSourceInfoResponse:
		return (void*)soap_instantiate__ns1__GetDataSourceInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetGreatCircleDistances:
		return (void*)soap_instantiate__ns1__GetGreatCircleDistances(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetGreatCircleDistancesResponse:
		return (void*)soap_instantiate__ns1__GetGreatCircleDistancesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetClientToken:
		return (void*)soap_instantiate__ns1__GetClientToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetClientTokenResponse:
		return (void*)soap_instantiate__ns1__GetClientTokenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__Search:
		return (void*)soap_instantiate__ns3__Search(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__SearchResponse:
		return (void*)soap_instantiate__ns3__SearchResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__RequestBase:
		return (void*)soap_instantiate_ns4__RequestBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Credentials:
		return (void*)soap_instantiate_ns4__Credentials(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ExecutionOptions:
		return (void*)soap_instantiate_ns4__ExecutionOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__UserProfile:
		return (void*)soap_instantiate_ns4__UserProfile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Heading:
		return (void*)soap_instantiate_ns4__Heading(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Location:
		return (void*)soap_instantiate_ns4__Location(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ShapeBase:
		return (void*)soap_instantiate_ns4__ShapeBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfLocation:
		return (void*)soap_instantiate_ns4__ArrayOfLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__SizeOfint:
		return (void*)soap_instantiate_ns4__SizeOfint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__FilterExpressionBase:
		return (void*)soap_instantiate_ns4__FilterExpressionBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfFilterExpressionBase:
		return (void*)soap_instantiate_ns4__ArrayOfFilterExpressionBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ResponseBase:
		return (void*)soap_instantiate_ns4__ResponseBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ResponseSummary:
		return (void*)soap_instantiate_ns4__ResponseSummary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GeocodeResult:
		return (void*)soap_instantiate_ns4__GeocodeResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Address:
		return (void*)soap_instantiate_ns4__Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfGeocodeLocation:
		return (void*)soap_instantiate_ns4__ArrayOfGeocodeLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfGeocodeResult:
		return (void*)soap_instantiate_ns4__ArrayOfGeocodeResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__RangeOfint:
		return (void*)soap_instantiate_ns4__RangeOfint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__RangeOfdateTime:
		return (void*)soap_instantiate_ns4__RangeOfdateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfPushpin:
		return (void*)soap_instantiate_ns4__ArrayOfPushpin(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Pushpin:
		return (void*)soap_instantiate_ns4__Pushpin(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SearchOptions:
		return (void*)soap_instantiate_ns6__SearchOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__StructuredSearchQuery:
		return (void*)soap_instantiate_ns6__StructuredSearchQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__QuerySuggestion:
		return (void*)soap_instantiate_ns6__QuerySuggestion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ArrayOfSearchResultSet:
		return (void*)soap_instantiate_ns6__ArrayOfSearchResultSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SearchResultSet:
		return (void*)soap_instantiate_ns6__SearchResultSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ArrayOfSearchRegion:
		return (void*)soap_instantiate_ns6__ArrayOfSearchRegion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SearchRegion:
		return (void*)soap_instantiate_ns6__SearchRegion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ArrayOfAvailableFilter:
		return (void*)soap_instantiate_ns6__ArrayOfAvailableFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__AvailableFilter:
		return (void*)soap_instantiate_ns6__AvailableFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Neighborhood:
		return (void*)soap_instantiate_ns6__Neighborhood(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Category:
		return (void*)soap_instantiate_ns6__Category(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__FilterValue:
		return (void*)soap_instantiate_ns6__FilterValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ArrayOfCategoryCount:
		return (void*)soap_instantiate_ns6__ArrayOfCategoryCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CategoryCount:
		return (void*)soap_instantiate_ns6__CategoryCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Parse:
		return (void*)soap_instantiate_ns6__Parse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ArrayOfSearchResultBase:
		return (void*)soap_instantiate_ns6__ArrayOfSearchResultBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SearchResultBase:
		return (void*)soap_instantiate_ns6__SearchResultBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__LocationData:
		return (void*)soap_instantiate_ns6__LocationData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ArrayOfCategory:
		return (void*)soap_instantiate_ns6__ArrayOfCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CategorySpecificPropertySet:
		return (void*)soap_instantiate_ns6__CategorySpecificPropertySet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ArrayOfNeighborhood:
		return (void*)soap_instantiate_ns6__ArrayOfNeighborhood(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ArrayOfstring:
		return (void*)soap_instantiate_ns7__ArrayOfstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ArrayOfanyType:
		return (void*)soap_instantiate_ns7__ArrayOfanyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6:
		return (void*)soap_instantiate__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6:
		return (void*)soap_instantiate_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType:
		return (void*)soap_instantiate__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType:
		return (void*)soap_instantiate_ns7__ArrayOfKeyValueOfstringanyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		return (void*)soap_instantiate__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		return (void*)soap_instantiate_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns9__Geocode:
		return (void*)soap_instantiate__ns9__Geocode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns9__GeocodeResponse:
		return (void*)soap_instantiate__ns9__GeocodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns9__ReverseGeocode:
		return (void*)soap_instantiate__ns9__ReverseGeocode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns9__ReverseGeocodeResponse:
		return (void*)soap_instantiate__ns9__ReverseGeocodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns10__GeocodeOptions:
		return (void*)soap_instantiate_ns10__GeocodeOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns10__ArrayOfFilterBase:
		return (void*)soap_instantiate_ns10__ArrayOfFilterBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns10__FilterBase:
		return (void*)soap_instantiate_ns10__FilterBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns12__GetImageryMetadata:
		return (void*)soap_instantiate__ns12__GetImageryMetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns12__GetImageryMetadataResponse:
		return (void*)soap_instantiate__ns12__GetImageryMetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns12__GetMapUri:
		return (void*)soap_instantiate__ns12__GetMapUri(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns12__GetMapUriResponse:
		return (void*)soap_instantiate__ns12__GetMapUriResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns13__ImageryMetadataOptions:
		return (void*)soap_instantiate_ns13__ImageryMetadataOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns13__ArrayOfImageryMetadataResult:
		return (void*)soap_instantiate_ns13__ArrayOfImageryMetadataResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns13__ImageryMetadataResult:
		return (void*)soap_instantiate_ns13__ImageryMetadataResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns13__ArrayOfImageryProvider:
		return (void*)soap_instantiate_ns13__ArrayOfImageryProvider(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns13__ImageryProvider:
		return (void*)soap_instantiate_ns13__ImageryProvider(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns13__ArrayOfCoverageArea:
		return (void*)soap_instantiate_ns13__ArrayOfCoverageArea(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns13__CoverageArea:
		return (void*)soap_instantiate_ns13__CoverageArea(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns13__MapUriOptions:
		return (void*)soap_instantiate_ns13__MapUriOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns15__CalculateRoute:
		return (void*)soap_instantiate__ns15__CalculateRoute(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns15__CalculateRouteResponse:
		return (void*)soap_instantiate__ns15__CalculateRouteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns15__CalculateRoutesFromMajorRoads:
		return (void*)soap_instantiate__ns15__CalculateRoutesFromMajorRoads(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns15__CalculateRoutesFromMajorRoadsResponse:
		return (void*)soap_instantiate__ns15__CalculateRoutesFromMajorRoadsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__RouteOptions:
		return (void*)soap_instantiate_ns16__RouteOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__ArrayOfWaypoint:
		return (void*)soap_instantiate_ns16__ArrayOfWaypoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__Waypoint:
		return (void*)soap_instantiate_ns16__Waypoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__RouteResult:
		return (void*)soap_instantiate_ns16__RouteResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__ArrayOfRouteLeg:
		return (void*)soap_instantiate_ns16__ArrayOfRouteLeg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__RouteLeg:
		return (void*)soap_instantiate_ns16__RouteLeg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__ArrayOfItineraryItem:
		return (void*)soap_instantiate_ns16__ArrayOfItineraryItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__ItineraryItem:
		return (void*)soap_instantiate_ns16__ItineraryItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__ArrayOfItineraryItemHint:
		return (void*)soap_instantiate_ns16__ArrayOfItineraryItemHint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__ItineraryItemHint:
		return (void*)soap_instantiate_ns16__ItineraryItemHint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__RouteSummary:
		return (void*)soap_instantiate_ns16__RouteSummary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__ArrayOfItineraryItemWarning:
		return (void*)soap_instantiate_ns16__ArrayOfItineraryItemWarning(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__ItineraryItemWarning:
		return (void*)soap_instantiate_ns16__ItineraryItemWarning(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__RoutePath:
		return (void*)soap_instantiate_ns16__RoutePath(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__ArrayOfRouteResult:
		return (void*)soap_instantiate_ns16__ArrayOfRouteResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__UserLocation:
		return (void*)soap_instantiate_ns4__UserLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__GeocodeLocation:
		return (void*)soap_instantiate_ns4__GeocodeLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Rectangle:
		return (void*)soap_instantiate_ns4__Rectangle(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Circle:
		return (void*)soap_instantiate_ns4__Circle(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Polygon:
		return (void*)soap_instantiate_ns4__Polygon(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__FilterExpression:
		return (void*)soap_instantiate_ns4__FilterExpression(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__FilterExpressionClause:
		return (void*)soap_instantiate_ns4__FilterExpressionClause(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SearchRequest:
		return (void*)soap_instantiate_ns6__SearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SearchResponse:
		return (void*)soap_instantiate_ns6__SearchResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RangeFilter:
		return (void*)soap_instantiate_ns6__RangeFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ValueListFilter:
		return (void*)soap_instantiate_ns6__ValueListFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CommunityContentSearchResult:
		return (void*)soap_instantiate_ns6__CommunityContentSearchResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__BusinessSearchResult:
		return (void*)soap_instantiate_ns6__BusinessSearchResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__PersonSearchResult:
		return (void*)soap_instantiate_ns6__PersonSearchResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SearchPoint:
		return (void*)soap_instantiate_ns6__SearchPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns10__GeocodeRequest:
		return (void*)soap_instantiate_ns10__GeocodeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns10__ConfidenceFilter:
		return (void*)soap_instantiate_ns10__ConfidenceFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns10__GeocodeResponse:
		return (void*)soap_instantiate_ns10__GeocodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns10__ReverseGeocodeRequest:
		return (void*)soap_instantiate_ns10__ReverseGeocodeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns13__ImageryMetadataRequest:
		return (void*)soap_instantiate_ns13__ImageryMetadataRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns13__ImageryMetadataResponse:
		return (void*)soap_instantiate_ns13__ImageryMetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult:
		return (void*)soap_instantiate_ns13__ImageryMetadataBirdseyeResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns13__MapUriRequest:
		return (void*)soap_instantiate_ns13__MapUriRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns13__MapUriResponse:
		return (void*)soap_instantiate_ns13__MapUriResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__RouteRequest:
		return (void*)soap_instantiate_ns16__RouteRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__RouteResponse:
		return (void*)soap_instantiate_ns16__RouteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__MajorRoutesRequest:
		return (void*)soap_instantiate_ns16__MajorRoutesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__MajorRoutesOptions:
		return (void*)soap_instantiate_ns16__MajorRoutesOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__MajorRoutesResponse:
		return (void*)soap_instantiate_ns16__MajorRoutesResponse(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__GetVersionInfo:
		return (void*)soap_instantiate___ns1__GetVersionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetCountryRegionInfo:
		return (void*)soap_instantiate___ns1__GetCountryRegionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetEntityTypes:
		return (void*)soap_instantiate___ns1__GetEntityTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDataSourceInfo:
		return (void*)soap_instantiate___ns1__GetDataSourceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetGreatCircleDistances:
		return (void*)soap_instantiate___ns1__GetGreatCircleDistances(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetClientToken:
		return (void*)soap_instantiate___ns1__GetClientToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns10__Geocode:
		return (void*)soap_instantiate___ns10__Geocode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns10__ReverseGeocode:
		return (void*)soap_instantiate___ns10__ReverseGeocode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetImageryMetadata:
		return (void*)soap_instantiate___ns13__GetImageryMetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns13__GetMapUri:
		return (void*)soap_instantiate___ns13__GetMapUri(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns16__CalculateRoute:
		return (void*)soap_instantiate___ns16__CalculateRoute(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns16__CalculateRoutesFromMajorRoads:
		return (void*)soap_instantiate___ns16__CalculateRoutesFromMajorRoads(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__Search:
		return (void*)soap_instantiate___ns6__Search(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			delete (xsd__anyType*)p->ptr;
		else
			delete[] (xsd__anyType*)p->ptr;
		break;
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			delete (xsd__QName*)p->ptr;
		else
			delete[] (xsd__QName*)p->ptr;
		break;
	case SOAP_TYPE_xsd__anyURI_:
		if (p->size < 0)
			delete (xsd__anyURI_*)p->ptr;
		else
			delete[] (xsd__anyURI_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			delete (xsd__base64Binary*)p->ptr;
		else
			delete[] (xsd__base64Binary*)p->ptr;
		break;
	case SOAP_TYPE_xsd__base64Binary_:
		if (p->size < 0)
			delete (xsd__base64Binary_*)p->ptr;
		else
			delete[] (xsd__base64Binary_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__boolean:
		if (p->size < 0)
			delete (xsd__boolean*)p->ptr;
		else
			delete[] (xsd__boolean*)p->ptr;
		break;
	case SOAP_TYPE_xsd__byte_:
		if (p->size < 0)
			delete (xsd__byte_*)p->ptr;
		else
			delete[] (xsd__byte_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__dateTime:
		if (p->size < 0)
			delete (xsd__dateTime*)p->ptr;
		else
			delete[] (xsd__dateTime*)p->ptr;
		break;
	case SOAP_TYPE_xsd__decimal_:
		if (p->size < 0)
			delete (xsd__decimal_*)p->ptr;
		else
			delete[] (xsd__decimal_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__double:
		if (p->size < 0)
			delete (xsd__double*)p->ptr;
		else
			delete[] (xsd__double*)p->ptr;
		break;
	case SOAP_TYPE_xsd__duration_:
		if (p->size < 0)
			delete (xsd__duration_*)p->ptr;
		else
			delete[] (xsd__duration_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__float:
		if (p->size < 0)
			delete (xsd__float*)p->ptr;
		else
			delete[] (xsd__float*)p->ptr;
		break;
	case SOAP_TYPE_xsd__int:
		if (p->size < 0)
			delete (xsd__int*)p->ptr;
		else
			delete[] (xsd__int*)p->ptr;
		break;
	case SOAP_TYPE_xsd__long:
		if (p->size < 0)
			delete (xsd__long*)p->ptr;
		else
			delete[] (xsd__long*)p->ptr;
		break;
	case SOAP_TYPE_xsd__short:
		if (p->size < 0)
			delete (xsd__short*)p->ptr;
		else
			delete[] (xsd__short*)p->ptr;
		break;
	case SOAP_TYPE_xsd__string:
		if (p->size < 0)
			delete (xsd__string*)p->ptr;
		else
			delete[] (xsd__string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedByte_:
		if (p->size < 0)
			delete (xsd__unsignedByte_*)p->ptr;
		else
			delete[] (xsd__unsignedByte_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedInt:
		if (p->size < 0)
			delete (xsd__unsignedInt*)p->ptr;
		else
			delete[] (xsd__unsignedInt*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedLong:
		if (p->size < 0)
			delete (xsd__unsignedLong*)p->ptr;
		else
			delete[] (xsd__unsignedLong*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedShort:
		if (p->size < 0)
			delete (xsd__unsignedShort*)p->ptr;
		else
			delete[] (xsd__unsignedShort*)p->ptr;
		break;
	case SOAP_TYPE_ns1__DataSourceCapability_:
		if (p->size < 0)
			delete (ns1__DataSourceCapability_*)p->ptr;
		else
			delete[] (ns1__DataSourceCapability_*)p->ptr;
		break;
	case SOAP_TYPE_ns1__DistanceUnit_:
		if (p->size < 0)
			delete (ns1__DistanceUnit_*)p->ptr;
		else
			delete[] (ns1__DistanceUnit_*)p->ptr;
		break;
	case SOAP_TYPE_ns4__Confidence_:
		if (p->size < 0)
			delete (ns4__Confidence_*)p->ptr;
		else
			delete[] (ns4__Confidence_*)p->ptr;
		break;
	case SOAP_TYPE_ns4__DeviceType_:
		if (p->size < 0)
			delete (ns4__DeviceType_*)p->ptr;
		else
			delete[] (ns4__DeviceType_*)p->ptr;
		break;
	case SOAP_TYPE_ns4__DistanceUnit_:
		if (p->size < 0)
			delete (ns4__DistanceUnit_*)p->ptr;
		else
			delete[] (ns4__DistanceUnit_*)p->ptr;
		break;
	case SOAP_TYPE_ns4__CompareOperator_:
		if (p->size < 0)
			delete (ns4__CompareOperator_*)p->ptr;
		else
			delete[] (ns4__CompareOperator_*)p->ptr;
		break;
	case SOAP_TYPE_ns4__LogicalOperator_:
		if (p->size < 0)
			delete (ns4__LogicalOperator_*)p->ptr;
		else
			delete[] (ns4__LogicalOperator_*)p->ptr;
		break;
	case SOAP_TYPE_ns4__AuthenticationResultCode_:
		if (p->size < 0)
			delete (ns4__AuthenticationResultCode_*)p->ptr;
		else
			delete[] (ns4__AuthenticationResultCode_*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ResponseStatusCode_:
		if (p->size < 0)
			delete (ns4__ResponseStatusCode_*)p->ptr;
		else
			delete[] (ns4__ResponseStatusCode_*)p->ptr;
		break;
	case SOAP_TYPE_ns4__UriScheme_:
		if (p->size < 0)
			delete (ns4__UriScheme_*)p->ptr;
		else
			delete[] (ns4__UriScheme_*)p->ptr;
		break;
	case SOAP_TYPE_ns4__MapStyle_:
		if (p->size < 0)
			delete (ns4__MapStyle_*)p->ptr;
		else
			delete[] (ns4__MapStyle_*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ImageType_:
		if (p->size < 0)
			delete (ns4__ImageType_*)p->ptr;
		else
			delete[] (ns4__ImageType_*)p->ptr;
		break;
	case SOAP_TYPE_ns5__char__:
		if (p->size < 0)
			delete (ns5__char__*)p->ptr;
		else
			delete[] (ns5__char__*)p->ptr;
		break;
	case SOAP_TYPE_ns5__duration__:
		if (p->size < 0)
			delete (ns5__duration__*)p->ptr;
		else
			delete[] (ns5__duration__*)p->ptr;
		break;
	case SOAP_TYPE_ns5__guid__:
		if (p->size < 0)
			delete (ns5__guid__*)p->ptr;
		else
			delete[] (ns5__guid__*)p->ptr;
		break;
	case SOAP_TYPE_ns6__ListingType_:
		if (p->size < 0)
			delete (ns6__ListingType_*)p->ptr;
		else
			delete[] (ns6__ListingType_*)p->ptr;
		break;
	case SOAP_TYPE_ns6__SortOrder_:
		if (p->size < 0)
			delete (ns6__SortOrder_*)p->ptr;
		else
			delete[] (ns6__SortOrder_*)p->ptr;
		break;
	case SOAP_TYPE_ns16__TravelMode_:
		if (p->size < 0)
			delete (ns16__TravelMode_*)p->ptr;
		else
			delete[] (ns16__TravelMode_*)p->ptr;
		break;
	case SOAP_TYPE_ns16__RouteOptimization_:
		if (p->size < 0)
			delete (ns16__RouteOptimization_*)p->ptr;
		else
			delete[] (ns16__RouteOptimization_*)p->ptr;
		break;
	case SOAP_TYPE_ns16__RoutePathType_:
		if (p->size < 0)
			delete (ns16__RoutePathType_*)p->ptr;
		else
			delete[] (ns16__RoutePathType_*)p->ptr;
		break;
	case SOAP_TYPE_ns16__TrafficUsage_:
		if (p->size < 0)
			delete (ns16__TrafficUsage_*)p->ptr;
		else
			delete[] (ns16__TrafficUsage_*)p->ptr;
		break;
	case SOAP_TYPE_ns16__ItineraryItemHintType_:
		if (p->size < 0)
			delete (ns16__ItineraryItemHintType_*)p->ptr;
		else
			delete[] (ns16__ItineraryItemHintType_*)p->ptr;
		break;
	case SOAP_TYPE_ns16__ManeuverType_:
		if (p->size < 0)
			delete (ns16__ManeuverType_*)p->ptr;
		else
			delete[] (ns16__ManeuverType_*)p->ptr;
		break;
	case SOAP_TYPE_ns16__ItineraryWarningSeverity_:
		if (p->size < 0)
			delete (ns16__ItineraryWarningSeverity_*)p->ptr;
		else
			delete[] (ns16__ItineraryWarningSeverity_*)p->ptr;
		break;
	case SOAP_TYPE_ns16__ItineraryWarningType_:
		if (p->size < 0)
			delete (ns16__ItineraryWarningType_*)p->ptr;
		else
			delete[] (ns16__ItineraryWarningType_*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfVersionInfo:
		if (p->size < 0)
			delete (ns1__ArrayOfVersionInfo*)p->ptr;
		else
			delete[] (ns1__ArrayOfVersionInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__VersionInfo:
		if (p->size < 0)
			delete (ns1__VersionInfo*)p->ptr;
		else
			delete[] (ns1__VersionInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CustomerInfoHeader:
		if (p->size < 0)
			delete (ns1__CustomerInfoHeader*)p->ptr;
		else
			delete[] (ns1__CustomerInfoHeader*)p->ptr;
		break;
	case SOAP_TYPE_ns1__UserInfoHeader:
		if (p->size < 0)
			delete (ns1__UserInfoHeader*)p->ptr;
		else
			delete[] (ns1__UserInfoHeader*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CultureInfo:
		if (p->size < 0)
			delete (ns1__CultureInfo*)p->ptr;
		else
			delete[] (ns1__CultureInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CountryRegionContext:
		if (p->size < 0)
			delete (ns1__CountryRegionContext*)p->ptr;
		else
			delete[] (ns1__CountryRegionContext*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfInt:
		if (p->size < 0)
			delete (ns1__ArrayOfInt*)p->ptr;
		else
			delete[] (ns1__ArrayOfInt*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfCountryRegionInfo:
		if (p->size < 0)
			delete (ns1__ArrayOfCountryRegionInfo*)p->ptr;
		else
			delete[] (ns1__ArrayOfCountryRegionInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CountryRegionInfo:
		if (p->size < 0)
			delete (ns1__CountryRegionInfo*)p->ptr;
		else
			delete[] (ns1__CountryRegionInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__LatLong:
		if (p->size < 0)
			delete (ns1__LatLong*)p->ptr;
		else
			delete[] (ns1__LatLong*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfEntityType:
		if (p->size < 0)
			delete (ns1__ArrayOfEntityType*)p->ptr;
		else
			delete[] (ns1__ArrayOfEntityType*)p->ptr;
		break;
	case SOAP_TYPE_ns1__EntityType:
		if (p->size < 0)
			delete (ns1__EntityType*)p->ptr;
		else
			delete[] (ns1__EntityType*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfEntityProperty:
		if (p->size < 0)
			delete (ns1__ArrayOfEntityProperty*)p->ptr;
		else
			delete[] (ns1__ArrayOfEntityProperty*)p->ptr;
		break;
	case SOAP_TYPE_ns1__EntityProperty:
		if (p->size < 0)
			delete (ns1__EntityProperty*)p->ptr;
		else
			delete[] (ns1__EntityProperty*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		if (p->size < 0)
			delete (ns1__ArrayOfString*)p->ptr;
		else
			delete[] (ns1__ArrayOfString*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfDataSource:
		if (p->size < 0)
			delete (ns1__ArrayOfDataSource*)p->ptr;
		else
			delete[] (ns1__ArrayOfDataSource*)p->ptr;
		break;
	case SOAP_TYPE_ns1__DataSource:
		if (p->size < 0)
			delete (ns1__DataSource*)p->ptr;
		else
			delete[] (ns1__DataSource*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfLatLong:
		if (p->size < 0)
			delete (ns1__ArrayOfLatLong*)p->ptr;
		else
			delete[] (ns1__ArrayOfLatLong*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfDouble:
		if (p->size < 0)
			delete (ns1__ArrayOfDouble*)p->ptr;
		else
			delete[] (ns1__ArrayOfDouble*)p->ptr;
		break;
	case SOAP_TYPE_ns1__TokenSpecification:
		if (p->size < 0)
			delete (ns1__TokenSpecification*)p->ptr;
		else
			delete[] (ns1__TokenSpecification*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetVersionInfo:
		if (p->size < 0)
			delete (_ns1__GetVersionInfo*)p->ptr;
		else
			delete[] (_ns1__GetVersionInfo*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetVersionInfoResponse:
		if (p->size < 0)
			delete (_ns1__GetVersionInfoResponse*)p->ptr;
		else
			delete[] (_ns1__GetVersionInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetCountryRegionInfo:
		if (p->size < 0)
			delete (_ns1__GetCountryRegionInfo*)p->ptr;
		else
			delete[] (_ns1__GetCountryRegionInfo*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetCountryRegionInfoResponse:
		if (p->size < 0)
			delete (_ns1__GetCountryRegionInfoResponse*)p->ptr;
		else
			delete[] (_ns1__GetCountryRegionInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetEntityTypes:
		if (p->size < 0)
			delete (_ns1__GetEntityTypes*)p->ptr;
		else
			delete[] (_ns1__GetEntityTypes*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetEntityTypesResponse:
		if (p->size < 0)
			delete (_ns1__GetEntityTypesResponse*)p->ptr;
		else
			delete[] (_ns1__GetEntityTypesResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetDataSourceInfo:
		if (p->size < 0)
			delete (_ns1__GetDataSourceInfo*)p->ptr;
		else
			delete[] (_ns1__GetDataSourceInfo*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetDataSourceInfoResponse:
		if (p->size < 0)
			delete (_ns1__GetDataSourceInfoResponse*)p->ptr;
		else
			delete[] (_ns1__GetDataSourceInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetGreatCircleDistances:
		if (p->size < 0)
			delete (_ns1__GetGreatCircleDistances*)p->ptr;
		else
			delete[] (_ns1__GetGreatCircleDistances*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetGreatCircleDistancesResponse:
		if (p->size < 0)
			delete (_ns1__GetGreatCircleDistancesResponse*)p->ptr;
		else
			delete[] (_ns1__GetGreatCircleDistancesResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetClientToken:
		if (p->size < 0)
			delete (_ns1__GetClientToken*)p->ptr;
		else
			delete[] (_ns1__GetClientToken*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetClientTokenResponse:
		if (p->size < 0)
			delete (_ns1__GetClientTokenResponse*)p->ptr;
		else
			delete[] (_ns1__GetClientTokenResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__Search:
		if (p->size < 0)
			delete (_ns3__Search*)p->ptr;
		else
			delete[] (_ns3__Search*)p->ptr;
		break;
	case SOAP_TYPE__ns3__SearchResponse:
		if (p->size < 0)
			delete (_ns3__SearchResponse*)p->ptr;
		else
			delete[] (_ns3__SearchResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns4__RequestBase:
		if (p->size < 0)
			delete (ns4__RequestBase*)p->ptr;
		else
			delete[] (ns4__RequestBase*)p->ptr;
		break;
	case SOAP_TYPE_ns4__Credentials:
		if (p->size < 0)
			delete (ns4__Credentials*)p->ptr;
		else
			delete[] (ns4__Credentials*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ExecutionOptions:
		if (p->size < 0)
			delete (ns4__ExecutionOptions*)p->ptr;
		else
			delete[] (ns4__ExecutionOptions*)p->ptr;
		break;
	case SOAP_TYPE_ns4__UserProfile:
		if (p->size < 0)
			delete (ns4__UserProfile*)p->ptr;
		else
			delete[] (ns4__UserProfile*)p->ptr;
		break;
	case SOAP_TYPE_ns4__Heading:
		if (p->size < 0)
			delete (ns4__Heading*)p->ptr;
		else
			delete[] (ns4__Heading*)p->ptr;
		break;
	case SOAP_TYPE_ns4__Location:
		if (p->size < 0)
			delete (ns4__Location*)p->ptr;
		else
			delete[] (ns4__Location*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ShapeBase:
		if (p->size < 0)
			delete (ns4__ShapeBase*)p->ptr;
		else
			delete[] (ns4__ShapeBase*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfLocation:
		if (p->size < 0)
			delete (ns4__ArrayOfLocation*)p->ptr;
		else
			delete[] (ns4__ArrayOfLocation*)p->ptr;
		break;
	case SOAP_TYPE_ns4__SizeOfint:
		if (p->size < 0)
			delete (ns4__SizeOfint*)p->ptr;
		else
			delete[] (ns4__SizeOfint*)p->ptr;
		break;
	case SOAP_TYPE_ns4__FilterExpressionBase:
		if (p->size < 0)
			delete (ns4__FilterExpressionBase*)p->ptr;
		else
			delete[] (ns4__FilterExpressionBase*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfFilterExpressionBase:
		if (p->size < 0)
			delete (ns4__ArrayOfFilterExpressionBase*)p->ptr;
		else
			delete[] (ns4__ArrayOfFilterExpressionBase*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ResponseBase:
		if (p->size < 0)
			delete (ns4__ResponseBase*)p->ptr;
		else
			delete[] (ns4__ResponseBase*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ResponseSummary:
		if (p->size < 0)
			delete (ns4__ResponseSummary*)p->ptr;
		else
			delete[] (ns4__ResponseSummary*)p->ptr;
		break;
	case SOAP_TYPE_ns4__GeocodeResult:
		if (p->size < 0)
			delete (ns4__GeocodeResult*)p->ptr;
		else
			delete[] (ns4__GeocodeResult*)p->ptr;
		break;
	case SOAP_TYPE_ns4__Address:
		if (p->size < 0)
			delete (ns4__Address*)p->ptr;
		else
			delete[] (ns4__Address*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfGeocodeLocation:
		if (p->size < 0)
			delete (ns4__ArrayOfGeocodeLocation*)p->ptr;
		else
			delete[] (ns4__ArrayOfGeocodeLocation*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfGeocodeResult:
		if (p->size < 0)
			delete (ns4__ArrayOfGeocodeResult*)p->ptr;
		else
			delete[] (ns4__ArrayOfGeocodeResult*)p->ptr;
		break;
	case SOAP_TYPE_ns4__RangeOfint:
		if (p->size < 0)
			delete (ns4__RangeOfint*)p->ptr;
		else
			delete[] (ns4__RangeOfint*)p->ptr;
		break;
	case SOAP_TYPE_ns4__RangeOfdateTime:
		if (p->size < 0)
			delete (ns4__RangeOfdateTime*)p->ptr;
		else
			delete[] (ns4__RangeOfdateTime*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ArrayOfPushpin:
		if (p->size < 0)
			delete (ns4__ArrayOfPushpin*)p->ptr;
		else
			delete[] (ns4__ArrayOfPushpin*)p->ptr;
		break;
	case SOAP_TYPE_ns4__Pushpin:
		if (p->size < 0)
			delete (ns4__Pushpin*)p->ptr;
		else
			delete[] (ns4__Pushpin*)p->ptr;
		break;
	case SOAP_TYPE_ns6__SearchOptions:
		if (p->size < 0)
			delete (ns6__SearchOptions*)p->ptr;
		else
			delete[] (ns6__SearchOptions*)p->ptr;
		break;
	case SOAP_TYPE_ns6__StructuredSearchQuery:
		if (p->size < 0)
			delete (ns6__StructuredSearchQuery*)p->ptr;
		else
			delete[] (ns6__StructuredSearchQuery*)p->ptr;
		break;
	case SOAP_TYPE_ns6__QuerySuggestion:
		if (p->size < 0)
			delete (ns6__QuerySuggestion*)p->ptr;
		else
			delete[] (ns6__QuerySuggestion*)p->ptr;
		break;
	case SOAP_TYPE_ns6__ArrayOfSearchResultSet:
		if (p->size < 0)
			delete (ns6__ArrayOfSearchResultSet*)p->ptr;
		else
			delete[] (ns6__ArrayOfSearchResultSet*)p->ptr;
		break;
	case SOAP_TYPE_ns6__SearchResultSet:
		if (p->size < 0)
			delete (ns6__SearchResultSet*)p->ptr;
		else
			delete[] (ns6__SearchResultSet*)p->ptr;
		break;
	case SOAP_TYPE_ns6__ArrayOfSearchRegion:
		if (p->size < 0)
			delete (ns6__ArrayOfSearchRegion*)p->ptr;
		else
			delete[] (ns6__ArrayOfSearchRegion*)p->ptr;
		break;
	case SOAP_TYPE_ns6__SearchRegion:
		if (p->size < 0)
			delete (ns6__SearchRegion*)p->ptr;
		else
			delete[] (ns6__SearchRegion*)p->ptr;
		break;
	case SOAP_TYPE_ns6__ArrayOfAvailableFilter:
		if (p->size < 0)
			delete (ns6__ArrayOfAvailableFilter*)p->ptr;
		else
			delete[] (ns6__ArrayOfAvailableFilter*)p->ptr;
		break;
	case SOAP_TYPE_ns6__AvailableFilter:
		if (p->size < 0)
			delete (ns6__AvailableFilter*)p->ptr;
		else
			delete[] (ns6__AvailableFilter*)p->ptr;
		break;
	case SOAP_TYPE_ns6__Neighborhood:
		if (p->size < 0)
			delete (ns6__Neighborhood*)p->ptr;
		else
			delete[] (ns6__Neighborhood*)p->ptr;
		break;
	case SOAP_TYPE_ns6__Category:
		if (p->size < 0)
			delete (ns6__Category*)p->ptr;
		else
			delete[] (ns6__Category*)p->ptr;
		break;
	case SOAP_TYPE_ns6__FilterValue:
		if (p->size < 0)
			delete (ns6__FilterValue*)p->ptr;
		else
			delete[] (ns6__FilterValue*)p->ptr;
		break;
	case SOAP_TYPE_ns6__ArrayOfCategoryCount:
		if (p->size < 0)
			delete (ns6__ArrayOfCategoryCount*)p->ptr;
		else
			delete[] (ns6__ArrayOfCategoryCount*)p->ptr;
		break;
	case SOAP_TYPE_ns6__CategoryCount:
		if (p->size < 0)
			delete (ns6__CategoryCount*)p->ptr;
		else
			delete[] (ns6__CategoryCount*)p->ptr;
		break;
	case SOAP_TYPE_ns6__Parse:
		if (p->size < 0)
			delete (ns6__Parse*)p->ptr;
		else
			delete[] (ns6__Parse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__ArrayOfSearchResultBase:
		if (p->size < 0)
			delete (ns6__ArrayOfSearchResultBase*)p->ptr;
		else
			delete[] (ns6__ArrayOfSearchResultBase*)p->ptr;
		break;
	case SOAP_TYPE_ns6__SearchResultBase:
		if (p->size < 0)
			delete (ns6__SearchResultBase*)p->ptr;
		else
			delete[] (ns6__SearchResultBase*)p->ptr;
		break;
	case SOAP_TYPE_ns6__LocationData:
		if (p->size < 0)
			delete (ns6__LocationData*)p->ptr;
		else
			delete[] (ns6__LocationData*)p->ptr;
		break;
	case SOAP_TYPE_ns6__ArrayOfCategory:
		if (p->size < 0)
			delete (ns6__ArrayOfCategory*)p->ptr;
		else
			delete[] (ns6__ArrayOfCategory*)p->ptr;
		break;
	case SOAP_TYPE_ns6__CategorySpecificPropertySet:
		if (p->size < 0)
			delete (ns6__CategorySpecificPropertySet*)p->ptr;
		else
			delete[] (ns6__CategorySpecificPropertySet*)p->ptr;
		break;
	case SOAP_TYPE_ns6__ArrayOfNeighborhood:
		if (p->size < 0)
			delete (ns6__ArrayOfNeighborhood*)p->ptr;
		else
			delete[] (ns6__ArrayOfNeighborhood*)p->ptr;
		break;
	case SOAP_TYPE_ns7__ArrayOfstring:
		if (p->size < 0)
			delete (ns7__ArrayOfstring*)p->ptr;
		else
			delete[] (ns7__ArrayOfstring*)p->ptr;
		break;
	case SOAP_TYPE_ns7__ArrayOfanyType:
		if (p->size < 0)
			delete (ns7__ArrayOfanyType*)p->ptr;
		else
			delete[] (ns7__ArrayOfanyType*)p->ptr;
		break;
	case SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6:
		if (p->size < 0)
			delete (_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6*)p->ptr;
		else
			delete[] (_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6*)p->ptr;
		break;
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6:
		if (p->size < 0)
			delete (ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6*)p->ptr;
		else
			delete[] (ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6*)p->ptr;
		break;
	case SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType:
		if (p->size < 0)
			delete (_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType*)p->ptr;
		else
			delete[] (_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType*)p->ptr;
		break;
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType:
		if (p->size < 0)
			delete (ns7__ArrayOfKeyValueOfstringanyType*)p->ptr;
		else
			delete[] (ns7__ArrayOfKeyValueOfstringanyType*)p->ptr;
		break;
	case SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		if (p->size < 0)
			delete (_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)p->ptr;
		else
			delete[] (_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)p->ptr;
		break;
	case SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s:
		if (p->size < 0)
			delete (ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)p->ptr;
		else
			delete[] (ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)p->ptr;
		break;
	case SOAP_TYPE__ns9__Geocode:
		if (p->size < 0)
			delete (_ns9__Geocode*)p->ptr;
		else
			delete[] (_ns9__Geocode*)p->ptr;
		break;
	case SOAP_TYPE__ns9__GeocodeResponse:
		if (p->size < 0)
			delete (_ns9__GeocodeResponse*)p->ptr;
		else
			delete[] (_ns9__GeocodeResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns9__ReverseGeocode:
		if (p->size < 0)
			delete (_ns9__ReverseGeocode*)p->ptr;
		else
			delete[] (_ns9__ReverseGeocode*)p->ptr;
		break;
	case SOAP_TYPE__ns9__ReverseGeocodeResponse:
		if (p->size < 0)
			delete (_ns9__ReverseGeocodeResponse*)p->ptr;
		else
			delete[] (_ns9__ReverseGeocodeResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns10__GeocodeOptions:
		if (p->size < 0)
			delete (ns10__GeocodeOptions*)p->ptr;
		else
			delete[] (ns10__GeocodeOptions*)p->ptr;
		break;
	case SOAP_TYPE_ns10__ArrayOfFilterBase:
		if (p->size < 0)
			delete (ns10__ArrayOfFilterBase*)p->ptr;
		else
			delete[] (ns10__ArrayOfFilterBase*)p->ptr;
		break;
	case SOAP_TYPE_ns10__FilterBase:
		if (p->size < 0)
			delete (ns10__FilterBase*)p->ptr;
		else
			delete[] (ns10__FilterBase*)p->ptr;
		break;
	case SOAP_TYPE__ns12__GetImageryMetadata:
		if (p->size < 0)
			delete (_ns12__GetImageryMetadata*)p->ptr;
		else
			delete[] (_ns12__GetImageryMetadata*)p->ptr;
		break;
	case SOAP_TYPE__ns12__GetImageryMetadataResponse:
		if (p->size < 0)
			delete (_ns12__GetImageryMetadataResponse*)p->ptr;
		else
			delete[] (_ns12__GetImageryMetadataResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns12__GetMapUri:
		if (p->size < 0)
			delete (_ns12__GetMapUri*)p->ptr;
		else
			delete[] (_ns12__GetMapUri*)p->ptr;
		break;
	case SOAP_TYPE__ns12__GetMapUriResponse:
		if (p->size < 0)
			delete (_ns12__GetMapUriResponse*)p->ptr;
		else
			delete[] (_ns12__GetMapUriResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns13__ImageryMetadataOptions:
		if (p->size < 0)
			delete (ns13__ImageryMetadataOptions*)p->ptr;
		else
			delete[] (ns13__ImageryMetadataOptions*)p->ptr;
		break;
	case SOAP_TYPE_ns13__ArrayOfImageryMetadataResult:
		if (p->size < 0)
			delete (ns13__ArrayOfImageryMetadataResult*)p->ptr;
		else
			delete[] (ns13__ArrayOfImageryMetadataResult*)p->ptr;
		break;
	case SOAP_TYPE_ns13__ImageryMetadataResult:
		if (p->size < 0)
			delete (ns13__ImageryMetadataResult*)p->ptr;
		else
			delete[] (ns13__ImageryMetadataResult*)p->ptr;
		break;
	case SOAP_TYPE_ns13__ArrayOfImageryProvider:
		if (p->size < 0)
			delete (ns13__ArrayOfImageryProvider*)p->ptr;
		else
			delete[] (ns13__ArrayOfImageryProvider*)p->ptr;
		break;
	case SOAP_TYPE_ns13__ImageryProvider:
		if (p->size < 0)
			delete (ns13__ImageryProvider*)p->ptr;
		else
			delete[] (ns13__ImageryProvider*)p->ptr;
		break;
	case SOAP_TYPE_ns13__ArrayOfCoverageArea:
		if (p->size < 0)
			delete (ns13__ArrayOfCoverageArea*)p->ptr;
		else
			delete[] (ns13__ArrayOfCoverageArea*)p->ptr;
		break;
	case SOAP_TYPE_ns13__CoverageArea:
		if (p->size < 0)
			delete (ns13__CoverageArea*)p->ptr;
		else
			delete[] (ns13__CoverageArea*)p->ptr;
		break;
	case SOAP_TYPE_ns13__MapUriOptions:
		if (p->size < 0)
			delete (ns13__MapUriOptions*)p->ptr;
		else
			delete[] (ns13__MapUriOptions*)p->ptr;
		break;
	case SOAP_TYPE__ns15__CalculateRoute:
		if (p->size < 0)
			delete (_ns15__CalculateRoute*)p->ptr;
		else
			delete[] (_ns15__CalculateRoute*)p->ptr;
		break;
	case SOAP_TYPE__ns15__CalculateRouteResponse:
		if (p->size < 0)
			delete (_ns15__CalculateRouteResponse*)p->ptr;
		else
			delete[] (_ns15__CalculateRouteResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns15__CalculateRoutesFromMajorRoads:
		if (p->size < 0)
			delete (_ns15__CalculateRoutesFromMajorRoads*)p->ptr;
		else
			delete[] (_ns15__CalculateRoutesFromMajorRoads*)p->ptr;
		break;
	case SOAP_TYPE__ns15__CalculateRoutesFromMajorRoadsResponse:
		if (p->size < 0)
			delete (_ns15__CalculateRoutesFromMajorRoadsResponse*)p->ptr;
		else
			delete[] (_ns15__CalculateRoutesFromMajorRoadsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns16__RouteOptions:
		if (p->size < 0)
			delete (ns16__RouteOptions*)p->ptr;
		else
			delete[] (ns16__RouteOptions*)p->ptr;
		break;
	case SOAP_TYPE_ns16__ArrayOfWaypoint:
		if (p->size < 0)
			delete (ns16__ArrayOfWaypoint*)p->ptr;
		else
			delete[] (ns16__ArrayOfWaypoint*)p->ptr;
		break;
	case SOAP_TYPE_ns16__Waypoint:
		if (p->size < 0)
			delete (ns16__Waypoint*)p->ptr;
		else
			delete[] (ns16__Waypoint*)p->ptr;
		break;
	case SOAP_TYPE_ns16__RouteResult:
		if (p->size < 0)
			delete (ns16__RouteResult*)p->ptr;
		else
			delete[] (ns16__RouteResult*)p->ptr;
		break;
	case SOAP_TYPE_ns16__ArrayOfRouteLeg:
		if (p->size < 0)
			delete (ns16__ArrayOfRouteLeg*)p->ptr;
		else
			delete[] (ns16__ArrayOfRouteLeg*)p->ptr;
		break;
	case SOAP_TYPE_ns16__RouteLeg:
		if (p->size < 0)
			delete (ns16__RouteLeg*)p->ptr;
		else
			delete[] (ns16__RouteLeg*)p->ptr;
		break;
	case SOAP_TYPE_ns16__ArrayOfItineraryItem:
		if (p->size < 0)
			delete (ns16__ArrayOfItineraryItem*)p->ptr;
		else
			delete[] (ns16__ArrayOfItineraryItem*)p->ptr;
		break;
	case SOAP_TYPE_ns16__ItineraryItem:
		if (p->size < 0)
			delete (ns16__ItineraryItem*)p->ptr;
		else
			delete[] (ns16__ItineraryItem*)p->ptr;
		break;
	case SOAP_TYPE_ns16__ArrayOfItineraryItemHint:
		if (p->size < 0)
			delete (ns16__ArrayOfItineraryItemHint*)p->ptr;
		else
			delete[] (ns16__ArrayOfItineraryItemHint*)p->ptr;
		break;
	case SOAP_TYPE_ns16__ItineraryItemHint:
		if (p->size < 0)
			delete (ns16__ItineraryItemHint*)p->ptr;
		else
			delete[] (ns16__ItineraryItemHint*)p->ptr;
		break;
	case SOAP_TYPE_ns16__RouteSummary:
		if (p->size < 0)
			delete (ns16__RouteSummary*)p->ptr;
		else
			delete[] (ns16__RouteSummary*)p->ptr;
		break;
	case SOAP_TYPE_ns16__ArrayOfItineraryItemWarning:
		if (p->size < 0)
			delete (ns16__ArrayOfItineraryItemWarning*)p->ptr;
		else
			delete[] (ns16__ArrayOfItineraryItemWarning*)p->ptr;
		break;
	case SOAP_TYPE_ns16__ItineraryItemWarning:
		if (p->size < 0)
			delete (ns16__ItineraryItemWarning*)p->ptr;
		else
			delete[] (ns16__ItineraryItemWarning*)p->ptr;
		break;
	case SOAP_TYPE_ns16__RoutePath:
		if (p->size < 0)
			delete (ns16__RoutePath*)p->ptr;
		else
			delete[] (ns16__RoutePath*)p->ptr;
		break;
	case SOAP_TYPE_ns16__ArrayOfRouteResult:
		if (p->size < 0)
			delete (ns16__ArrayOfRouteResult*)p->ptr;
		else
			delete[] (ns16__ArrayOfRouteResult*)p->ptr;
		break;
	case SOAP_TYPE_ns4__UserLocation:
		if (p->size < 0)
			delete (ns4__UserLocation*)p->ptr;
		else
			delete[] (ns4__UserLocation*)p->ptr;
		break;
	case SOAP_TYPE_ns4__GeocodeLocation:
		if (p->size < 0)
			delete (ns4__GeocodeLocation*)p->ptr;
		else
			delete[] (ns4__GeocodeLocation*)p->ptr;
		break;
	case SOAP_TYPE_ns4__Rectangle:
		if (p->size < 0)
			delete (ns4__Rectangle*)p->ptr;
		else
			delete[] (ns4__Rectangle*)p->ptr;
		break;
	case SOAP_TYPE_ns4__Circle:
		if (p->size < 0)
			delete (ns4__Circle*)p->ptr;
		else
			delete[] (ns4__Circle*)p->ptr;
		break;
	case SOAP_TYPE_ns4__Polygon:
		if (p->size < 0)
			delete (ns4__Polygon*)p->ptr;
		else
			delete[] (ns4__Polygon*)p->ptr;
		break;
	case SOAP_TYPE_ns4__FilterExpression:
		if (p->size < 0)
			delete (ns4__FilterExpression*)p->ptr;
		else
			delete[] (ns4__FilterExpression*)p->ptr;
		break;
	case SOAP_TYPE_ns4__FilterExpressionClause:
		if (p->size < 0)
			delete (ns4__FilterExpressionClause*)p->ptr;
		else
			delete[] (ns4__FilterExpressionClause*)p->ptr;
		break;
	case SOAP_TYPE_ns6__SearchRequest:
		if (p->size < 0)
			delete (ns6__SearchRequest*)p->ptr;
		else
			delete[] (ns6__SearchRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns6__SearchResponse:
		if (p->size < 0)
			delete (ns6__SearchResponse*)p->ptr;
		else
			delete[] (ns6__SearchResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__RangeFilter:
		if (p->size < 0)
			delete (ns6__RangeFilter*)p->ptr;
		else
			delete[] (ns6__RangeFilter*)p->ptr;
		break;
	case SOAP_TYPE_ns6__ValueListFilter:
		if (p->size < 0)
			delete (ns6__ValueListFilter*)p->ptr;
		else
			delete[] (ns6__ValueListFilter*)p->ptr;
		break;
	case SOAP_TYPE_ns6__CommunityContentSearchResult:
		if (p->size < 0)
			delete (ns6__CommunityContentSearchResult*)p->ptr;
		else
			delete[] (ns6__CommunityContentSearchResult*)p->ptr;
		break;
	case SOAP_TYPE_ns6__BusinessSearchResult:
		if (p->size < 0)
			delete (ns6__BusinessSearchResult*)p->ptr;
		else
			delete[] (ns6__BusinessSearchResult*)p->ptr;
		break;
	case SOAP_TYPE_ns6__PersonSearchResult:
		if (p->size < 0)
			delete (ns6__PersonSearchResult*)p->ptr;
		else
			delete[] (ns6__PersonSearchResult*)p->ptr;
		break;
	case SOAP_TYPE_ns6__SearchPoint:
		if (p->size < 0)
			delete (ns6__SearchPoint*)p->ptr;
		else
			delete[] (ns6__SearchPoint*)p->ptr;
		break;
	case SOAP_TYPE_ns10__GeocodeRequest:
		if (p->size < 0)
			delete (ns10__GeocodeRequest*)p->ptr;
		else
			delete[] (ns10__GeocodeRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns10__ConfidenceFilter:
		if (p->size < 0)
			delete (ns10__ConfidenceFilter*)p->ptr;
		else
			delete[] (ns10__ConfidenceFilter*)p->ptr;
		break;
	case SOAP_TYPE_ns10__GeocodeResponse:
		if (p->size < 0)
			delete (ns10__GeocodeResponse*)p->ptr;
		else
			delete[] (ns10__GeocodeResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns10__ReverseGeocodeRequest:
		if (p->size < 0)
			delete (ns10__ReverseGeocodeRequest*)p->ptr;
		else
			delete[] (ns10__ReverseGeocodeRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns13__ImageryMetadataRequest:
		if (p->size < 0)
			delete (ns13__ImageryMetadataRequest*)p->ptr;
		else
			delete[] (ns13__ImageryMetadataRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns13__ImageryMetadataResponse:
		if (p->size < 0)
			delete (ns13__ImageryMetadataResponse*)p->ptr;
		else
			delete[] (ns13__ImageryMetadataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult:
		if (p->size < 0)
			delete (ns13__ImageryMetadataBirdseyeResult*)p->ptr;
		else
			delete[] (ns13__ImageryMetadataBirdseyeResult*)p->ptr;
		break;
	case SOAP_TYPE_ns13__MapUriRequest:
		if (p->size < 0)
			delete (ns13__MapUriRequest*)p->ptr;
		else
			delete[] (ns13__MapUriRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns13__MapUriResponse:
		if (p->size < 0)
			delete (ns13__MapUriResponse*)p->ptr;
		else
			delete[] (ns13__MapUriResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns16__RouteRequest:
		if (p->size < 0)
			delete (ns16__RouteRequest*)p->ptr;
		else
			delete[] (ns16__RouteRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns16__RouteResponse:
		if (p->size < 0)
			delete (ns16__RouteResponse*)p->ptr;
		else
			delete[] (ns16__RouteResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns16__MajorRoutesRequest:
		if (p->size < 0)
			delete (ns16__MajorRoutesRequest*)p->ptr;
		else
			delete[] (ns16__MajorRoutesRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns16__MajorRoutesOptions:
		if (p->size < 0)
			delete (ns16__MajorRoutesOptions*)p->ptr;
		else
			delete[] (ns16__MajorRoutesOptions*)p->ptr;
		break;
	case SOAP_TYPE_ns16__MajorRoutesResponse:
		if (p->size < 0)
			delete (ns16__MajorRoutesResponse*)p->ptr;
		else
			delete[] (ns16__MajorRoutesResponse*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetVersionInfo:
		if (p->size < 0)
			delete (struct __ns1__GetVersionInfo*)p->ptr;
		else
			delete[] (struct __ns1__GetVersionInfo*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetCountryRegionInfo:
		if (p->size < 0)
			delete (struct __ns1__GetCountryRegionInfo*)p->ptr;
		else
			delete[] (struct __ns1__GetCountryRegionInfo*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetEntityTypes:
		if (p->size < 0)
			delete (struct __ns1__GetEntityTypes*)p->ptr;
		else
			delete[] (struct __ns1__GetEntityTypes*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetDataSourceInfo:
		if (p->size < 0)
			delete (struct __ns1__GetDataSourceInfo*)p->ptr;
		else
			delete[] (struct __ns1__GetDataSourceInfo*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetGreatCircleDistances:
		if (p->size < 0)
			delete (struct __ns1__GetGreatCircleDistances*)p->ptr;
		else
			delete[] (struct __ns1__GetGreatCircleDistances*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetClientToken:
		if (p->size < 0)
			delete (struct __ns1__GetClientToken*)p->ptr;
		else
			delete[] (struct __ns1__GetClientToken*)p->ptr;
		break;
	case SOAP_TYPE___ns10__Geocode:
		if (p->size < 0)
			delete (struct __ns10__Geocode*)p->ptr;
		else
			delete[] (struct __ns10__Geocode*)p->ptr;
		break;
	case SOAP_TYPE___ns10__ReverseGeocode:
		if (p->size < 0)
			delete (struct __ns10__ReverseGeocode*)p->ptr;
		else
			delete[] (struct __ns10__ReverseGeocode*)p->ptr;
		break;
	case SOAP_TYPE___ns13__GetImageryMetadata:
		if (p->size < 0)
			delete (struct __ns13__GetImageryMetadata*)p->ptr;
		else
			delete[] (struct __ns13__GetImageryMetadata*)p->ptr;
		break;
	case SOAP_TYPE___ns13__GetMapUri:
		if (p->size < 0)
			delete (struct __ns13__GetMapUri*)p->ptr;
		else
			delete[] (struct __ns13__GetMapUri*)p->ptr;
		break;
	case SOAP_TYPE___ns16__CalculateRoute:
		if (p->size < 0)
			delete (struct __ns16__CalculateRoute*)p->ptr;
		else
			delete[] (struct __ns16__CalculateRoute*)p->ptr;
		break;
	case SOAP_TYPE___ns16__CalculateRoutesFromMajorRoads:
		if (p->size < 0)
			delete (struct __ns16__CalculateRoutesFromMajorRoads*)p->ptr;
		else
			delete[] (struct __ns16__CalculateRoutesFromMajorRoads*)p->ptr;
		break;
	case SOAP_TYPE___ns6__Search:
		if (p->size < 0)
			delete (struct __ns6__Search*)p->ptr;
		else
			delete[] (struct __ns6__Search*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__byte);
	if (soap_out_xsd__byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_xsd__byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_xsd__byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_xsd__byte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{	short *p;
	p = soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__char(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__char);
	if (soap_out_ns5__char(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__char(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns5__char);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns5__char(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__char(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_ns5__char(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_ns5__char);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedByte);
	if (soap_out_xsd__unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_xsd__unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_xsd__unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_xsd__unsignedByte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedShort(struct soap *soap, unsigned short *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedShort
	*a = SOAP_DEFAULT_unsignedShort;
#else
	*a = (unsigned short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedShort(struct soap *soap, const unsigned short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedShort);
	if (soap_out_unsignedShort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedShort(struct soap *soap, const char *tag, int id, const unsigned short *a, const char *type)
{
	return soap_outunsignedShort(soap, tag, id, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_get_unsignedShort(struct soap *soap, unsigned short *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedShort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_in_unsignedShort(struct soap *soap, const char *tag, unsigned short *a, const char *type)
{	unsigned short *p;
	p = soap_inunsignedShort(soap, tag, a, type, SOAP_TYPE_unsignedShort);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{	ULONG64 *p;
	p = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns16__ItineraryWarningType(struct soap *soap, enum ns16__ItineraryWarningType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns16__ItineraryWarningType
	*a = SOAP_DEFAULT_ns16__ItineraryWarningType;
#else
	*a = (enum ns16__ItineraryWarningType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns16__ItineraryWarningType(struct soap *soap, const enum ns16__ItineraryWarningType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns16__ItineraryWarningType);
	if (soap_out_ns16__ItineraryWarningType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns16__ItineraryWarningType[] =
{	{ (long)ns16__ItineraryWarningType__Accident, "Accident" },
	{ (long)ns16__ItineraryWarningType__AdminDivisionChange, "AdminDivisionChange" },
	{ (long)ns16__ItineraryWarningType__BlockedRoad, "BlockedRoad" },
	{ (long)ns16__ItineraryWarningType__CheckTimetable, "CheckTimetable" },
	{ (long)ns16__ItineraryWarningType__Congestion, "Congestion" },
	{ (long)ns16__ItineraryWarningType__CountryChange, "CountryChange" },
	{ (long)ns16__ItineraryWarningType__DisabledVehicle, "DisabledVehicle" },
	{ (long)ns16__ItineraryWarningType__GateAccess, "GateAccess" },
	{ (long)ns16__ItineraryWarningType__GetOffTransit, "GetOffTransit" },
	{ (long)ns16__ItineraryWarningType__GetOnTransit, "GetOnTransit" },
	{ (long)ns16__ItineraryWarningType__IllegalUTurn, "IllegalUTurn" },
	{ (long)ns16__ItineraryWarningType__MassTransit, "MassTransit" },
	{ (long)ns16__ItineraryWarningType__Miscellaneous, "Miscellaneous" },
	{ (long)ns16__ItineraryWarningType__NoIncident, "NoIncident" },
	{ (long)ns16__ItineraryWarningType__None, "None" },
	{ (long)ns16__ItineraryWarningType__Other, "Other" },
	{ (long)ns16__ItineraryWarningType__OtherNews, "OtherNews" },
	{ (long)ns16__ItineraryWarningType__OtherTrafficIncidents, "OtherTrafficIncidents" },
	{ (long)ns16__ItineraryWarningType__PlannedEvent, "PlannedEvent" },
	{ (long)ns16__ItineraryWarningType__PrivateRoad, "PrivateRoad" },
	{ (long)ns16__ItineraryWarningType__RestrictedTurn, "RestrictedTurn" },
	{ (long)ns16__ItineraryWarningType__RoadClosures, "RoadClosures" },
	{ (long)ns16__ItineraryWarningType__RoadHazard, "RoadHazard" },
	{ (long)ns16__ItineraryWarningType__ScheduledConstruction, "ScheduledConstruction" },
	{ (long)ns16__ItineraryWarningType__SeasonalClosures, "SeasonalClosures" },
	{ (long)ns16__ItineraryWarningType__Tollbooth, "Tollbooth" },
	{ (long)ns16__ItineraryWarningType__TollRoad, "TollRoad" },
	{ (long)ns16__ItineraryWarningType__TrafficFlow, "TrafficFlow" },
	{ (long)ns16__ItineraryWarningType__UnpavedRoad, "UnpavedRoad" },
	{ (long)ns16__ItineraryWarningType__UnscheduledConstruction, "UnscheduledConstruction" },
	{ (long)ns16__ItineraryWarningType__Weather, "Weather" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns16__ItineraryWarningType2s(struct soap *soap, enum ns16__ItineraryWarningType n)
{	const char *s = soap_code_str(soap_codes_ns16__ItineraryWarningType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ItineraryWarningType(struct soap *soap, const char *tag, int id, const enum ns16__ItineraryWarningType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__ItineraryWarningType), type) || soap_send(soap, soap_ns16__ItineraryWarningType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns16__ItineraryWarningType * SOAP_FMAC4 soap_get_ns16__ItineraryWarningType(struct soap *soap, enum ns16__ItineraryWarningType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ItineraryWarningType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns16__ItineraryWarningType(struct soap *soap, const char *s, enum ns16__ItineraryWarningType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns16__ItineraryWarningType, s);
	if (map)
		*a = (enum ns16__ItineraryWarningType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 30)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns16__ItineraryWarningType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns16__ItineraryWarningType * SOAP_FMAC4 soap_in_ns16__ItineraryWarningType(struct soap *soap, const char *tag, enum ns16__ItineraryWarningType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns16__ItineraryWarningType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ItineraryWarningType, sizeof(enum ns16__ItineraryWarningType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns16__ItineraryWarningType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns16__ItineraryWarningType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__ItineraryWarningType, 0, sizeof(enum ns16__ItineraryWarningType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns16__ItineraryWarningSeverity(struct soap *soap, enum ns16__ItineraryWarningSeverity *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns16__ItineraryWarningSeverity
	*a = SOAP_DEFAULT_ns16__ItineraryWarningSeverity;
#else
	*a = (enum ns16__ItineraryWarningSeverity)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns16__ItineraryWarningSeverity(struct soap *soap, const enum ns16__ItineraryWarningSeverity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns16__ItineraryWarningSeverity);
	if (soap_out_ns16__ItineraryWarningSeverity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns16__ItineraryWarningSeverity[] =
{	{ (long)ns16__ItineraryWarningSeverity__None, "None" },
	{ (long)ns16__ItineraryWarningSeverity__LowImpact, "LowImpact" },
	{ (long)ns16__ItineraryWarningSeverity__Minor, "Minor" },
	{ (long)ns16__ItineraryWarningSeverity__Moderate, "Moderate" },
	{ (long)ns16__ItineraryWarningSeverity__Serious, "Serious" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns16__ItineraryWarningSeverity2s(struct soap *soap, enum ns16__ItineraryWarningSeverity n)
{	const char *s = soap_code_str(soap_codes_ns16__ItineraryWarningSeverity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ItineraryWarningSeverity(struct soap *soap, const char *tag, int id, const enum ns16__ItineraryWarningSeverity *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__ItineraryWarningSeverity), type) || soap_send(soap, soap_ns16__ItineraryWarningSeverity2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns16__ItineraryWarningSeverity * SOAP_FMAC4 soap_get_ns16__ItineraryWarningSeverity(struct soap *soap, enum ns16__ItineraryWarningSeverity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ItineraryWarningSeverity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns16__ItineraryWarningSeverity(struct soap *soap, const char *s, enum ns16__ItineraryWarningSeverity *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns16__ItineraryWarningSeverity, s);
	if (map)
		*a = (enum ns16__ItineraryWarningSeverity)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns16__ItineraryWarningSeverity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns16__ItineraryWarningSeverity * SOAP_FMAC4 soap_in_ns16__ItineraryWarningSeverity(struct soap *soap, const char *tag, enum ns16__ItineraryWarningSeverity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns16__ItineraryWarningSeverity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ItineraryWarningSeverity, sizeof(enum ns16__ItineraryWarningSeverity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns16__ItineraryWarningSeverity(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns16__ItineraryWarningSeverity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__ItineraryWarningSeverity, 0, sizeof(enum ns16__ItineraryWarningSeverity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns16__ManeuverType(struct soap *soap, enum ns16__ManeuverType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns16__ManeuverType
	*a = SOAP_DEFAULT_ns16__ManeuverType;
#else
	*a = (enum ns16__ManeuverType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns16__ManeuverType(struct soap *soap, const enum ns16__ManeuverType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns16__ManeuverType);
	if (soap_out_ns16__ManeuverType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns16__ManeuverType[] =
{	{ (long)ns16__ManeuverType__None, "None" },
	{ (long)ns16__ManeuverType__Unknown, "Unknown" },
	{ (long)ns16__ManeuverType__DepartStart, "DepartStart" },
	{ (long)ns16__ManeuverType__DepartIntermediateStop, "DepartIntermediateStop" },
	{ (long)ns16__ManeuverType__DepartIntermediateStopReturning, "DepartIntermediateStopReturning" },
	{ (long)ns16__ManeuverType__ArriveFinish, "ArriveFinish" },
	{ (long)ns16__ManeuverType__ArriveIntermediateStop, "ArriveIntermediateStop" },
	{ (long)ns16__ManeuverType__TurnLeft, "TurnLeft" },
	{ (long)ns16__ManeuverType__TurnRight, "TurnRight" },
	{ (long)ns16__ManeuverType__TurnBack, "TurnBack" },
	{ (long)ns16__ManeuverType__UTurn, "UTurn" },
	{ (long)ns16__ManeuverType__TurnToStayLeft, "TurnToStayLeft" },
	{ (long)ns16__ManeuverType__TurnToStayRight, "TurnToStayRight" },
	{ (long)ns16__ManeuverType__BearLeft, "BearLeft" },
	{ (long)ns16__ManeuverType__BearRight, "BearRight" },
	{ (long)ns16__ManeuverType__KeepToStayLeft, "KeepToStayLeft" },
	{ (long)ns16__ManeuverType__KeepToStayRight, "KeepToStayRight" },
	{ (long)ns16__ManeuverType__KeepToStayStraight, "KeepToStayStraight" },
	{ (long)ns16__ManeuverType__KeepLeft, "KeepLeft" },
	{ (long)ns16__ManeuverType__KeepRight, "KeepRight" },
	{ (long)ns16__ManeuverType__KeepStraight, "KeepStraight" },
	{ (long)ns16__ManeuverType__Take, "Take" },
	{ (long)ns16__ManeuverType__TakeRampLeft, "TakeRampLeft" },
	{ (long)ns16__ManeuverType__TakeRampRight, "TakeRampRight" },
	{ (long)ns16__ManeuverType__TakeRampStraight, "TakeRampStraight" },
	{ (long)ns16__ManeuverType__KeepOnrampLeft, "KeepOnrampLeft" },
	{ (long)ns16__ManeuverType__KeepOnrampRight, "KeepOnrampRight" },
	{ (long)ns16__ManeuverType__KeepOnrampStraight, "KeepOnrampStraight" },
	{ (long)ns16__ManeuverType__Merge, "Merge" },
	{ (long)ns16__ManeuverType__Continue, "Continue" },
	{ (long)ns16__ManeuverType__RoadNameChange, "RoadNameChange" },
	{ (long)ns16__ManeuverType__EnterRoundabout, "EnterRoundabout" },
	{ (long)ns16__ManeuverType__ExitRoundabout, "ExitRoundabout" },
	{ (long)ns16__ManeuverType__TurnRightThenTurnRight, "TurnRightThenTurnRight" },
	{ (long)ns16__ManeuverType__TurnRightThenTurnLeft, "TurnRightThenTurnLeft" },
	{ (long)ns16__ManeuverType__TurnRightThenBearRight, "TurnRightThenBearRight" },
	{ (long)ns16__ManeuverType__TurnRightThenBearLeft, "TurnRightThenBearLeft" },
	{ (long)ns16__ManeuverType__TurnLeftThenTurnLeft, "TurnLeftThenTurnLeft" },
	{ (long)ns16__ManeuverType__TurnLeftThenTurnRight, "TurnLeftThenTurnRight" },
	{ (long)ns16__ManeuverType__TurnLeftThenBearLeft, "TurnLeftThenBearLeft" },
	{ (long)ns16__ManeuverType__TurnLeftThenBearRight, "TurnLeftThenBearRight" },
	{ (long)ns16__ManeuverType__BearRightThenTurnRight, "BearRightThenTurnRight" },
	{ (long)ns16__ManeuverType__BearRightThenTurnLeft, "BearRightThenTurnLeft" },
	{ (long)ns16__ManeuverType__BearRightThenBearRight, "BearRightThenBearRight" },
	{ (long)ns16__ManeuverType__BearRightThenBearLeft, "BearRightThenBearLeft" },
	{ (long)ns16__ManeuverType__BearLeftThenTurnLeft, "BearLeftThenTurnLeft" },
	{ (long)ns16__ManeuverType__BearLeftThenTurnRight, "BearLeftThenTurnRight" },
	{ (long)ns16__ManeuverType__BearLeftThenBearRight, "BearLeftThenBearRight" },
	{ (long)ns16__ManeuverType__BearLeftThenBearLeft, "BearLeftThenBearLeft" },
	{ (long)ns16__ManeuverType__RampThenHighwayRight, "RampThenHighwayRight" },
	{ (long)ns16__ManeuverType__RampThenHighwayLeft, "RampThenHighwayLeft" },
	{ (long)ns16__ManeuverType__RampToHighwayStraight, "RampToHighwayStraight" },
	{ (long)ns16__ManeuverType__EnterThenExitRoundabout, "EnterThenExitRoundabout" },
	{ (long)ns16__ManeuverType__BearThenMerge, "BearThenMerge" },
	{ (long)ns16__ManeuverType__TurnThenMerge, "TurnThenMerge" },
	{ (long)ns16__ManeuverType__BearThenKeep, "BearThenKeep" },
	{ (long)ns16__ManeuverType__Transfer, "Transfer" },
	{ (long)ns16__ManeuverType__Wait, "Wait" },
	{ (long)ns16__ManeuverType__TakeTransit, "TakeTransit" },
	{ (long)ns16__ManeuverType__Walk, "Walk" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns16__ManeuverType2s(struct soap *soap, enum ns16__ManeuverType n)
{	const char *s = soap_code_str(soap_codes_ns16__ManeuverType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ManeuverType(struct soap *soap, const char *tag, int id, const enum ns16__ManeuverType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__ManeuverType), type) || soap_send(soap, soap_ns16__ManeuverType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns16__ManeuverType * SOAP_FMAC4 soap_get_ns16__ManeuverType(struct soap *soap, enum ns16__ManeuverType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ManeuverType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns16__ManeuverType(struct soap *soap, const char *s, enum ns16__ManeuverType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns16__ManeuverType, s);
	if (map)
		*a = (enum ns16__ManeuverType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 59)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns16__ManeuverType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns16__ManeuverType * SOAP_FMAC4 soap_in_ns16__ManeuverType(struct soap *soap, const char *tag, enum ns16__ManeuverType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns16__ManeuverType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ManeuverType, sizeof(enum ns16__ManeuverType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns16__ManeuverType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns16__ManeuverType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__ManeuverType, 0, sizeof(enum ns16__ManeuverType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns16__ItineraryItemHintType(struct soap *soap, enum ns16__ItineraryItemHintType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns16__ItineraryItemHintType
	*a = SOAP_DEFAULT_ns16__ItineraryItemHintType;
#else
	*a = (enum ns16__ItineraryItemHintType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns16__ItineraryItemHintType(struct soap *soap, const enum ns16__ItineraryItemHintType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns16__ItineraryItemHintType);
	if (soap_out_ns16__ItineraryItemHintType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns16__ItineraryItemHintType[] =
{	{ (long)ns16__ItineraryItemHintType__PreviousIntersection, "PreviousIntersection" },
	{ (long)ns16__ItineraryItemHintType__NextIntersection, "NextIntersection" },
	{ (long)ns16__ItineraryItemHintType__Landmark, "Landmark" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns16__ItineraryItemHintType2s(struct soap *soap, enum ns16__ItineraryItemHintType n)
{	const char *s = soap_code_str(soap_codes_ns16__ItineraryItemHintType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ItineraryItemHintType(struct soap *soap, const char *tag, int id, const enum ns16__ItineraryItemHintType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__ItineraryItemHintType), type) || soap_send(soap, soap_ns16__ItineraryItemHintType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns16__ItineraryItemHintType * SOAP_FMAC4 soap_get_ns16__ItineraryItemHintType(struct soap *soap, enum ns16__ItineraryItemHintType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ItineraryItemHintType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns16__ItineraryItemHintType(struct soap *soap, const char *s, enum ns16__ItineraryItemHintType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns16__ItineraryItemHintType, s);
	if (map)
		*a = (enum ns16__ItineraryItemHintType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns16__ItineraryItemHintType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns16__ItineraryItemHintType * SOAP_FMAC4 soap_in_ns16__ItineraryItemHintType(struct soap *soap, const char *tag, enum ns16__ItineraryItemHintType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns16__ItineraryItemHintType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ItineraryItemHintType, sizeof(enum ns16__ItineraryItemHintType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns16__ItineraryItemHintType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns16__ItineraryItemHintType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__ItineraryItemHintType, 0, sizeof(enum ns16__ItineraryItemHintType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns16__TrafficUsage(struct soap *soap, enum ns16__TrafficUsage *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns16__TrafficUsage
	*a = SOAP_DEFAULT_ns16__TrafficUsage;
#else
	*a = (enum ns16__TrafficUsage)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns16__TrafficUsage(struct soap *soap, const enum ns16__TrafficUsage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns16__TrafficUsage);
	if (soap_out_ns16__TrafficUsage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns16__TrafficUsage[] =
{	{ (long)ns16__TrafficUsage__None, "None" },
	{ (long)ns16__TrafficUsage__TrafficBasedTime, "TrafficBasedTime" },
	{ (long)ns16__TrafficUsage__TrafficBasedRouteAndTime, "TrafficBasedRouteAndTime" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns16__TrafficUsage2s(struct soap *soap, enum ns16__TrafficUsage n)
{	const char *s = soap_code_str(soap_codes_ns16__TrafficUsage, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__TrafficUsage(struct soap *soap, const char *tag, int id, const enum ns16__TrafficUsage *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__TrafficUsage), type) || soap_send(soap, soap_ns16__TrafficUsage2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns16__TrafficUsage * SOAP_FMAC4 soap_get_ns16__TrafficUsage(struct soap *soap, enum ns16__TrafficUsage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__TrafficUsage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns16__TrafficUsage(struct soap *soap, const char *s, enum ns16__TrafficUsage *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns16__TrafficUsage, s);
	if (map)
		*a = (enum ns16__TrafficUsage)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns16__TrafficUsage)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns16__TrafficUsage * SOAP_FMAC4 soap_in_ns16__TrafficUsage(struct soap *soap, const char *tag, enum ns16__TrafficUsage *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns16__TrafficUsage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__TrafficUsage, sizeof(enum ns16__TrafficUsage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns16__TrafficUsage(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns16__TrafficUsage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__TrafficUsage, 0, sizeof(enum ns16__TrafficUsage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns16__RoutePathType(struct soap *soap, enum ns16__RoutePathType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns16__RoutePathType
	*a = SOAP_DEFAULT_ns16__RoutePathType;
#else
	*a = (enum ns16__RoutePathType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns16__RoutePathType(struct soap *soap, const enum ns16__RoutePathType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns16__RoutePathType);
	if (soap_out_ns16__RoutePathType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns16__RoutePathType[] =
{	{ (long)ns16__RoutePathType__None, "None" },
	{ (long)ns16__RoutePathType__Points, "Points" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns16__RoutePathType2s(struct soap *soap, enum ns16__RoutePathType n)
{	const char *s = soap_code_str(soap_codes_ns16__RoutePathType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__RoutePathType(struct soap *soap, const char *tag, int id, const enum ns16__RoutePathType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__RoutePathType), type) || soap_send(soap, soap_ns16__RoutePathType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns16__RoutePathType * SOAP_FMAC4 soap_get_ns16__RoutePathType(struct soap *soap, enum ns16__RoutePathType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__RoutePathType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns16__RoutePathType(struct soap *soap, const char *s, enum ns16__RoutePathType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns16__RoutePathType, s);
	if (map)
		*a = (enum ns16__RoutePathType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns16__RoutePathType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns16__RoutePathType * SOAP_FMAC4 soap_in_ns16__RoutePathType(struct soap *soap, const char *tag, enum ns16__RoutePathType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns16__RoutePathType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__RoutePathType, sizeof(enum ns16__RoutePathType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns16__RoutePathType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns16__RoutePathType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__RoutePathType, 0, sizeof(enum ns16__RoutePathType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns16__RouteOptimization(struct soap *soap, enum ns16__RouteOptimization *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns16__RouteOptimization
	*a = SOAP_DEFAULT_ns16__RouteOptimization;
#else
	*a = (enum ns16__RouteOptimization)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns16__RouteOptimization(struct soap *soap, const enum ns16__RouteOptimization *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns16__RouteOptimization);
	if (soap_out_ns16__RouteOptimization(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns16__RouteOptimization[] =
{	{ (long)ns16__RouteOptimization__MinimizeTime, "MinimizeTime" },
	{ (long)ns16__RouteOptimization__MinimizeDistance, "MinimizeDistance" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns16__RouteOptimization2s(struct soap *soap, enum ns16__RouteOptimization n)
{	const char *s = soap_code_str(soap_codes_ns16__RouteOptimization, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__RouteOptimization(struct soap *soap, const char *tag, int id, const enum ns16__RouteOptimization *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__RouteOptimization), type) || soap_send(soap, soap_ns16__RouteOptimization2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns16__RouteOptimization * SOAP_FMAC4 soap_get_ns16__RouteOptimization(struct soap *soap, enum ns16__RouteOptimization *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__RouteOptimization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns16__RouteOptimization(struct soap *soap, const char *s, enum ns16__RouteOptimization *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns16__RouteOptimization, s);
	if (map)
		*a = (enum ns16__RouteOptimization)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns16__RouteOptimization)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns16__RouteOptimization * SOAP_FMAC4 soap_in_ns16__RouteOptimization(struct soap *soap, const char *tag, enum ns16__RouteOptimization *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns16__RouteOptimization *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__RouteOptimization, sizeof(enum ns16__RouteOptimization), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns16__RouteOptimization(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns16__RouteOptimization *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__RouteOptimization, 0, sizeof(enum ns16__RouteOptimization), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns16__TravelMode(struct soap *soap, enum ns16__TravelMode *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns16__TravelMode
	*a = SOAP_DEFAULT_ns16__TravelMode;
#else
	*a = (enum ns16__TravelMode)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns16__TravelMode(struct soap *soap, const enum ns16__TravelMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns16__TravelMode);
	if (soap_out_ns16__TravelMode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns16__TravelMode[] =
{	{ (long)ns16__TravelMode__Driving, "Driving" },
	{ (long)ns16__TravelMode__Walking, "Walking" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns16__TravelMode2s(struct soap *soap, enum ns16__TravelMode n)
{	const char *s = soap_code_str(soap_codes_ns16__TravelMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__TravelMode(struct soap *soap, const char *tag, int id, const enum ns16__TravelMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__TravelMode), type) || soap_send(soap, soap_ns16__TravelMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns16__TravelMode * SOAP_FMAC4 soap_get_ns16__TravelMode(struct soap *soap, enum ns16__TravelMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__TravelMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns16__TravelMode(struct soap *soap, const char *s, enum ns16__TravelMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns16__TravelMode, s);
	if (map)
		*a = (enum ns16__TravelMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns16__TravelMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns16__TravelMode * SOAP_FMAC4 soap_in_ns16__TravelMode(struct soap *soap, const char *tag, enum ns16__TravelMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns16__TravelMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__TravelMode, sizeof(enum ns16__TravelMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns16__TravelMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns16__TravelMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__TravelMode, 0, sizeof(enum ns16__TravelMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__SortOrder(struct soap *soap, enum ns6__SortOrder *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__SortOrder
	*a = SOAP_DEFAULT_ns6__SortOrder;
#else
	*a = (enum ns6__SortOrder)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__SortOrder(struct soap *soap, const enum ns6__SortOrder *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__SortOrder);
	if (soap_out_ns6__SortOrder(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns6__SortOrder[] =
{	{ (long)ns6__SortOrder__Relevance, "Relevance" },
	{ (long)ns6__SortOrder__Distance, "Distance" },
	{ (long)ns6__SortOrder__Rating, "Rating" },
	{ (long)ns6__SortOrder__Popularity, "Popularity" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__SortOrder2s(struct soap *soap, enum ns6__SortOrder n)
{	const char *s = soap_code_str(soap_codes_ns6__SortOrder, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SortOrder(struct soap *soap, const char *tag, int id, const enum ns6__SortOrder *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SortOrder), type) || soap_send(soap, soap_ns6__SortOrder2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns6__SortOrder * SOAP_FMAC4 soap_get_ns6__SortOrder(struct soap *soap, enum ns6__SortOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SortOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__SortOrder(struct soap *soap, const char *s, enum ns6__SortOrder *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns6__SortOrder, s);
	if (map)
		*a = (enum ns6__SortOrder)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__SortOrder)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__SortOrder * SOAP_FMAC4 soap_in_ns6__SortOrder(struct soap *soap, const char *tag, enum ns6__SortOrder *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__SortOrder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SortOrder, sizeof(enum ns6__SortOrder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__SortOrder(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__SortOrder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SortOrder, 0, sizeof(enum ns6__SortOrder), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ListingType(struct soap *soap, enum ns6__ListingType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__ListingType
	*a = SOAP_DEFAULT_ns6__ListingType;
#else
	*a = (enum ns6__ListingType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ListingType(struct soap *soap, const enum ns6__ListingType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__ListingType);
	if (soap_out_ns6__ListingType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns6__ListingType[] =
{	{ (long)ns6__ListingType__Business, "Business" },
	{ (long)ns6__ListingType__CommunityContent, "CommunityContent" },
	{ (long)ns6__ListingType__Person, "Person" },
	{ (long)ns6__ListingType__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__ListingType2s(struct soap *soap, enum ns6__ListingType n)
{	const char *s = soap_code_str(soap_codes_ns6__ListingType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ListingType(struct soap *soap, const char *tag, int id, const enum ns6__ListingType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ListingType), type) || soap_send(soap, soap_ns6__ListingType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns6__ListingType * SOAP_FMAC4 soap_get_ns6__ListingType(struct soap *soap, enum ns6__ListingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ListingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__ListingType(struct soap *soap, const char *s, enum ns6__ListingType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns6__ListingType, s);
	if (map)
		*a = (enum ns6__ListingType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__ListingType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__ListingType * SOAP_FMAC4 soap_in_ns6__ListingType(struct soap *soap, const char *tag, enum ns6__ListingType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__ListingType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ListingType, sizeof(enum ns6__ListingType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__ListingType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__ListingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ListingType, 0, sizeof(enum ns6__ListingType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ImageType(struct soap *soap, enum ns4__ImageType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__ImageType
	*a = SOAP_DEFAULT_ns4__ImageType;
#else
	*a = (enum ns4__ImageType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ImageType(struct soap *soap, const enum ns4__ImageType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ImageType);
	if (soap_out_ns4__ImageType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns4__ImageType[] =
{	{ (long)ns4__ImageType__Default, "Default" },
	{ (long)ns4__ImageType__Png, "Png" },
	{ (long)ns4__ImageType__Jpeg, "Jpeg" },
	{ (long)ns4__ImageType__Gif, "Gif" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__ImageType2s(struct soap *soap, enum ns4__ImageType n)
{	const char *s = soap_code_str(soap_codes_ns4__ImageType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ImageType(struct soap *soap, const char *tag, int id, const enum ns4__ImageType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ImageType), type) || soap_send(soap, soap_ns4__ImageType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns4__ImageType * SOAP_FMAC4 soap_get_ns4__ImageType(struct soap *soap, enum ns4__ImageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ImageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__ImageType(struct soap *soap, const char *s, enum ns4__ImageType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns4__ImageType, s);
	if (map)
		*a = (enum ns4__ImageType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__ImageType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__ImageType * SOAP_FMAC4 soap_in_ns4__ImageType(struct soap *soap, const char *tag, enum ns4__ImageType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__ImageType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ImageType, sizeof(enum ns4__ImageType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__ImageType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__ImageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ImageType, 0, sizeof(enum ns4__ImageType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__MapStyle(struct soap *soap, enum ns4__MapStyle *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__MapStyle
	*a = SOAP_DEFAULT_ns4__MapStyle;
#else
	*a = (enum ns4__MapStyle)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__MapStyle(struct soap *soap, const enum ns4__MapStyle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__MapStyle);
	if (soap_out_ns4__MapStyle(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns4__MapStyle[] =
{	{ (long)ns4__MapStyle__Road, "Road" },
	{ (long)ns4__MapStyle__Aerial, "Aerial" },
	{ (long)ns4__MapStyle__AerialWithLabels, "AerialWithLabels" },
	{ (long)ns4__MapStyle__Birdseye, "Birdseye" },
	{ (long)ns4__MapStyle__BirdseyeWithLabels, "BirdseyeWithLabels" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__MapStyle2s(struct soap *soap, enum ns4__MapStyle n)
{	const char *s = soap_code_str(soap_codes_ns4__MapStyle, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__MapStyle(struct soap *soap, const char *tag, int id, const enum ns4__MapStyle *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__MapStyle), type) || soap_send(soap, soap_ns4__MapStyle2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns4__MapStyle * SOAP_FMAC4 soap_get_ns4__MapStyle(struct soap *soap, enum ns4__MapStyle *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__MapStyle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__MapStyle(struct soap *soap, const char *s, enum ns4__MapStyle *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns4__MapStyle, s);
	if (map)
		*a = (enum ns4__MapStyle)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__MapStyle)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__MapStyle * SOAP_FMAC4 soap_in_ns4__MapStyle(struct soap *soap, const char *tag, enum ns4__MapStyle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__MapStyle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__MapStyle, sizeof(enum ns4__MapStyle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__MapStyle(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__MapStyle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__MapStyle, 0, sizeof(enum ns4__MapStyle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UriScheme(struct soap *soap, enum ns4__UriScheme *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__UriScheme
	*a = SOAP_DEFAULT_ns4__UriScheme;
#else
	*a = (enum ns4__UriScheme)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UriScheme(struct soap *soap, const enum ns4__UriScheme *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__UriScheme);
	if (soap_out_ns4__UriScheme(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns4__UriScheme[] =
{	{ (long)ns4__UriScheme__Http, "Http" },
	{ (long)ns4__UriScheme__Https, "Https" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__UriScheme2s(struct soap *soap, enum ns4__UriScheme n)
{	const char *s = soap_code_str(soap_codes_ns4__UriScheme, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UriScheme(struct soap *soap, const char *tag, int id, const enum ns4__UriScheme *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UriScheme), type) || soap_send(soap, soap_ns4__UriScheme2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns4__UriScheme * SOAP_FMAC4 soap_get_ns4__UriScheme(struct soap *soap, enum ns4__UriScheme *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UriScheme(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__UriScheme(struct soap *soap, const char *s, enum ns4__UriScheme *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns4__UriScheme, s);
	if (map)
		*a = (enum ns4__UriScheme)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__UriScheme)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__UriScheme * SOAP_FMAC4 soap_in_ns4__UriScheme(struct soap *soap, const char *tag, enum ns4__UriScheme *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__UriScheme *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UriScheme, sizeof(enum ns4__UriScheme), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__UriScheme(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__UriScheme *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UriScheme, 0, sizeof(enum ns4__UriScheme), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ResponseStatusCode(struct soap *soap, enum ns4__ResponseStatusCode *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__ResponseStatusCode
	*a = SOAP_DEFAULT_ns4__ResponseStatusCode;
#else
	*a = (enum ns4__ResponseStatusCode)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ResponseStatusCode(struct soap *soap, const enum ns4__ResponseStatusCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ResponseStatusCode);
	if (soap_out_ns4__ResponseStatusCode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns4__ResponseStatusCode[] =
{	{ (long)ns4__ResponseStatusCode__Success, "Success" },
	{ (long)ns4__ResponseStatusCode__BadRequest, "BadRequest" },
	{ (long)ns4__ResponseStatusCode__ServerError, "ServerError" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__ResponseStatusCode2s(struct soap *soap, enum ns4__ResponseStatusCode n)
{	const char *s = soap_code_str(soap_codes_ns4__ResponseStatusCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ResponseStatusCode(struct soap *soap, const char *tag, int id, const enum ns4__ResponseStatusCode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ResponseStatusCode), type) || soap_send(soap, soap_ns4__ResponseStatusCode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns4__ResponseStatusCode * SOAP_FMAC4 soap_get_ns4__ResponseStatusCode(struct soap *soap, enum ns4__ResponseStatusCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ResponseStatusCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__ResponseStatusCode(struct soap *soap, const char *s, enum ns4__ResponseStatusCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns4__ResponseStatusCode, s);
	if (map)
		*a = (enum ns4__ResponseStatusCode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__ResponseStatusCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__ResponseStatusCode * SOAP_FMAC4 soap_in_ns4__ResponseStatusCode(struct soap *soap, const char *tag, enum ns4__ResponseStatusCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__ResponseStatusCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ResponseStatusCode, sizeof(enum ns4__ResponseStatusCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__ResponseStatusCode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__ResponseStatusCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ResponseStatusCode, 0, sizeof(enum ns4__ResponseStatusCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__AuthenticationResultCode(struct soap *soap, enum ns4__AuthenticationResultCode *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__AuthenticationResultCode
	*a = SOAP_DEFAULT_ns4__AuthenticationResultCode;
#else
	*a = (enum ns4__AuthenticationResultCode)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__AuthenticationResultCode(struct soap *soap, const enum ns4__AuthenticationResultCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__AuthenticationResultCode);
	if (soap_out_ns4__AuthenticationResultCode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns4__AuthenticationResultCode[] =
{	{ (long)ns4__AuthenticationResultCode__None, "None" },
	{ (long)ns4__AuthenticationResultCode__NoCredentials, "NoCredentials" },
	{ (long)ns4__AuthenticationResultCode__ValidCredentials, "ValidCredentials" },
	{ (long)ns4__AuthenticationResultCode__InvalidCredentials, "InvalidCredentials" },
	{ (long)ns4__AuthenticationResultCode__CredentialsExpired, "CredentialsExpired" },
	{ (long)ns4__AuthenticationResultCode__NotAuthorized, "NotAuthorized" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__AuthenticationResultCode2s(struct soap *soap, enum ns4__AuthenticationResultCode n)
{	const char *s = soap_code_str(soap_codes_ns4__AuthenticationResultCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__AuthenticationResultCode(struct soap *soap, const char *tag, int id, const enum ns4__AuthenticationResultCode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__AuthenticationResultCode), type) || soap_send(soap, soap_ns4__AuthenticationResultCode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns4__AuthenticationResultCode * SOAP_FMAC4 soap_get_ns4__AuthenticationResultCode(struct soap *soap, enum ns4__AuthenticationResultCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__AuthenticationResultCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__AuthenticationResultCode(struct soap *soap, const char *s, enum ns4__AuthenticationResultCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns4__AuthenticationResultCode, s);
	if (map)
		*a = (enum ns4__AuthenticationResultCode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__AuthenticationResultCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__AuthenticationResultCode * SOAP_FMAC4 soap_in_ns4__AuthenticationResultCode(struct soap *soap, const char *tag, enum ns4__AuthenticationResultCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__AuthenticationResultCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__AuthenticationResultCode, sizeof(enum ns4__AuthenticationResultCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__AuthenticationResultCode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__AuthenticationResultCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__AuthenticationResultCode, 0, sizeof(enum ns4__AuthenticationResultCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__LogicalOperator(struct soap *soap, enum ns4__LogicalOperator *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__LogicalOperator
	*a = SOAP_DEFAULT_ns4__LogicalOperator;
#else
	*a = (enum ns4__LogicalOperator)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__LogicalOperator(struct soap *soap, const enum ns4__LogicalOperator *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__LogicalOperator);
	if (soap_out_ns4__LogicalOperator(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns4__LogicalOperator[] =
{	{ (long)ns4__LogicalOperator__And, "And" },
	{ (long)ns4__LogicalOperator__Or, "Or" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__LogicalOperator2s(struct soap *soap, enum ns4__LogicalOperator n)
{	const char *s = soap_code_str(soap_codes_ns4__LogicalOperator, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__LogicalOperator(struct soap *soap, const char *tag, int id, const enum ns4__LogicalOperator *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__LogicalOperator), type) || soap_send(soap, soap_ns4__LogicalOperator2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns4__LogicalOperator * SOAP_FMAC4 soap_get_ns4__LogicalOperator(struct soap *soap, enum ns4__LogicalOperator *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__LogicalOperator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__LogicalOperator(struct soap *soap, const char *s, enum ns4__LogicalOperator *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns4__LogicalOperator, s);
	if (map)
		*a = (enum ns4__LogicalOperator)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__LogicalOperator)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__LogicalOperator * SOAP_FMAC4 soap_in_ns4__LogicalOperator(struct soap *soap, const char *tag, enum ns4__LogicalOperator *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__LogicalOperator *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__LogicalOperator, sizeof(enum ns4__LogicalOperator), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__LogicalOperator(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__LogicalOperator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__LogicalOperator, 0, sizeof(enum ns4__LogicalOperator), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__CompareOperator(struct soap *soap, enum ns4__CompareOperator *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__CompareOperator
	*a = SOAP_DEFAULT_ns4__CompareOperator;
#else
	*a = (enum ns4__CompareOperator)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__CompareOperator(struct soap *soap, const enum ns4__CompareOperator *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__CompareOperator);
	if (soap_out_ns4__CompareOperator(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns4__CompareOperator[] =
{	{ (long)ns4__CompareOperator__Equals, "Equals" },
	{ (long)ns4__CompareOperator__GreaterThan, "GreaterThan" },
	{ (long)ns4__CompareOperator__GreaterThanOrEquals, "GreaterThanOrEquals" },
	{ (long)ns4__CompareOperator__LessThan, "LessThan" },
	{ (long)ns4__CompareOperator__LessThanOrEquals, "LessThanOrEquals" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__CompareOperator2s(struct soap *soap, enum ns4__CompareOperator n)
{	const char *s = soap_code_str(soap_codes_ns4__CompareOperator, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__CompareOperator(struct soap *soap, const char *tag, int id, const enum ns4__CompareOperator *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__CompareOperator), type) || soap_send(soap, soap_ns4__CompareOperator2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns4__CompareOperator * SOAP_FMAC4 soap_get_ns4__CompareOperator(struct soap *soap, enum ns4__CompareOperator *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__CompareOperator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__CompareOperator(struct soap *soap, const char *s, enum ns4__CompareOperator *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns4__CompareOperator, s);
	if (map)
		*a = (enum ns4__CompareOperator)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__CompareOperator)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__CompareOperator * SOAP_FMAC4 soap_in_ns4__CompareOperator(struct soap *soap, const char *tag, enum ns4__CompareOperator *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__CompareOperator *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__CompareOperator, sizeof(enum ns4__CompareOperator), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__CompareOperator(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__CompareOperator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__CompareOperator, 0, sizeof(enum ns4__CompareOperator), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__DistanceUnit(struct soap *soap, enum ns4__DistanceUnit *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__DistanceUnit
	*a = SOAP_DEFAULT_ns4__DistanceUnit;
#else
	*a = (enum ns4__DistanceUnit)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__DistanceUnit(struct soap *soap, const enum ns4__DistanceUnit *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__DistanceUnit);
	if (soap_out_ns4__DistanceUnit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns4__DistanceUnit[] =
{	{ (long)ns4__DistanceUnit__Kilometer, "Kilometer" },
	{ (long)ns4__DistanceUnit__Mile, "Mile" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__DistanceUnit2s(struct soap *soap, enum ns4__DistanceUnit n)
{	const char *s = soap_code_str(soap_codes_ns4__DistanceUnit, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__DistanceUnit(struct soap *soap, const char *tag, int id, const enum ns4__DistanceUnit *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__DistanceUnit), type) || soap_send(soap, soap_ns4__DistanceUnit2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns4__DistanceUnit * SOAP_FMAC4 soap_get_ns4__DistanceUnit(struct soap *soap, enum ns4__DistanceUnit *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__DistanceUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__DistanceUnit(struct soap *soap, const char *s, enum ns4__DistanceUnit *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns4__DistanceUnit, s);
	if (map)
		*a = (enum ns4__DistanceUnit)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__DistanceUnit)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__DistanceUnit * SOAP_FMAC4 soap_in_ns4__DistanceUnit(struct soap *soap, const char *tag, enum ns4__DistanceUnit *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__DistanceUnit *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DistanceUnit, sizeof(enum ns4__DistanceUnit), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__DistanceUnit(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__DistanceUnit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DistanceUnit, 0, sizeof(enum ns4__DistanceUnit), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__DeviceType(struct soap *soap, enum ns4__DeviceType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__DeviceType
	*a = SOAP_DEFAULT_ns4__DeviceType;
#else
	*a = (enum ns4__DeviceType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__DeviceType(struct soap *soap, const enum ns4__DeviceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__DeviceType);
	if (soap_out_ns4__DeviceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns4__DeviceType[] =
{	{ (long)ns4__DeviceType__Desktop, "Desktop" },
	{ (long)ns4__DeviceType__Mobile, "Mobile" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__DeviceType2s(struct soap *soap, enum ns4__DeviceType n)
{	const char *s = soap_code_str(soap_codes_ns4__DeviceType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__DeviceType(struct soap *soap, const char *tag, int id, const enum ns4__DeviceType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__DeviceType), type) || soap_send(soap, soap_ns4__DeviceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns4__DeviceType * SOAP_FMAC4 soap_get_ns4__DeviceType(struct soap *soap, enum ns4__DeviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__DeviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__DeviceType(struct soap *soap, const char *s, enum ns4__DeviceType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns4__DeviceType, s);
	if (map)
		*a = (enum ns4__DeviceType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__DeviceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__DeviceType * SOAP_FMAC4 soap_in_ns4__DeviceType(struct soap *soap, const char *tag, enum ns4__DeviceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__DeviceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DeviceType, sizeof(enum ns4__DeviceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__DeviceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__DeviceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DeviceType, 0, sizeof(enum ns4__DeviceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__Confidence(struct soap *soap, enum ns4__Confidence *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__Confidence
	*a = SOAP_DEFAULT_ns4__Confidence;
#else
	*a = (enum ns4__Confidence)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__Confidence(struct soap *soap, const enum ns4__Confidence *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__Confidence);
	if (soap_out_ns4__Confidence(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns4__Confidence[] =
{	{ (long)ns4__Confidence__High, "High" },
	{ (long)ns4__Confidence__Medium, "Medium" },
	{ (long)ns4__Confidence__Low, "Low" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__Confidence2s(struct soap *soap, enum ns4__Confidence n)
{	const char *s = soap_code_str(soap_codes_ns4__Confidence, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Confidence(struct soap *soap, const char *tag, int id, const enum ns4__Confidence *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Confidence), type) || soap_send(soap, soap_ns4__Confidence2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns4__Confidence * SOAP_FMAC4 soap_get_ns4__Confidence(struct soap *soap, enum ns4__Confidence *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Confidence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__Confidence(struct soap *soap, const char *s, enum ns4__Confidence *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns4__Confidence, s);
	if (map)
		*a = (enum ns4__Confidence)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__Confidence)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__Confidence * SOAP_FMAC4 soap_in_ns4__Confidence(struct soap *soap, const char *tag, enum ns4__Confidence *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__Confidence *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Confidence, sizeof(enum ns4__Confidence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__Confidence(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__Confidence *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Confidence, 0, sizeof(enum ns4__Confidence), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DistanceUnit(struct soap *soap, enum ns1__DistanceUnit *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__DistanceUnit
	*a = SOAP_DEFAULT_ns1__DistanceUnit;
#else
	*a = (enum ns1__DistanceUnit)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DistanceUnit(struct soap *soap, const enum ns1__DistanceUnit *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DistanceUnit);
	if (soap_out_ns1__DistanceUnit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__DistanceUnit[] =
{	{ (long)ns1__DistanceUnit__Kilometer, "Kilometer" },
	{ (long)ns1__DistanceUnit__Mile, "Mile" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__DistanceUnit2s(struct soap *soap, enum ns1__DistanceUnit n)
{	const char *s = soap_code_str(soap_codes_ns1__DistanceUnit, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DistanceUnit(struct soap *soap, const char *tag, int id, const enum ns1__DistanceUnit *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DistanceUnit), type) || soap_send(soap, soap_ns1__DistanceUnit2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__DistanceUnit * SOAP_FMAC4 soap_get_ns1__DistanceUnit(struct soap *soap, enum ns1__DistanceUnit *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DistanceUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__DistanceUnit(struct soap *soap, const char *s, enum ns1__DistanceUnit *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__DistanceUnit, s);
	if (map)
		*a = (enum ns1__DistanceUnit)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__DistanceUnit)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DistanceUnit * SOAP_FMAC4 soap_in_ns1__DistanceUnit(struct soap *soap, const char *tag, enum ns1__DistanceUnit *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__DistanceUnit *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DistanceUnit, sizeof(enum ns1__DistanceUnit), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__DistanceUnit(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__DistanceUnit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DistanceUnit, 0, sizeof(enum ns1__DistanceUnit), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DataSourceCapability(struct soap *soap, enum ns1__DataSourceCapability *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__DataSourceCapability
	*a = SOAP_DEFAULT_ns1__DataSourceCapability;
#else
	*a = (enum ns1__DataSourceCapability)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DataSourceCapability(struct soap *soap, const enum ns1__DataSourceCapability *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DataSourceCapability);
	if (soap_out_ns1__DataSourceCapability(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__DataSourceCapability[] =
{	{ (long)ns1__DataSourceCapability__CanDrawMaps, "CanDrawMaps" },
	{ (long)ns1__DataSourceCapability__CanFindPlaces, "CanFindPlaces" },
	{ (long)ns1__DataSourceCapability__CanFindNearby, "CanFindNearby" },
	{ (long)ns1__DataSourceCapability__CanRoute, "CanRoute" },
	{ (long)ns1__DataSourceCapability__CanFindAddress, "CanFindAddress" },
	{ (long)ns1__DataSourceCapability__HasIcons, "HasIcons" },
	{ (long)ns1__DataSourceCapability__DataServiceQuery, "DataServiceQuery" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__DataSourceCapability2s(struct soap *soap, enum ns1__DataSourceCapability n)
{
	return soap_code_list(soap, soap_codes_ns1__DataSourceCapability, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataSourceCapability(struct soap *soap, const char *tag, int id, const enum ns1__DataSourceCapability *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataSourceCapability), type) || soap_send(soap, soap_ns1__DataSourceCapability2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__DataSourceCapability * SOAP_FMAC4 soap_get_ns1__DataSourceCapability(struct soap *soap, enum ns1__DataSourceCapability *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DataSourceCapability(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__DataSourceCapability(struct soap *soap, const char *s, enum ns1__DataSourceCapability *a)
{
	*a = (enum ns1__DataSourceCapability)soap_code_bits(soap_codes_ns1__DataSourceCapability, s);
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DataSourceCapability * SOAP_FMAC4 soap_in_ns1__DataSourceCapability(struct soap *soap, const char *tag, enum ns1__DataSourceCapability *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__DataSourceCapability *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataSourceCapability, sizeof(enum ns1__DataSourceCapability), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__DataSourceCapability(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__DataSourceCapability *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataSourceCapability, 0, sizeof(enum ns1__DataSourceCapability), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::Key);
	this->_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::Value = NULL;
}

void _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::Key, SOAP_TYPE_int);
	soap_serialize_PointerTons6__CategorySpecificPropertySet(soap, &this->_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::Value);
}

int _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, const char *tag, int id, const _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s), type))
		return soap->error;
	if (soap_out_int(soap, "ns7:Key", -1, &(a->_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::Key), ""))
		return soap->error;
	if (soap_out_PointerTons6__CategorySpecificPropertySet(soap, "ns7:Value", -1, &(a->_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::Value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s * SOAP_FMAC4 soap_get__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s * SOAP_FMAC4 soap_in__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, const char *tag, _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s, sizeof(_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns7:Key", &(a->_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::Key), "xsd:int"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_Value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__CategorySpecificPropertySet(soap, "ns7:Value", &(a->_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::Value), "ns6:CategorySpecificPropertySet"))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s, 0, sizeof(_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s), 0, soap_copy__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Key1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s * SOAP_FMAC4 soap_instantiate__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s;
		if (size)
			*size = sizeof(_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
	}
	else
	{	cp->ptr = (void*)new _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s %p -> %p\n", q, p));
	*(_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)p = *(_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)q;
}

void _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_string(soap, &this->_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType::Key);
	this->_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType::Value = NULL;
}

void _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType::Key);
	soap_serialize_PointerToxsd__anyType(soap, &this->_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType::Value);
}

int _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(struct soap *soap, const char *tag, int id, const _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType), type))
		return soap->error;
	if (soap_out_string(soap, "ns7:Key", -1, &(a->_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType::Key), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "ns7:Value", -1, &(a->_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType::Value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType * SOAP_FMAC4 soap_get__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(struct soap *soap, _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType * SOAP_FMAC4 soap_in__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(struct soap *soap, const char *tag, _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType, sizeof(_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns7:Key", &(a->_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType::Key), "xsd:string"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_Value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "ns7:Value", &(a->_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType::Value), "xsd:anyType"))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType, 0, sizeof(_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType), 0, soap_copy__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType * SOAP_FMAC4 soap_instantiate__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType;
		if (size)
			*size = sizeof(_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType);
	}
	else
	{	cp->ptr = (void*)new _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType %p -> %p\n", q, p));
	*(_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType*)p = *(_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType*)q;
}

void _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6::Key = NULL;
	soap_default_int(soap, &this->_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6::Value);
}

void _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__Neighborhood(soap, &this->_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6::Key);
	soap_embedded(soap, &this->_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6::Value, SOAP_TYPE_int);
}

int _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, const char *tag, int id, const _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6), type))
		return soap->error;
	if (soap_out_PointerTons6__Neighborhood(soap, "ns7:Key", -1, &(a->_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6::Key), ""))
		return soap->error;
	if (soap_out_int(soap, "ns7:Value", -1, &(a->_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6::Value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 * SOAP_FMAC4 soap_get__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 * SOAP_FMAC4 soap_in__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, const char *tag, _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6, sizeof(_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Neighborhood(soap, "ns7:Key", &(a->_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6::Key), "ns6:Neighborhood"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_Value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns7:Value", &(a->_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6::Value), "xsd:int"))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6, 0, sizeof(_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6), 0, soap_copy__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 * SOAP_FMAC4 soap_instantiate__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6;
		if (size)
			*size = sizeof(_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6);
	}
	else
	{	cp->ptr = (void*)new _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 %p -> %p\n", q, p));
	*(_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6*)p = *(_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6*)q;
}

void ns16__ItineraryWarningType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns16__ItineraryWarningType(soap, &this->ns16__ItineraryWarningType_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__ItineraryWarningType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns16__ItineraryWarningType_::__item, SOAP_TYPE_ns16__ItineraryWarningType);
	/* transient soap skipped */
}

int ns16__ItineraryWarningType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__ItineraryWarningType_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__ItineraryWarningType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__ItineraryWarningType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ItineraryWarningType_(struct soap *soap, const char *tag, int id, const ns16__ItineraryWarningType_ *a, const char *type)
{
	return soap_out_ns16__ItineraryWarningType(soap, tag, id, &(a->ns16__ItineraryWarningType_::__item), "ns16:ItineraryWarningType");
}

void *ns16__ItineraryWarningType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__ItineraryWarningType_(soap, this, tag, type);
}

SOAP_FMAC3 ns16__ItineraryWarningType_ * SOAP_FMAC4 soap_get_ns16__ItineraryWarningType_(struct soap *soap, ns16__ItineraryWarningType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ItineraryWarningType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__ItineraryWarningType_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__ItineraryWarningType_(soap, tag, this, type);
}

SOAP_FMAC3 ns16__ItineraryWarningType_ * SOAP_FMAC4 soap_in_ns16__ItineraryWarningType_(struct soap *soap, const char *tag, ns16__ItineraryWarningType_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns16__ItineraryWarningType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ItineraryWarningType_, sizeof(ns16__ItineraryWarningType_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__ItineraryWarningType_)
			return (ns16__ItineraryWarningType_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns16__ItineraryWarningType(soap, tag, &(a->ns16__ItineraryWarningType_::__item), "ns16:ItineraryWarningType"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns16__ItineraryWarningType_ * SOAP_FMAC4 soap_instantiate_ns16__ItineraryWarningType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__ItineraryWarningType_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__ItineraryWarningType_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__ItineraryWarningType_;
		if (size)
			*size = sizeof(ns16__ItineraryWarningType_);
		((ns16__ItineraryWarningType_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__ItineraryWarningType_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__ItineraryWarningType_);
		for (int i = 0; i < n; i++)
			((ns16__ItineraryWarningType_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__ItineraryWarningType_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__ItineraryWarningType_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__ItineraryWarningType_ %p -> %p\n", q, p));
	*(ns16__ItineraryWarningType_*)p = *(ns16__ItineraryWarningType_*)q;
}

void ns16__ItineraryWarningSeverity_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns16__ItineraryWarningSeverity(soap, &this->ns16__ItineraryWarningSeverity_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__ItineraryWarningSeverity_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns16__ItineraryWarningSeverity_::__item, SOAP_TYPE_ns16__ItineraryWarningSeverity);
	/* transient soap skipped */
}

int ns16__ItineraryWarningSeverity_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__ItineraryWarningSeverity_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__ItineraryWarningSeverity_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__ItineraryWarningSeverity_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ItineraryWarningSeverity_(struct soap *soap, const char *tag, int id, const ns16__ItineraryWarningSeverity_ *a, const char *type)
{
	return soap_out_ns16__ItineraryWarningSeverity(soap, tag, id, &(a->ns16__ItineraryWarningSeverity_::__item), "ns16:ItineraryWarningSeverity");
}

void *ns16__ItineraryWarningSeverity_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__ItineraryWarningSeverity_(soap, this, tag, type);
}

SOAP_FMAC3 ns16__ItineraryWarningSeverity_ * SOAP_FMAC4 soap_get_ns16__ItineraryWarningSeverity_(struct soap *soap, ns16__ItineraryWarningSeverity_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ItineraryWarningSeverity_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__ItineraryWarningSeverity_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__ItineraryWarningSeverity_(soap, tag, this, type);
}

SOAP_FMAC3 ns16__ItineraryWarningSeverity_ * SOAP_FMAC4 soap_in_ns16__ItineraryWarningSeverity_(struct soap *soap, const char *tag, ns16__ItineraryWarningSeverity_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns16__ItineraryWarningSeverity_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ItineraryWarningSeverity_, sizeof(ns16__ItineraryWarningSeverity_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__ItineraryWarningSeverity_)
			return (ns16__ItineraryWarningSeverity_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns16__ItineraryWarningSeverity(soap, tag, &(a->ns16__ItineraryWarningSeverity_::__item), "ns16:ItineraryWarningSeverity"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns16__ItineraryWarningSeverity_ * SOAP_FMAC4 soap_instantiate_ns16__ItineraryWarningSeverity_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__ItineraryWarningSeverity_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__ItineraryWarningSeverity_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__ItineraryWarningSeverity_;
		if (size)
			*size = sizeof(ns16__ItineraryWarningSeverity_);
		((ns16__ItineraryWarningSeverity_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__ItineraryWarningSeverity_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__ItineraryWarningSeverity_);
		for (int i = 0; i < n; i++)
			((ns16__ItineraryWarningSeverity_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__ItineraryWarningSeverity_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__ItineraryWarningSeverity_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__ItineraryWarningSeverity_ %p -> %p\n", q, p));
	*(ns16__ItineraryWarningSeverity_*)p = *(ns16__ItineraryWarningSeverity_*)q;
}

void ns16__ManeuverType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns16__ManeuverType(soap, &this->ns16__ManeuverType_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__ManeuverType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns16__ManeuverType_::__item, SOAP_TYPE_ns16__ManeuverType);
	/* transient soap skipped */
}

int ns16__ManeuverType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__ManeuverType_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__ManeuverType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__ManeuverType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ManeuverType_(struct soap *soap, const char *tag, int id, const ns16__ManeuverType_ *a, const char *type)
{
	return soap_out_ns16__ManeuverType(soap, tag, id, &(a->ns16__ManeuverType_::__item), "ns16:ManeuverType");
}

void *ns16__ManeuverType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__ManeuverType_(soap, this, tag, type);
}

SOAP_FMAC3 ns16__ManeuverType_ * SOAP_FMAC4 soap_get_ns16__ManeuverType_(struct soap *soap, ns16__ManeuverType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ManeuverType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__ManeuverType_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__ManeuverType_(soap, tag, this, type);
}

SOAP_FMAC3 ns16__ManeuverType_ * SOAP_FMAC4 soap_in_ns16__ManeuverType_(struct soap *soap, const char *tag, ns16__ManeuverType_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns16__ManeuverType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ManeuverType_, sizeof(ns16__ManeuverType_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__ManeuverType_)
			return (ns16__ManeuverType_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns16__ManeuverType(soap, tag, &(a->ns16__ManeuverType_::__item), "ns16:ManeuverType"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns16__ManeuverType_ * SOAP_FMAC4 soap_instantiate_ns16__ManeuverType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__ManeuverType_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__ManeuverType_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__ManeuverType_;
		if (size)
			*size = sizeof(ns16__ManeuverType_);
		((ns16__ManeuverType_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__ManeuverType_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__ManeuverType_);
		for (int i = 0; i < n; i++)
			((ns16__ManeuverType_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__ManeuverType_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__ManeuverType_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__ManeuverType_ %p -> %p\n", q, p));
	*(ns16__ManeuverType_*)p = *(ns16__ManeuverType_*)q;
}

void ns16__ItineraryItemHintType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns16__ItineraryItemHintType(soap, &this->ns16__ItineraryItemHintType_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__ItineraryItemHintType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns16__ItineraryItemHintType_::__item, SOAP_TYPE_ns16__ItineraryItemHintType);
	/* transient soap skipped */
}

int ns16__ItineraryItemHintType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__ItineraryItemHintType_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__ItineraryItemHintType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__ItineraryItemHintType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ItineraryItemHintType_(struct soap *soap, const char *tag, int id, const ns16__ItineraryItemHintType_ *a, const char *type)
{
	return soap_out_ns16__ItineraryItemHintType(soap, tag, id, &(a->ns16__ItineraryItemHintType_::__item), "ns16:ItineraryItemHintType");
}

void *ns16__ItineraryItemHintType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__ItineraryItemHintType_(soap, this, tag, type);
}

SOAP_FMAC3 ns16__ItineraryItemHintType_ * SOAP_FMAC4 soap_get_ns16__ItineraryItemHintType_(struct soap *soap, ns16__ItineraryItemHintType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ItineraryItemHintType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__ItineraryItemHintType_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__ItineraryItemHintType_(soap, tag, this, type);
}

SOAP_FMAC3 ns16__ItineraryItemHintType_ * SOAP_FMAC4 soap_in_ns16__ItineraryItemHintType_(struct soap *soap, const char *tag, ns16__ItineraryItemHintType_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns16__ItineraryItemHintType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ItineraryItemHintType_, sizeof(ns16__ItineraryItemHintType_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__ItineraryItemHintType_)
			return (ns16__ItineraryItemHintType_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns16__ItineraryItemHintType(soap, tag, &(a->ns16__ItineraryItemHintType_::__item), "ns16:ItineraryItemHintType"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns16__ItineraryItemHintType_ * SOAP_FMAC4 soap_instantiate_ns16__ItineraryItemHintType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__ItineraryItemHintType_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__ItineraryItemHintType_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__ItineraryItemHintType_;
		if (size)
			*size = sizeof(ns16__ItineraryItemHintType_);
		((ns16__ItineraryItemHintType_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__ItineraryItemHintType_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__ItineraryItemHintType_);
		for (int i = 0; i < n; i++)
			((ns16__ItineraryItemHintType_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__ItineraryItemHintType_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__ItineraryItemHintType_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__ItineraryItemHintType_ %p -> %p\n", q, p));
	*(ns16__ItineraryItemHintType_*)p = *(ns16__ItineraryItemHintType_*)q;
}

void ns16__TrafficUsage_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns16__TrafficUsage(soap, &this->ns16__TrafficUsage_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__TrafficUsage_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns16__TrafficUsage_::__item, SOAP_TYPE_ns16__TrafficUsage);
	/* transient soap skipped */
}

int ns16__TrafficUsage_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__TrafficUsage_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__TrafficUsage_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__TrafficUsage_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__TrafficUsage_(struct soap *soap, const char *tag, int id, const ns16__TrafficUsage_ *a, const char *type)
{
	return soap_out_ns16__TrafficUsage(soap, tag, id, &(a->ns16__TrafficUsage_::__item), "ns16:TrafficUsage");
}

void *ns16__TrafficUsage_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__TrafficUsage_(soap, this, tag, type);
}

SOAP_FMAC3 ns16__TrafficUsage_ * SOAP_FMAC4 soap_get_ns16__TrafficUsage_(struct soap *soap, ns16__TrafficUsage_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__TrafficUsage_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__TrafficUsage_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__TrafficUsage_(soap, tag, this, type);
}

SOAP_FMAC3 ns16__TrafficUsage_ * SOAP_FMAC4 soap_in_ns16__TrafficUsage_(struct soap *soap, const char *tag, ns16__TrafficUsage_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns16__TrafficUsage_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__TrafficUsage_, sizeof(ns16__TrafficUsage_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__TrafficUsage_)
			return (ns16__TrafficUsage_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns16__TrafficUsage(soap, tag, &(a->ns16__TrafficUsage_::__item), "ns16:TrafficUsage"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns16__TrafficUsage_ * SOAP_FMAC4 soap_instantiate_ns16__TrafficUsage_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__TrafficUsage_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__TrafficUsage_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__TrafficUsage_;
		if (size)
			*size = sizeof(ns16__TrafficUsage_);
		((ns16__TrafficUsage_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__TrafficUsage_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__TrafficUsage_);
		for (int i = 0; i < n; i++)
			((ns16__TrafficUsage_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__TrafficUsage_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__TrafficUsage_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__TrafficUsage_ %p -> %p\n", q, p));
	*(ns16__TrafficUsage_*)p = *(ns16__TrafficUsage_*)q;
}

void ns16__RoutePathType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns16__RoutePathType(soap, &this->ns16__RoutePathType_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__RoutePathType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns16__RoutePathType_::__item, SOAP_TYPE_ns16__RoutePathType);
	/* transient soap skipped */
}

int ns16__RoutePathType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__RoutePathType_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__RoutePathType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__RoutePathType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__RoutePathType_(struct soap *soap, const char *tag, int id, const ns16__RoutePathType_ *a, const char *type)
{
	return soap_out_ns16__RoutePathType(soap, tag, id, &(a->ns16__RoutePathType_::__item), "ns16:RoutePathType");
}

void *ns16__RoutePathType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__RoutePathType_(soap, this, tag, type);
}

SOAP_FMAC3 ns16__RoutePathType_ * SOAP_FMAC4 soap_get_ns16__RoutePathType_(struct soap *soap, ns16__RoutePathType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__RoutePathType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__RoutePathType_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__RoutePathType_(soap, tag, this, type);
}

SOAP_FMAC3 ns16__RoutePathType_ * SOAP_FMAC4 soap_in_ns16__RoutePathType_(struct soap *soap, const char *tag, ns16__RoutePathType_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns16__RoutePathType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__RoutePathType_, sizeof(ns16__RoutePathType_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__RoutePathType_)
			return (ns16__RoutePathType_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns16__RoutePathType(soap, tag, &(a->ns16__RoutePathType_::__item), "ns16:RoutePathType"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns16__RoutePathType_ * SOAP_FMAC4 soap_instantiate_ns16__RoutePathType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__RoutePathType_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__RoutePathType_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__RoutePathType_;
		if (size)
			*size = sizeof(ns16__RoutePathType_);
		((ns16__RoutePathType_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__RoutePathType_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__RoutePathType_);
		for (int i = 0; i < n; i++)
			((ns16__RoutePathType_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__RoutePathType_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__RoutePathType_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__RoutePathType_ %p -> %p\n", q, p));
	*(ns16__RoutePathType_*)p = *(ns16__RoutePathType_*)q;
}

void ns16__RouteOptimization_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns16__RouteOptimization(soap, &this->ns16__RouteOptimization_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__RouteOptimization_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns16__RouteOptimization_::__item, SOAP_TYPE_ns16__RouteOptimization);
	/* transient soap skipped */
}

int ns16__RouteOptimization_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__RouteOptimization_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__RouteOptimization_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__RouteOptimization_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__RouteOptimization_(struct soap *soap, const char *tag, int id, const ns16__RouteOptimization_ *a, const char *type)
{
	return soap_out_ns16__RouteOptimization(soap, tag, id, &(a->ns16__RouteOptimization_::__item), "ns16:RouteOptimization");
}

void *ns16__RouteOptimization_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__RouteOptimization_(soap, this, tag, type);
}

SOAP_FMAC3 ns16__RouteOptimization_ * SOAP_FMAC4 soap_get_ns16__RouteOptimization_(struct soap *soap, ns16__RouteOptimization_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__RouteOptimization_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__RouteOptimization_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__RouteOptimization_(soap, tag, this, type);
}

SOAP_FMAC3 ns16__RouteOptimization_ * SOAP_FMAC4 soap_in_ns16__RouteOptimization_(struct soap *soap, const char *tag, ns16__RouteOptimization_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns16__RouteOptimization_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__RouteOptimization_, sizeof(ns16__RouteOptimization_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__RouteOptimization_)
			return (ns16__RouteOptimization_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns16__RouteOptimization(soap, tag, &(a->ns16__RouteOptimization_::__item), "ns16:RouteOptimization"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns16__RouteOptimization_ * SOAP_FMAC4 soap_instantiate_ns16__RouteOptimization_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__RouteOptimization_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__RouteOptimization_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__RouteOptimization_;
		if (size)
			*size = sizeof(ns16__RouteOptimization_);
		((ns16__RouteOptimization_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__RouteOptimization_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__RouteOptimization_);
		for (int i = 0; i < n; i++)
			((ns16__RouteOptimization_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__RouteOptimization_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__RouteOptimization_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__RouteOptimization_ %p -> %p\n", q, p));
	*(ns16__RouteOptimization_*)p = *(ns16__RouteOptimization_*)q;
}

void ns16__TravelMode_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns16__TravelMode(soap, &this->ns16__TravelMode_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__TravelMode_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns16__TravelMode_::__item, SOAP_TYPE_ns16__TravelMode);
	/* transient soap skipped */
}

int ns16__TravelMode_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__TravelMode_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__TravelMode_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__TravelMode_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__TravelMode_(struct soap *soap, const char *tag, int id, const ns16__TravelMode_ *a, const char *type)
{
	return soap_out_ns16__TravelMode(soap, tag, id, &(a->ns16__TravelMode_::__item), "ns16:TravelMode");
}

void *ns16__TravelMode_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__TravelMode_(soap, this, tag, type);
}

SOAP_FMAC3 ns16__TravelMode_ * SOAP_FMAC4 soap_get_ns16__TravelMode_(struct soap *soap, ns16__TravelMode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__TravelMode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__TravelMode_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__TravelMode_(soap, tag, this, type);
}

SOAP_FMAC3 ns16__TravelMode_ * SOAP_FMAC4 soap_in_ns16__TravelMode_(struct soap *soap, const char *tag, ns16__TravelMode_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns16__TravelMode_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__TravelMode_, sizeof(ns16__TravelMode_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__TravelMode_)
			return (ns16__TravelMode_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns16__TravelMode(soap, tag, &(a->ns16__TravelMode_::__item), "ns16:TravelMode"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns16__TravelMode_ * SOAP_FMAC4 soap_instantiate_ns16__TravelMode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__TravelMode_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__TravelMode_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__TravelMode_;
		if (size)
			*size = sizeof(ns16__TravelMode_);
		((ns16__TravelMode_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__TravelMode_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__TravelMode_);
		for (int i = 0; i < n; i++)
			((ns16__TravelMode_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__TravelMode_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__TravelMode_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__TravelMode_ %p -> %p\n", q, p));
	*(ns16__TravelMode_*)p = *(ns16__TravelMode_*)q;
}

void ns6__SortOrder_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__SortOrder(soap, &this->ns6__SortOrder_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__SortOrder_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns6__SortOrder_::__item, SOAP_TYPE_ns6__SortOrder);
	/* transient soap skipped */
}

int ns6__SortOrder_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__SortOrder_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__SortOrder_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SortOrder_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SortOrder_(struct soap *soap, const char *tag, int id, const ns6__SortOrder_ *a, const char *type)
{
	return soap_out_ns6__SortOrder(soap, tag, id, &(a->ns6__SortOrder_::__item), "ns6:SortOrder");
}

void *ns6__SortOrder_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SortOrder_(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SortOrder_ * SOAP_FMAC4 soap_get_ns6__SortOrder_(struct soap *soap, ns6__SortOrder_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SortOrder_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__SortOrder_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__SortOrder_(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SortOrder_ * SOAP_FMAC4 soap_in_ns6__SortOrder_(struct soap *soap, const char *tag, ns6__SortOrder_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns6__SortOrder_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SortOrder_, sizeof(ns6__SortOrder_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__SortOrder_)
			return (ns6__SortOrder_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns6__SortOrder(soap, tag, &(a->ns6__SortOrder_::__item), "ns6:SortOrder"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns6__SortOrder_ * SOAP_FMAC4 soap_instantiate_ns6__SortOrder_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__SortOrder_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__SortOrder_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__SortOrder_;
		if (size)
			*size = sizeof(ns6__SortOrder_);
		((ns6__SortOrder_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__SortOrder_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__SortOrder_);
		for (int i = 0; i < n; i++)
			((ns6__SortOrder_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__SortOrder_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__SortOrder_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__SortOrder_ %p -> %p\n", q, p));
	*(ns6__SortOrder_*)p = *(ns6__SortOrder_*)q;
}

void ns6__ListingType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__ListingType(soap, &this->ns6__ListingType_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__ListingType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns6__ListingType_::__item, SOAP_TYPE_ns6__ListingType);
	/* transient soap skipped */
}

int ns6__ListingType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ListingType_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__ListingType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ListingType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ListingType_(struct soap *soap, const char *tag, int id, const ns6__ListingType_ *a, const char *type)
{
	return soap_out_ns6__ListingType(soap, tag, id, &(a->ns6__ListingType_::__item), "ns6:ListingType");
}

void *ns6__ListingType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ListingType_(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ListingType_ * SOAP_FMAC4 soap_get_ns6__ListingType_(struct soap *soap, ns6__ListingType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ListingType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__ListingType_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ListingType_(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ListingType_ * SOAP_FMAC4 soap_in_ns6__ListingType_(struct soap *soap, const char *tag, ns6__ListingType_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns6__ListingType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ListingType_, sizeof(ns6__ListingType_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ListingType_)
			return (ns6__ListingType_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns6__ListingType(soap, tag, &(a->ns6__ListingType_::__item), "ns6:ListingType"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns6__ListingType_ * SOAP_FMAC4 soap_instantiate_ns6__ListingType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ListingType_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ListingType_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__ListingType_;
		if (size)
			*size = sizeof(ns6__ListingType_);
		((ns6__ListingType_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__ListingType_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__ListingType_);
		for (int i = 0; i < n; i++)
			((ns6__ListingType_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ListingType_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ListingType_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ListingType_ %p -> %p\n", q, p));
	*(ns6__ListingType_*)p = *(ns6__ListingType_*)q;
}

void ns5__guid__::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns5__guid(soap, &this->ns5__guid__::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns5__guid__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns5__guid(soap, &this->ns5__guid__::__item);
	/* transient soap skipped */
}

int ns5__guid__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__guid__);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__guid__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__guid__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__guid__(struct soap *soap, const char *tag, int id, const ns5__guid__ *a, const char *type)
{
	return soap_out_ns5__guid(soap, tag, id, &(a->ns5__guid__::__item), "ns5:guid");
}

void *ns5__guid__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__guid__(soap, this, tag, type);
}

SOAP_FMAC3 ns5__guid__ * SOAP_FMAC4 soap_get_ns5__guid__(struct soap *soap, ns5__guid__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__guid__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns5__guid__::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__guid__(soap, tag, this, type);
}

SOAP_FMAC3 ns5__guid__ * SOAP_FMAC4 soap_in_ns5__guid__(struct soap *soap, const char *tag, ns5__guid__ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns5__guid__ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__guid__, sizeof(ns5__guid__), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__guid__)
			return (ns5__guid__ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns5__guid(soap, tag, &(a->ns5__guid__::__item), "ns5:guid"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns5__guid__ * SOAP_FMAC4 soap_instantiate_ns5__guid__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__guid__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__guid__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__guid__;
		if (size)
			*size = sizeof(ns5__guid__);
		((ns5__guid__*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__guid__[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__guid__);
		for (int i = 0; i < n; i++)
			((ns5__guid__*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__guid__*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__guid__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__guid__ %p -> %p\n", q, p));
	*(ns5__guid__*)p = *(ns5__guid__*)q;
}

void ns5__duration__::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns5__duration(soap, &this->ns5__duration__::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns5__duration__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns5__duration(soap, &this->ns5__duration__::__item);
	/* transient soap skipped */
}

int ns5__duration__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__duration__);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__duration__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__duration__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__duration__(struct soap *soap, const char *tag, int id, const ns5__duration__ *a, const char *type)
{
	return soap_out_ns5__duration(soap, tag, id, &(a->ns5__duration__::__item), "ns5:duration");
}

void *ns5__duration__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__duration__(soap, this, tag, type);
}

SOAP_FMAC3 ns5__duration__ * SOAP_FMAC4 soap_get_ns5__duration__(struct soap *soap, ns5__duration__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__duration__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns5__duration__::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__duration__(soap, tag, this, type);
}

SOAP_FMAC3 ns5__duration__ * SOAP_FMAC4 soap_in_ns5__duration__(struct soap *soap, const char *tag, ns5__duration__ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns5__duration__ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__duration__, sizeof(ns5__duration__), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__duration__)
			return (ns5__duration__ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns5__duration(soap, tag, &(a->ns5__duration__::__item), "ns5:duration"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns5__duration__ * SOAP_FMAC4 soap_instantiate_ns5__duration__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__duration__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__duration__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__duration__;
		if (size)
			*size = sizeof(ns5__duration__);
		((ns5__duration__*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__duration__[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__duration__);
		for (int i = 0; i < n; i++)
			((ns5__duration__*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__duration__*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__duration__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__duration__ %p -> %p\n", q, p));
	*(ns5__duration__*)p = *(ns5__duration__*)q;
}

void ns5__char__::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns5__char(soap, &this->ns5__char__::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns5__char__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns5__char__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__char__);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__char__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__char__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__char__(struct soap *soap, const char *tag, int id, const ns5__char__ *a, const char *type)
{
	return soap_out_ns5__char(soap, tag, id, &(a->ns5__char__::__item), "ns5:char");
}

void *ns5__char__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__char__(soap, this, tag, type);
}

SOAP_FMAC3 ns5__char__ * SOAP_FMAC4 soap_get_ns5__char__(struct soap *soap, ns5__char__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__char__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns5__char__::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__char__(soap, tag, this, type);
}

SOAP_FMAC3 ns5__char__ * SOAP_FMAC4 soap_in_ns5__char__(struct soap *soap, const char *tag, ns5__char__ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns5__char__ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__char__, sizeof(ns5__char__), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__char__)
			return (ns5__char__ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns5__char(soap, tag, &(a->ns5__char__::__item), "ns5:char"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns5__char__ * SOAP_FMAC4 soap_instantiate_ns5__char__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__char__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__char__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__char__;
		if (size)
			*size = sizeof(ns5__char__);
		((ns5__char__*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__char__[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__char__);
		for (int i = 0; i < n; i++)
			((ns5__char__*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__char__*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__char__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__char__ %p -> %p\n", q, p));
	*(ns5__char__*)p = *(ns5__char__*)q;
}

void ns4__ImageType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__ImageType(soap, &this->ns4__ImageType_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__ImageType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns4__ImageType_::__item, SOAP_TYPE_ns4__ImageType);
	/* transient soap skipped */
}

int ns4__ImageType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ImageType_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ImageType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ImageType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ImageType_(struct soap *soap, const char *tag, int id, const ns4__ImageType_ *a, const char *type)
{
	return soap_out_ns4__ImageType(soap, tag, id, &(a->ns4__ImageType_::__item), "ns4:ImageType");
}

void *ns4__ImageType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ImageType_(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ImageType_ * SOAP_FMAC4 soap_get_ns4__ImageType_(struct soap *soap, ns4__ImageType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ImageType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__ImageType_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ImageType_(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ImageType_ * SOAP_FMAC4 soap_in_ns4__ImageType_(struct soap *soap, const char *tag, ns4__ImageType_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__ImageType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ImageType_, sizeof(ns4__ImageType_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ImageType_)
			return (ns4__ImageType_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns4__ImageType(soap, tag, &(a->ns4__ImageType_::__item), "ns4:ImageType"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns4__ImageType_ * SOAP_FMAC4 soap_instantiate_ns4__ImageType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ImageType_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ImageType_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ImageType_;
		if (size)
			*size = sizeof(ns4__ImageType_);
		((ns4__ImageType_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ImageType_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__ImageType_);
		for (int i = 0; i < n; i++)
			((ns4__ImageType_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ImageType_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ImageType_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ImageType_ %p -> %p\n", q, p));
	*(ns4__ImageType_*)p = *(ns4__ImageType_*)q;
}

void ns4__MapStyle_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__MapStyle(soap, &this->ns4__MapStyle_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__MapStyle_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns4__MapStyle_::__item, SOAP_TYPE_ns4__MapStyle);
	/* transient soap skipped */
}

int ns4__MapStyle_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__MapStyle_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__MapStyle_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__MapStyle_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__MapStyle_(struct soap *soap, const char *tag, int id, const ns4__MapStyle_ *a, const char *type)
{
	return soap_out_ns4__MapStyle(soap, tag, id, &(a->ns4__MapStyle_::__item), "ns4:MapStyle");
}

void *ns4__MapStyle_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__MapStyle_(soap, this, tag, type);
}

SOAP_FMAC3 ns4__MapStyle_ * SOAP_FMAC4 soap_get_ns4__MapStyle_(struct soap *soap, ns4__MapStyle_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__MapStyle_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__MapStyle_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__MapStyle_(soap, tag, this, type);
}

SOAP_FMAC3 ns4__MapStyle_ * SOAP_FMAC4 soap_in_ns4__MapStyle_(struct soap *soap, const char *tag, ns4__MapStyle_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__MapStyle_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__MapStyle_, sizeof(ns4__MapStyle_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__MapStyle_)
			return (ns4__MapStyle_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns4__MapStyle(soap, tag, &(a->ns4__MapStyle_::__item), "ns4:MapStyle"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns4__MapStyle_ * SOAP_FMAC4 soap_instantiate_ns4__MapStyle_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__MapStyle_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__MapStyle_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__MapStyle_;
		if (size)
			*size = sizeof(ns4__MapStyle_);
		((ns4__MapStyle_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__MapStyle_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__MapStyle_);
		for (int i = 0; i < n; i++)
			((ns4__MapStyle_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__MapStyle_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__MapStyle_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__MapStyle_ %p -> %p\n", q, p));
	*(ns4__MapStyle_*)p = *(ns4__MapStyle_*)q;
}

void ns4__UriScheme_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__UriScheme(soap, &this->ns4__UriScheme_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__UriScheme_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns4__UriScheme_::__item, SOAP_TYPE_ns4__UriScheme);
	/* transient soap skipped */
}

int ns4__UriScheme_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__UriScheme_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__UriScheme_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__UriScheme_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UriScheme_(struct soap *soap, const char *tag, int id, const ns4__UriScheme_ *a, const char *type)
{
	return soap_out_ns4__UriScheme(soap, tag, id, &(a->ns4__UriScheme_::__item), "ns4:UriScheme");
}

void *ns4__UriScheme_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__UriScheme_(soap, this, tag, type);
}

SOAP_FMAC3 ns4__UriScheme_ * SOAP_FMAC4 soap_get_ns4__UriScheme_(struct soap *soap, ns4__UriScheme_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UriScheme_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__UriScheme_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__UriScheme_(soap, tag, this, type);
}

SOAP_FMAC3 ns4__UriScheme_ * SOAP_FMAC4 soap_in_ns4__UriScheme_(struct soap *soap, const char *tag, ns4__UriScheme_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__UriScheme_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UriScheme_, sizeof(ns4__UriScheme_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__UriScheme_)
			return (ns4__UriScheme_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns4__UriScheme(soap, tag, &(a->ns4__UriScheme_::__item), "ns4:UriScheme"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns4__UriScheme_ * SOAP_FMAC4 soap_instantiate_ns4__UriScheme_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__UriScheme_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__UriScheme_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__UriScheme_;
		if (size)
			*size = sizeof(ns4__UriScheme_);
		((ns4__UriScheme_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__UriScheme_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__UriScheme_);
		for (int i = 0; i < n; i++)
			((ns4__UriScheme_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__UriScheme_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__UriScheme_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__UriScheme_ %p -> %p\n", q, p));
	*(ns4__UriScheme_*)p = *(ns4__UriScheme_*)q;
}

void ns4__ResponseStatusCode_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__ResponseStatusCode(soap, &this->ns4__ResponseStatusCode_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__ResponseStatusCode_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns4__ResponseStatusCode_::__item, SOAP_TYPE_ns4__ResponseStatusCode);
	/* transient soap skipped */
}

int ns4__ResponseStatusCode_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ResponseStatusCode_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ResponseStatusCode_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ResponseStatusCode_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ResponseStatusCode_(struct soap *soap, const char *tag, int id, const ns4__ResponseStatusCode_ *a, const char *type)
{
	return soap_out_ns4__ResponseStatusCode(soap, tag, id, &(a->ns4__ResponseStatusCode_::__item), "ns4:ResponseStatusCode");
}

void *ns4__ResponseStatusCode_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ResponseStatusCode_(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ResponseStatusCode_ * SOAP_FMAC4 soap_get_ns4__ResponseStatusCode_(struct soap *soap, ns4__ResponseStatusCode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ResponseStatusCode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__ResponseStatusCode_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ResponseStatusCode_(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ResponseStatusCode_ * SOAP_FMAC4 soap_in_ns4__ResponseStatusCode_(struct soap *soap, const char *tag, ns4__ResponseStatusCode_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__ResponseStatusCode_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ResponseStatusCode_, sizeof(ns4__ResponseStatusCode_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ResponseStatusCode_)
			return (ns4__ResponseStatusCode_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns4__ResponseStatusCode(soap, tag, &(a->ns4__ResponseStatusCode_::__item), "ns4:ResponseStatusCode"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns4__ResponseStatusCode_ * SOAP_FMAC4 soap_instantiate_ns4__ResponseStatusCode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ResponseStatusCode_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ResponseStatusCode_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ResponseStatusCode_;
		if (size)
			*size = sizeof(ns4__ResponseStatusCode_);
		((ns4__ResponseStatusCode_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ResponseStatusCode_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__ResponseStatusCode_);
		for (int i = 0; i < n; i++)
			((ns4__ResponseStatusCode_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ResponseStatusCode_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ResponseStatusCode_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ResponseStatusCode_ %p -> %p\n", q, p));
	*(ns4__ResponseStatusCode_*)p = *(ns4__ResponseStatusCode_*)q;
}

void ns4__AuthenticationResultCode_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__AuthenticationResultCode(soap, &this->ns4__AuthenticationResultCode_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__AuthenticationResultCode_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns4__AuthenticationResultCode_::__item, SOAP_TYPE_ns4__AuthenticationResultCode);
	/* transient soap skipped */
}

int ns4__AuthenticationResultCode_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__AuthenticationResultCode_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__AuthenticationResultCode_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__AuthenticationResultCode_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__AuthenticationResultCode_(struct soap *soap, const char *tag, int id, const ns4__AuthenticationResultCode_ *a, const char *type)
{
	return soap_out_ns4__AuthenticationResultCode(soap, tag, id, &(a->ns4__AuthenticationResultCode_::__item), "ns4:AuthenticationResultCode");
}

void *ns4__AuthenticationResultCode_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__AuthenticationResultCode_(soap, this, tag, type);
}

SOAP_FMAC3 ns4__AuthenticationResultCode_ * SOAP_FMAC4 soap_get_ns4__AuthenticationResultCode_(struct soap *soap, ns4__AuthenticationResultCode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__AuthenticationResultCode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__AuthenticationResultCode_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__AuthenticationResultCode_(soap, tag, this, type);
}

SOAP_FMAC3 ns4__AuthenticationResultCode_ * SOAP_FMAC4 soap_in_ns4__AuthenticationResultCode_(struct soap *soap, const char *tag, ns4__AuthenticationResultCode_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__AuthenticationResultCode_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__AuthenticationResultCode_, sizeof(ns4__AuthenticationResultCode_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__AuthenticationResultCode_)
			return (ns4__AuthenticationResultCode_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns4__AuthenticationResultCode(soap, tag, &(a->ns4__AuthenticationResultCode_::__item), "ns4:AuthenticationResultCode"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns4__AuthenticationResultCode_ * SOAP_FMAC4 soap_instantiate_ns4__AuthenticationResultCode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__AuthenticationResultCode_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__AuthenticationResultCode_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__AuthenticationResultCode_;
		if (size)
			*size = sizeof(ns4__AuthenticationResultCode_);
		((ns4__AuthenticationResultCode_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__AuthenticationResultCode_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__AuthenticationResultCode_);
		for (int i = 0; i < n; i++)
			((ns4__AuthenticationResultCode_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__AuthenticationResultCode_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__AuthenticationResultCode_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__AuthenticationResultCode_ %p -> %p\n", q, p));
	*(ns4__AuthenticationResultCode_*)p = *(ns4__AuthenticationResultCode_*)q;
}

void ns4__LogicalOperator_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__LogicalOperator(soap, &this->ns4__LogicalOperator_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__LogicalOperator_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns4__LogicalOperator_::__item, SOAP_TYPE_ns4__LogicalOperator);
	/* transient soap skipped */
}

int ns4__LogicalOperator_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__LogicalOperator_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__LogicalOperator_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__LogicalOperator_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__LogicalOperator_(struct soap *soap, const char *tag, int id, const ns4__LogicalOperator_ *a, const char *type)
{
	return soap_out_ns4__LogicalOperator(soap, tag, id, &(a->ns4__LogicalOperator_::__item), "ns4:LogicalOperator");
}

void *ns4__LogicalOperator_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__LogicalOperator_(soap, this, tag, type);
}

SOAP_FMAC3 ns4__LogicalOperator_ * SOAP_FMAC4 soap_get_ns4__LogicalOperator_(struct soap *soap, ns4__LogicalOperator_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__LogicalOperator_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__LogicalOperator_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__LogicalOperator_(soap, tag, this, type);
}

SOAP_FMAC3 ns4__LogicalOperator_ * SOAP_FMAC4 soap_in_ns4__LogicalOperator_(struct soap *soap, const char *tag, ns4__LogicalOperator_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__LogicalOperator_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__LogicalOperator_, sizeof(ns4__LogicalOperator_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__LogicalOperator_)
			return (ns4__LogicalOperator_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns4__LogicalOperator(soap, tag, &(a->ns4__LogicalOperator_::__item), "ns4:LogicalOperator"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns4__LogicalOperator_ * SOAP_FMAC4 soap_instantiate_ns4__LogicalOperator_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__LogicalOperator_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__LogicalOperator_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__LogicalOperator_;
		if (size)
			*size = sizeof(ns4__LogicalOperator_);
		((ns4__LogicalOperator_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__LogicalOperator_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__LogicalOperator_);
		for (int i = 0; i < n; i++)
			((ns4__LogicalOperator_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__LogicalOperator_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__LogicalOperator_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__LogicalOperator_ %p -> %p\n", q, p));
	*(ns4__LogicalOperator_*)p = *(ns4__LogicalOperator_*)q;
}

void ns4__CompareOperator_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__CompareOperator(soap, &this->ns4__CompareOperator_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__CompareOperator_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns4__CompareOperator_::__item, SOAP_TYPE_ns4__CompareOperator);
	/* transient soap skipped */
}

int ns4__CompareOperator_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__CompareOperator_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__CompareOperator_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__CompareOperator_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__CompareOperator_(struct soap *soap, const char *tag, int id, const ns4__CompareOperator_ *a, const char *type)
{
	return soap_out_ns4__CompareOperator(soap, tag, id, &(a->ns4__CompareOperator_::__item), "ns4:CompareOperator");
}

void *ns4__CompareOperator_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__CompareOperator_(soap, this, tag, type);
}

SOAP_FMAC3 ns4__CompareOperator_ * SOAP_FMAC4 soap_get_ns4__CompareOperator_(struct soap *soap, ns4__CompareOperator_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__CompareOperator_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__CompareOperator_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__CompareOperator_(soap, tag, this, type);
}

SOAP_FMAC3 ns4__CompareOperator_ * SOAP_FMAC4 soap_in_ns4__CompareOperator_(struct soap *soap, const char *tag, ns4__CompareOperator_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__CompareOperator_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__CompareOperator_, sizeof(ns4__CompareOperator_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__CompareOperator_)
			return (ns4__CompareOperator_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns4__CompareOperator(soap, tag, &(a->ns4__CompareOperator_::__item), "ns4:CompareOperator"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns4__CompareOperator_ * SOAP_FMAC4 soap_instantiate_ns4__CompareOperator_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__CompareOperator_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__CompareOperator_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__CompareOperator_;
		if (size)
			*size = sizeof(ns4__CompareOperator_);
		((ns4__CompareOperator_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__CompareOperator_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__CompareOperator_);
		for (int i = 0; i < n; i++)
			((ns4__CompareOperator_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__CompareOperator_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__CompareOperator_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__CompareOperator_ %p -> %p\n", q, p));
	*(ns4__CompareOperator_*)p = *(ns4__CompareOperator_*)q;
}

void ns4__DistanceUnit_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__DistanceUnit(soap, &this->ns4__DistanceUnit_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__DistanceUnit_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns4__DistanceUnit_::__item, SOAP_TYPE_ns4__DistanceUnit);
	/* transient soap skipped */
}

int ns4__DistanceUnit_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__DistanceUnit_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__DistanceUnit_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__DistanceUnit_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__DistanceUnit_(struct soap *soap, const char *tag, int id, const ns4__DistanceUnit_ *a, const char *type)
{
	return soap_out_ns4__DistanceUnit(soap, tag, id, &(a->ns4__DistanceUnit_::__item), "ns4:DistanceUnit");
}

void *ns4__DistanceUnit_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__DistanceUnit_(soap, this, tag, type);
}

SOAP_FMAC3 ns4__DistanceUnit_ * SOAP_FMAC4 soap_get_ns4__DistanceUnit_(struct soap *soap, ns4__DistanceUnit_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__DistanceUnit_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__DistanceUnit_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__DistanceUnit_(soap, tag, this, type);
}

SOAP_FMAC3 ns4__DistanceUnit_ * SOAP_FMAC4 soap_in_ns4__DistanceUnit_(struct soap *soap, const char *tag, ns4__DistanceUnit_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__DistanceUnit_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DistanceUnit_, sizeof(ns4__DistanceUnit_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__DistanceUnit_)
			return (ns4__DistanceUnit_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns4__DistanceUnit(soap, tag, &(a->ns4__DistanceUnit_::__item), "ns4:DistanceUnit"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns4__DistanceUnit_ * SOAP_FMAC4 soap_instantiate_ns4__DistanceUnit_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__DistanceUnit_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__DistanceUnit_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__DistanceUnit_;
		if (size)
			*size = sizeof(ns4__DistanceUnit_);
		((ns4__DistanceUnit_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__DistanceUnit_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__DistanceUnit_);
		for (int i = 0; i < n; i++)
			((ns4__DistanceUnit_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__DistanceUnit_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__DistanceUnit_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__DistanceUnit_ %p -> %p\n", q, p));
	*(ns4__DistanceUnit_*)p = *(ns4__DistanceUnit_*)q;
}

void ns4__DeviceType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__DeviceType(soap, &this->ns4__DeviceType_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__DeviceType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns4__DeviceType_::__item, SOAP_TYPE_ns4__DeviceType);
	/* transient soap skipped */
}

int ns4__DeviceType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__DeviceType_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__DeviceType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__DeviceType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__DeviceType_(struct soap *soap, const char *tag, int id, const ns4__DeviceType_ *a, const char *type)
{
	return soap_out_ns4__DeviceType(soap, tag, id, &(a->ns4__DeviceType_::__item), "ns4:DeviceType");
}

void *ns4__DeviceType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__DeviceType_(soap, this, tag, type);
}

SOAP_FMAC3 ns4__DeviceType_ * SOAP_FMAC4 soap_get_ns4__DeviceType_(struct soap *soap, ns4__DeviceType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__DeviceType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__DeviceType_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__DeviceType_(soap, tag, this, type);
}

SOAP_FMAC3 ns4__DeviceType_ * SOAP_FMAC4 soap_in_ns4__DeviceType_(struct soap *soap, const char *tag, ns4__DeviceType_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__DeviceType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DeviceType_, sizeof(ns4__DeviceType_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__DeviceType_)
			return (ns4__DeviceType_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns4__DeviceType(soap, tag, &(a->ns4__DeviceType_::__item), "ns4:DeviceType"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns4__DeviceType_ * SOAP_FMAC4 soap_instantiate_ns4__DeviceType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__DeviceType_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__DeviceType_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__DeviceType_;
		if (size)
			*size = sizeof(ns4__DeviceType_);
		((ns4__DeviceType_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__DeviceType_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__DeviceType_);
		for (int i = 0; i < n; i++)
			((ns4__DeviceType_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__DeviceType_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__DeviceType_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__DeviceType_ %p -> %p\n", q, p));
	*(ns4__DeviceType_*)p = *(ns4__DeviceType_*)q;
}

void ns4__Confidence_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__Confidence(soap, &this->ns4__Confidence_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__Confidence_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns4__Confidence_::__item, SOAP_TYPE_ns4__Confidence);
	/* transient soap skipped */
}

int ns4__Confidence_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Confidence_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__Confidence_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Confidence_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Confidence_(struct soap *soap, const char *tag, int id, const ns4__Confidence_ *a, const char *type)
{
	return soap_out_ns4__Confidence(soap, tag, id, &(a->ns4__Confidence_::__item), "ns4:Confidence");
}

void *ns4__Confidence_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Confidence_(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Confidence_ * SOAP_FMAC4 soap_get_ns4__Confidence_(struct soap *soap, ns4__Confidence_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Confidence_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__Confidence_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Confidence_(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Confidence_ * SOAP_FMAC4 soap_in_ns4__Confidence_(struct soap *soap, const char *tag, ns4__Confidence_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__Confidence_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Confidence_, sizeof(ns4__Confidence_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Confidence_)
			return (ns4__Confidence_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns4__Confidence(soap, tag, &(a->ns4__Confidence_::__item), "ns4:Confidence"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns4__Confidence_ * SOAP_FMAC4 soap_instantiate_ns4__Confidence_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Confidence_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Confidence_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__Confidence_;
		if (size)
			*size = sizeof(ns4__Confidence_);
		((ns4__Confidence_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__Confidence_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__Confidence_);
		for (int i = 0; i < n; i++)
			((ns4__Confidence_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__Confidence_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Confidence_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Confidence_ %p -> %p\n", q, p));
	*(ns4__Confidence_*)p = *(ns4__Confidence_*)q;
}

void ns1__DistanceUnit_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__DistanceUnit(soap, &this->ns1__DistanceUnit_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__DistanceUnit_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__DistanceUnit_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DistanceUnit_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__DistanceUnit_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DistanceUnit_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DistanceUnit_(struct soap *soap, const char *tag, int id, const ns1__DistanceUnit_ *a, const char *type)
{
	return soap_out_ns1__DistanceUnit(soap, tag, id, &(a->ns1__DistanceUnit_::__item), "ns1:DistanceUnit");
}

void *ns1__DistanceUnit_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DistanceUnit_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DistanceUnit_ * SOAP_FMAC4 soap_get_ns1__DistanceUnit_(struct soap *soap, ns1__DistanceUnit_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DistanceUnit_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__DistanceUnit_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DistanceUnit_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DistanceUnit_ * SOAP_FMAC4 soap_in_ns1__DistanceUnit_(struct soap *soap, const char *tag, ns1__DistanceUnit_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__DistanceUnit_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DistanceUnit_, sizeof(ns1__DistanceUnit_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DistanceUnit_)
			return (ns1__DistanceUnit_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns1__DistanceUnit(soap, tag, &(a->ns1__DistanceUnit_::__item), "ns1:DistanceUnit"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns1__DistanceUnit_ * SOAP_FMAC4 soap_instantiate_ns1__DistanceUnit_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DistanceUnit_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DistanceUnit_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__DistanceUnit_;
		if (size)
			*size = sizeof(ns1__DistanceUnit_);
		((ns1__DistanceUnit_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__DistanceUnit_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DistanceUnit_);
		for (int i = 0; i < n; i++)
			((ns1__DistanceUnit_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DistanceUnit_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DistanceUnit_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DistanceUnit_ %p -> %p\n", q, p));
	*(ns1__DistanceUnit_*)p = *(ns1__DistanceUnit_*)q;
}

void ns1__DataSourceCapability_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__DataSourceCapability(soap, &this->ns1__DataSourceCapability_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__DataSourceCapability_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__DataSourceCapability_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DataSourceCapability_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__DataSourceCapability_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DataSourceCapability_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataSourceCapability_(struct soap *soap, const char *tag, int id, const ns1__DataSourceCapability_ *a, const char *type)
{
	return soap_out_ns1__DataSourceCapability(soap, tag, id, &(a->ns1__DataSourceCapability_::__item), "ns1:DataSourceCapability");
}

void *ns1__DataSourceCapability_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DataSourceCapability_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DataSourceCapability_ * SOAP_FMAC4 soap_get_ns1__DataSourceCapability_(struct soap *soap, ns1__DataSourceCapability_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DataSourceCapability_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__DataSourceCapability_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DataSourceCapability_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DataSourceCapability_ * SOAP_FMAC4 soap_in_ns1__DataSourceCapability_(struct soap *soap, const char *tag, ns1__DataSourceCapability_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__DataSourceCapability_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataSourceCapability_, sizeof(ns1__DataSourceCapability_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DataSourceCapability_)
			return (ns1__DataSourceCapability_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns1__DataSourceCapability(soap, tag, &(a->ns1__DataSourceCapability_::__item), "ns1:DataSourceCapability"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns1__DataSourceCapability_ * SOAP_FMAC4 soap_instantiate_ns1__DataSourceCapability_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DataSourceCapability_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DataSourceCapability_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__DataSourceCapability_;
		if (size)
			*size = sizeof(ns1__DataSourceCapability_);
		((ns1__DataSourceCapability_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__DataSourceCapability_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DataSourceCapability_);
		for (int i = 0; i < n; i++)
			((ns1__DataSourceCapability_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DataSourceCapability_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DataSourceCapability_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DataSourceCapability_ %p -> %p\n", q, p));
	*(ns1__DataSourceCapability_*)p = *(ns1__DataSourceCapability_*)q;
}

void ns16__ArrayOfRouteResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__ArrayOfRouteResult::__sizeRouteResult = 0;
	this->ns16__ArrayOfRouteResult::RouteResult = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__ArrayOfRouteResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns16__ArrayOfRouteResult::RouteResult)
	{	int i;
		for (i = 0; i < this->ns16__ArrayOfRouteResult::__sizeRouteResult; i++)
		{
			soap_serialize_PointerTons16__RouteResult(soap, this->ns16__ArrayOfRouteResult::RouteResult + i);
		}
	}
	/* transient soap skipped */
}

int ns16__ArrayOfRouteResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__ArrayOfRouteResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__ArrayOfRouteResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__ArrayOfRouteResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ArrayOfRouteResult(struct soap *soap, const char *tag, int id, const ns16__ArrayOfRouteResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__ArrayOfRouteResult), "ns16:ArrayOfRouteResult"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns16__ArrayOfRouteResult::RouteResult)
	{	int i;
		for (i = 0; i < a->ns16__ArrayOfRouteResult::__sizeRouteResult; i++)
			if (soap_out_PointerTons16__RouteResult(soap, "ns16:RouteResult", -1, a->ns16__ArrayOfRouteResult::RouteResult + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns16__ArrayOfRouteResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__ArrayOfRouteResult(soap, this, tag, type);
}

SOAP_FMAC3 ns16__ArrayOfRouteResult * SOAP_FMAC4 soap_get_ns16__ArrayOfRouteResult(struct soap *soap, ns16__ArrayOfRouteResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ArrayOfRouteResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__ArrayOfRouteResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__ArrayOfRouteResult(soap, tag, this, type);
}

SOAP_FMAC3 ns16__ArrayOfRouteResult * SOAP_FMAC4 soap_in_ns16__ArrayOfRouteResult(struct soap *soap, const char *tag, ns16__ArrayOfRouteResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__ArrayOfRouteResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ArrayOfRouteResult, sizeof(ns16__ArrayOfRouteResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__ArrayOfRouteResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__ArrayOfRouteResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_RouteResult1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns16:RouteResult", 1, NULL))
			{	if (a->ns16__ArrayOfRouteResult::RouteResult == NULL)
				{	if (soap_blist_RouteResult1 == NULL)
						soap_blist_RouteResult1 = soap_new_block(soap);
					a->ns16__ArrayOfRouteResult::RouteResult = (ns16__RouteResult **)soap_push_block(soap, soap_blist_RouteResult1, sizeof(ns16__RouteResult *));
					if (a->ns16__ArrayOfRouteResult::RouteResult == NULL)
						return NULL;
					*a->ns16__ArrayOfRouteResult::RouteResult = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons16__RouteResult(soap, "ns16:RouteResult", a->ns16__ArrayOfRouteResult::RouteResult, "ns16:RouteResult"))
				{	a->ns16__ArrayOfRouteResult::__sizeRouteResult++;
					a->ns16__ArrayOfRouteResult::RouteResult = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns16__ArrayOfRouteResult::RouteResult)
			soap_pop_block(soap, soap_blist_RouteResult1);
		if (a->ns16__ArrayOfRouteResult::__sizeRouteResult)
			a->ns16__ArrayOfRouteResult::RouteResult = (ns16__RouteResult **)soap_save_block(soap, soap_blist_RouteResult1, NULL, 1);
		else
		{	a->ns16__ArrayOfRouteResult::RouteResult = NULL;
			if (soap_blist_RouteResult1)
				soap_end_block(soap, soap_blist_RouteResult1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__ArrayOfRouteResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__ArrayOfRouteResult, 0, sizeof(ns16__ArrayOfRouteResult), 0, soap_copy_ns16__ArrayOfRouteResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__ArrayOfRouteResult * SOAP_FMAC4 soap_instantiate_ns16__ArrayOfRouteResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__ArrayOfRouteResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__ArrayOfRouteResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__ArrayOfRouteResult;
		if (size)
			*size = sizeof(ns16__ArrayOfRouteResult);
		((ns16__ArrayOfRouteResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__ArrayOfRouteResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__ArrayOfRouteResult);
		for (int i = 0; i < n; i++)
			((ns16__ArrayOfRouteResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__ArrayOfRouteResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__ArrayOfRouteResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__ArrayOfRouteResult %p -> %p\n", q, p));
	*(ns16__ArrayOfRouteResult*)p = *(ns16__ArrayOfRouteResult*)q;
}

void ns16__MajorRoutesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__MajorRoutesResponse::Routes = NULL;
	this->ns16__MajorRoutesResponse::StartingPoints = NULL;
	this->ns4__ResponseBase::ResponseSummary = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__MajorRoutesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons16__ArrayOfRouteResult(soap, &this->ns16__MajorRoutesResponse::Routes);
	soap_serialize_PointerTons16__ArrayOfWaypoint(soap, &this->ns16__MajorRoutesResponse::StartingPoints);
	soap_serialize_PointerTons4__ResponseSummary(soap, &this->ns4__ResponseBase::ResponseSummary);
	/* transient soap skipped */
}

int ns16__MajorRoutesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__MajorRoutesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__MajorRoutesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__MajorRoutesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__MajorRoutesResponse(struct soap *soap, const char *tag, int id, const ns16__MajorRoutesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__MajorRoutesResponse), "ns16:MajorRoutesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__ResponseSummary(soap, "ns4:ResponseSummary", -1, &(a->ns4__ResponseBase::ResponseSummary), ""))
		return soap->error;
	if (soap_out_PointerTons16__ArrayOfRouteResult(soap, "ns16:Routes", -1, &(a->ns16__MajorRoutesResponse::Routes), ""))
		return soap->error;
	if (soap_out_PointerTons16__ArrayOfWaypoint(soap, "ns16:StartingPoints", -1, &(a->ns16__MajorRoutesResponse::StartingPoints), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns16__MajorRoutesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__MajorRoutesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns16__MajorRoutesResponse * SOAP_FMAC4 soap_get_ns16__MajorRoutesResponse(struct soap *soap, ns16__MajorRoutesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__MajorRoutesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__MajorRoutesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__MajorRoutesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns16__MajorRoutesResponse * SOAP_FMAC4 soap_in_ns16__MajorRoutesResponse(struct soap *soap, const char *tag, ns16__MajorRoutesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__MajorRoutesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__MajorRoutesResponse, sizeof(ns16__MajorRoutesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__MajorRoutesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__MajorRoutesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_ResponseSummary2 = 1;
	size_t soap_flag_Routes1 = 1;
	size_t soap_flag_StartingPoints1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ResponseSummary2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ResponseSummary(soap, "ns4:ResponseSummary", &(a->ns4__ResponseBase::ResponseSummary), "ns4:ResponseSummary"))
				{	soap_flag_ResponseSummary2--;
					continue;
				}
			if (soap_flag_Routes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__ArrayOfRouteResult(soap, "ns16:Routes", &(a->ns16__MajorRoutesResponse::Routes), "ns16:ArrayOfRouteResult"))
				{	soap_flag_Routes1--;
					continue;
				}
			if (soap_flag_StartingPoints1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__ArrayOfWaypoint(soap, "ns16:StartingPoints", &(a->ns16__MajorRoutesResponse::StartingPoints), "ns16:ArrayOfWaypoint"))
				{	soap_flag_StartingPoints1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__MajorRoutesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__MajorRoutesResponse, 0, sizeof(ns16__MajorRoutesResponse), 0, soap_copy_ns16__MajorRoutesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__MajorRoutesResponse * SOAP_FMAC4 soap_instantiate_ns16__MajorRoutesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__MajorRoutesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__MajorRoutesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__MajorRoutesResponse;
		if (size)
			*size = sizeof(ns16__MajorRoutesResponse);
		((ns16__MajorRoutesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__MajorRoutesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__MajorRoutesResponse);
		for (int i = 0; i < n; i++)
			((ns16__MajorRoutesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__MajorRoutesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__MajorRoutesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__MajorRoutesResponse %p -> %p\n", q, p));
	*(ns16__MajorRoutesResponse*)p = *(ns16__MajorRoutesResponse*)q;
}

void ns16__MajorRoutesOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__MajorRoutesOptions::ReturnRoutes = NULL;
	this->ns16__RouteOptions::Mode = NULL;
	this->ns16__RouteOptions::Optimization = NULL;
	this->ns16__RouteOptions::RoutePathType = NULL;
	this->ns16__RouteOptions::TrafficUsage = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__MajorRoutesOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &this->ns16__MajorRoutesOptions::ReturnRoutes);
	soap_serialize_PointerTons16__TravelMode(soap, &this->ns16__RouteOptions::Mode);
	soap_serialize_PointerTons16__RouteOptimization(soap, &this->ns16__RouteOptions::Optimization);
	soap_serialize_PointerTons16__RoutePathType(soap, &this->ns16__RouteOptions::RoutePathType);
	soap_serialize_PointerTons16__TrafficUsage(soap, &this->ns16__RouteOptions::TrafficUsage);
	/* transient soap skipped */
}

int ns16__MajorRoutesOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__MajorRoutesOptions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__MajorRoutesOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__MajorRoutesOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__MajorRoutesOptions(struct soap *soap, const char *tag, int id, const ns16__MajorRoutesOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__MajorRoutesOptions), "ns16:MajorRoutesOptions"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons16__TravelMode(soap, "ns16:Mode", -1, &(a->ns16__RouteOptions::Mode), ""))
		return soap->error;
	if (soap_out_PointerTons16__RouteOptimization(soap, "ns16:Optimization", -1, &(a->ns16__RouteOptions::Optimization), ""))
		return soap->error;
	if (soap_out_PointerTons16__RoutePathType(soap, "ns16:RoutePathType", -1, &(a->ns16__RouteOptions::RoutePathType), ""))
		return soap->error;
	if (soap_out_PointerTons16__TrafficUsage(soap, "ns16:TrafficUsage", -1, &(a->ns16__RouteOptions::TrafficUsage), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns16:ReturnRoutes", -1, &(a->ns16__MajorRoutesOptions::ReturnRoutes), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns16__MajorRoutesOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__MajorRoutesOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns16__MajorRoutesOptions * SOAP_FMAC4 soap_get_ns16__MajorRoutesOptions(struct soap *soap, ns16__MajorRoutesOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__MajorRoutesOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__MajorRoutesOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__MajorRoutesOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns16__MajorRoutesOptions * SOAP_FMAC4 soap_in_ns16__MajorRoutesOptions(struct soap *soap, const char *tag, ns16__MajorRoutesOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__MajorRoutesOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__MajorRoutesOptions, sizeof(ns16__MajorRoutesOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__MajorRoutesOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__MajorRoutesOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Mode2 = 1;
	size_t soap_flag_Optimization2 = 1;
	size_t soap_flag_RoutePathType2 = 1;
	size_t soap_flag_TrafficUsage2 = 1;
	size_t soap_flag_ReturnRoutes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Mode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__TravelMode(soap, "ns16:Mode", &(a->ns16__RouteOptions::Mode), "ns16:TravelMode"))
				{	soap_flag_Mode2--;
					continue;
				}
			if (soap_flag_Optimization2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__RouteOptimization(soap, "ns16:Optimization", &(a->ns16__RouteOptions::Optimization), "ns16:RouteOptimization"))
				{	soap_flag_Optimization2--;
					continue;
				}
			if (soap_flag_RoutePathType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__RoutePathType(soap, "ns16:RoutePathType", &(a->ns16__RouteOptions::RoutePathType), "ns16:RoutePathType"))
				{	soap_flag_RoutePathType2--;
					continue;
				}
			if (soap_flag_TrafficUsage2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__TrafficUsage(soap, "ns16:TrafficUsage", &(a->ns16__RouteOptions::TrafficUsage), "ns16:TrafficUsage"))
				{	soap_flag_TrafficUsage2--;
					continue;
				}
			if (soap_flag_ReturnRoutes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns16:ReturnRoutes", &(a->ns16__MajorRoutesOptions::ReturnRoutes), "xsd:boolean"))
				{	soap_flag_ReturnRoutes1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__MajorRoutesOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__MajorRoutesOptions, 0, sizeof(ns16__MajorRoutesOptions), 0, soap_copy_ns16__MajorRoutesOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__MajorRoutesOptions * SOAP_FMAC4 soap_instantiate_ns16__MajorRoutesOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__MajorRoutesOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__MajorRoutesOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__MajorRoutesOptions;
		if (size)
			*size = sizeof(ns16__MajorRoutesOptions);
		((ns16__MajorRoutesOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__MajorRoutesOptions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__MajorRoutesOptions);
		for (int i = 0; i < n; i++)
			((ns16__MajorRoutesOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__MajorRoutesOptions*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__MajorRoutesOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__MajorRoutesOptions %p -> %p\n", q, p));
	*(ns16__MajorRoutesOptions*)p = *(ns16__MajorRoutesOptions*)q;
}

void ns16__MajorRoutesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__MajorRoutesRequest::Destination = NULL;
	this->ns16__MajorRoutesRequest::Options = NULL;
	this->ns4__RequestBase::Credentials = NULL;
	soap_default_string(soap, &this->ns4__RequestBase::Culture);
	this->ns4__RequestBase::ExecutionOptions = NULL;
	this->ns4__RequestBase::UserProfile = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__MajorRoutesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons16__Waypoint(soap, &this->ns16__MajorRoutesRequest::Destination);
	soap_serialize_PointerTons16__MajorRoutesOptions(soap, &this->ns16__MajorRoutesRequest::Options);
	soap_serialize_PointerTons4__Credentials(soap, &this->ns4__RequestBase::Credentials);
	soap_serialize_string(soap, &this->ns4__RequestBase::Culture);
	soap_serialize_PointerTons4__ExecutionOptions(soap, &this->ns4__RequestBase::ExecutionOptions);
	soap_serialize_PointerTons4__UserProfile(soap, &this->ns4__RequestBase::UserProfile);
	/* transient soap skipped */
}

int ns16__MajorRoutesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__MajorRoutesRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__MajorRoutesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__MajorRoutesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__MajorRoutesRequest(struct soap *soap, const char *tag, int id, const ns16__MajorRoutesRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__MajorRoutesRequest), "ns16:MajorRoutesRequest"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Credentials(soap, "ns4:Credentials", -1, &(a->ns4__RequestBase::Credentials), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Culture", -1, &(a->ns4__RequestBase::Culture), ""))
		return soap->error;
	if (soap_out_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", -1, &(a->ns4__RequestBase::ExecutionOptions), ""))
		return soap->error;
	if (soap_out_PointerTons4__UserProfile(soap, "ns4:UserProfile", -1, &(a->ns4__RequestBase::UserProfile), ""))
		return soap->error;
	if (soap_out_PointerTons16__Waypoint(soap, "ns16:Destination", -1, &(a->ns16__MajorRoutesRequest::Destination), ""))
		return soap->error;
	if (soap_out_PointerTons16__MajorRoutesOptions(soap, "ns16:Options", -1, &(a->ns16__MajorRoutesRequest::Options), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns16__MajorRoutesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__MajorRoutesRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns16__MajorRoutesRequest * SOAP_FMAC4 soap_get_ns16__MajorRoutesRequest(struct soap *soap, ns16__MajorRoutesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__MajorRoutesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__MajorRoutesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__MajorRoutesRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns16__MajorRoutesRequest * SOAP_FMAC4 soap_in_ns16__MajorRoutesRequest(struct soap *soap, const char *tag, ns16__MajorRoutesRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__MajorRoutesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__MajorRoutesRequest, sizeof(ns16__MajorRoutesRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__MajorRoutesRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__MajorRoutesRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Credentials2 = 1;
	size_t soap_flag_Culture2 = 1;
	size_t soap_flag_ExecutionOptions2 = 1;
	size_t soap_flag_UserProfile2 = 1;
	size_t soap_flag_Destination1 = 1;
	size_t soap_flag_Options1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Credentials2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Credentials(soap, "ns4:Credentials", &(a->ns4__RequestBase::Credentials), "ns4:Credentials"))
				{	soap_flag_Credentials2--;
					continue;
				}
			if (soap_flag_Culture2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Culture", &(a->ns4__RequestBase::Culture), "xsd:string"))
				{	soap_flag_Culture2--;
					continue;
				}
			if (soap_flag_ExecutionOptions2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", &(a->ns4__RequestBase::ExecutionOptions), "ns4:ExecutionOptions"))
				{	soap_flag_ExecutionOptions2--;
					continue;
				}
			if (soap_flag_UserProfile2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserProfile(soap, "ns4:UserProfile", &(a->ns4__RequestBase::UserProfile), "ns4:UserProfile"))
				{	soap_flag_UserProfile2--;
					continue;
				}
			if (soap_flag_Destination1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__Waypoint(soap, "ns16:Destination", &(a->ns16__MajorRoutesRequest::Destination), "ns16:Waypoint"))
				{	soap_flag_Destination1--;
					continue;
				}
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__MajorRoutesOptions(soap, "ns16:Options", &(a->ns16__MajorRoutesRequest::Options), "ns16:MajorRoutesOptions"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__MajorRoutesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__MajorRoutesRequest, 0, sizeof(ns16__MajorRoutesRequest), 0, soap_copy_ns16__MajorRoutesRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__MajorRoutesRequest * SOAP_FMAC4 soap_instantiate_ns16__MajorRoutesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__MajorRoutesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__MajorRoutesRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__MajorRoutesRequest;
		if (size)
			*size = sizeof(ns16__MajorRoutesRequest);
		((ns16__MajorRoutesRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__MajorRoutesRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__MajorRoutesRequest);
		for (int i = 0; i < n; i++)
			((ns16__MajorRoutesRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__MajorRoutesRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__MajorRoutesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__MajorRoutesRequest %p -> %p\n", q, p));
	*(ns16__MajorRoutesRequest*)p = *(ns16__MajorRoutesRequest*)q;
}

void ns16__RoutePath::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__RoutePath::Points = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__RoutePath::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfLocation(soap, &this->ns16__RoutePath::Points);
	/* transient soap skipped */
}

int ns16__RoutePath::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__RoutePath);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__RoutePath::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__RoutePath(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__RoutePath(struct soap *soap, const char *tag, int id, const ns16__RoutePath *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__RoutePath), "ns16:RoutePath"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__ArrayOfLocation(soap, "ns16:Points", -1, &(a->ns16__RoutePath::Points), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns16__RoutePath::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__RoutePath(soap, this, tag, type);
}

SOAP_FMAC3 ns16__RoutePath * SOAP_FMAC4 soap_get_ns16__RoutePath(struct soap *soap, ns16__RoutePath *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__RoutePath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__RoutePath::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__RoutePath(soap, tag, this, type);
}

SOAP_FMAC3 ns16__RoutePath * SOAP_FMAC4 soap_in_ns16__RoutePath(struct soap *soap, const char *tag, ns16__RoutePath *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__RoutePath *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__RoutePath, sizeof(ns16__RoutePath), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__RoutePath)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__RoutePath *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Points1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Points1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfLocation(soap, "ns16:Points", &(a->ns16__RoutePath::Points), "ns4:ArrayOfLocation"))
				{	soap_flag_Points1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__RoutePath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__RoutePath, 0, sizeof(ns16__RoutePath), 0, soap_copy_ns16__RoutePath);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__RoutePath * SOAP_FMAC4 soap_instantiate_ns16__RoutePath(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__RoutePath(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__RoutePath, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__RoutePath;
		if (size)
			*size = sizeof(ns16__RoutePath);
		((ns16__RoutePath*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__RoutePath[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__RoutePath);
		for (int i = 0; i < n; i++)
			((ns16__RoutePath*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__RoutePath*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__RoutePath(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__RoutePath %p -> %p\n", q, p));
	*(ns16__RoutePath*)p = *(ns16__RoutePath*)q;
}

void ns16__ItineraryItemWarning::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__ItineraryItemWarning::Severity = NULL;
	soap_default_string(soap, &this->ns16__ItineraryItemWarning::Text);
	this->ns16__ItineraryItemWarning::WarningType = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__ItineraryItemWarning::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons16__ItineraryWarningSeverity(soap, &this->ns16__ItineraryItemWarning::Severity);
	soap_serialize_string(soap, &this->ns16__ItineraryItemWarning::Text);
	soap_serialize_PointerTons16__ItineraryWarningType(soap, &this->ns16__ItineraryItemWarning::WarningType);
	/* transient soap skipped */
}

int ns16__ItineraryItemWarning::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__ItineraryItemWarning);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__ItineraryItemWarning::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__ItineraryItemWarning(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ItineraryItemWarning(struct soap *soap, const char *tag, int id, const ns16__ItineraryItemWarning *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__ItineraryItemWarning), "ns16:ItineraryItemWarning"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons16__ItineraryWarningSeverity(soap, "ns16:Severity", -1, &(a->ns16__ItineraryItemWarning::Severity), ""))
		return soap->error;
	if (soap_out_string(soap, "ns16:Text", -1, &(a->ns16__ItineraryItemWarning::Text), ""))
		return soap->error;
	if (soap_out_PointerTons16__ItineraryWarningType(soap, "ns16:WarningType", -1, &(a->ns16__ItineraryItemWarning::WarningType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns16__ItineraryItemWarning::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__ItineraryItemWarning(soap, this, tag, type);
}

SOAP_FMAC3 ns16__ItineraryItemWarning * SOAP_FMAC4 soap_get_ns16__ItineraryItemWarning(struct soap *soap, ns16__ItineraryItemWarning *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ItineraryItemWarning(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__ItineraryItemWarning::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__ItineraryItemWarning(soap, tag, this, type);
}

SOAP_FMAC3 ns16__ItineraryItemWarning * SOAP_FMAC4 soap_in_ns16__ItineraryItemWarning(struct soap *soap, const char *tag, ns16__ItineraryItemWarning *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__ItineraryItemWarning *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ItineraryItemWarning, sizeof(ns16__ItineraryItemWarning), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__ItineraryItemWarning)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__ItineraryItemWarning *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Severity1 = 1;
	size_t soap_flag_Text1 = 1;
	size_t soap_flag_WarningType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Severity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__ItineraryWarningSeverity(soap, "ns16:Severity", &(a->ns16__ItineraryItemWarning::Severity), "ns16:ItineraryWarningSeverity"))
				{	soap_flag_Severity1--;
					continue;
				}
			if (soap_flag_Text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns16:Text", &(a->ns16__ItineraryItemWarning::Text), "xsd:string"))
				{	soap_flag_Text1--;
					continue;
				}
			if (soap_flag_WarningType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__ItineraryWarningType(soap, "ns16:WarningType", &(a->ns16__ItineraryItemWarning::WarningType), "ns16:ItineraryWarningType"))
				{	soap_flag_WarningType1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__ItineraryItemWarning *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__ItineraryItemWarning, 0, sizeof(ns16__ItineraryItemWarning), 0, soap_copy_ns16__ItineraryItemWarning);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__ItineraryItemWarning * SOAP_FMAC4 soap_instantiate_ns16__ItineraryItemWarning(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__ItineraryItemWarning(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__ItineraryItemWarning, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__ItineraryItemWarning;
		if (size)
			*size = sizeof(ns16__ItineraryItemWarning);
		((ns16__ItineraryItemWarning*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__ItineraryItemWarning[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__ItineraryItemWarning);
		for (int i = 0; i < n; i++)
			((ns16__ItineraryItemWarning*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__ItineraryItemWarning*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__ItineraryItemWarning(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__ItineraryItemWarning %p -> %p\n", q, p));
	*(ns16__ItineraryItemWarning*)p = *(ns16__ItineraryItemWarning*)q;
}

void ns16__ArrayOfItineraryItemWarning::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__ArrayOfItineraryItemWarning::__sizeItineraryItemWarning = 0;
	this->ns16__ArrayOfItineraryItemWarning::ItineraryItemWarning = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__ArrayOfItineraryItemWarning::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns16__ArrayOfItineraryItemWarning::ItineraryItemWarning)
	{	int i;
		for (i = 0; i < this->ns16__ArrayOfItineraryItemWarning::__sizeItineraryItemWarning; i++)
		{
			soap_serialize_PointerTons16__ItineraryItemWarning(soap, this->ns16__ArrayOfItineraryItemWarning::ItineraryItemWarning + i);
		}
	}
	/* transient soap skipped */
}

int ns16__ArrayOfItineraryItemWarning::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__ArrayOfItineraryItemWarning);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__ArrayOfItineraryItemWarning::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__ArrayOfItineraryItemWarning(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ArrayOfItineraryItemWarning(struct soap *soap, const char *tag, int id, const ns16__ArrayOfItineraryItemWarning *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__ArrayOfItineraryItemWarning), "ns16:ArrayOfItineraryItemWarning"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns16__ArrayOfItineraryItemWarning::ItineraryItemWarning)
	{	int i;
		for (i = 0; i < a->ns16__ArrayOfItineraryItemWarning::__sizeItineraryItemWarning; i++)
			if (soap_out_PointerTons16__ItineraryItemWarning(soap, "ns16:ItineraryItemWarning", -1, a->ns16__ArrayOfItineraryItemWarning::ItineraryItemWarning + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns16__ArrayOfItineraryItemWarning::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__ArrayOfItineraryItemWarning(soap, this, tag, type);
}

SOAP_FMAC3 ns16__ArrayOfItineraryItemWarning * SOAP_FMAC4 soap_get_ns16__ArrayOfItineraryItemWarning(struct soap *soap, ns16__ArrayOfItineraryItemWarning *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ArrayOfItineraryItemWarning(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__ArrayOfItineraryItemWarning::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__ArrayOfItineraryItemWarning(soap, tag, this, type);
}

SOAP_FMAC3 ns16__ArrayOfItineraryItemWarning * SOAP_FMAC4 soap_in_ns16__ArrayOfItineraryItemWarning(struct soap *soap, const char *tag, ns16__ArrayOfItineraryItemWarning *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__ArrayOfItineraryItemWarning *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ArrayOfItineraryItemWarning, sizeof(ns16__ArrayOfItineraryItemWarning), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__ArrayOfItineraryItemWarning)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__ArrayOfItineraryItemWarning *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_ItineraryItemWarning1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns16:ItineraryItemWarning", 1, NULL))
			{	if (a->ns16__ArrayOfItineraryItemWarning::ItineraryItemWarning == NULL)
				{	if (soap_blist_ItineraryItemWarning1 == NULL)
						soap_blist_ItineraryItemWarning1 = soap_new_block(soap);
					a->ns16__ArrayOfItineraryItemWarning::ItineraryItemWarning = (ns16__ItineraryItemWarning **)soap_push_block(soap, soap_blist_ItineraryItemWarning1, sizeof(ns16__ItineraryItemWarning *));
					if (a->ns16__ArrayOfItineraryItemWarning::ItineraryItemWarning == NULL)
						return NULL;
					*a->ns16__ArrayOfItineraryItemWarning::ItineraryItemWarning = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons16__ItineraryItemWarning(soap, "ns16:ItineraryItemWarning", a->ns16__ArrayOfItineraryItemWarning::ItineraryItemWarning, "ns16:ItineraryItemWarning"))
				{	a->ns16__ArrayOfItineraryItemWarning::__sizeItineraryItemWarning++;
					a->ns16__ArrayOfItineraryItemWarning::ItineraryItemWarning = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns16__ArrayOfItineraryItemWarning::ItineraryItemWarning)
			soap_pop_block(soap, soap_blist_ItineraryItemWarning1);
		if (a->ns16__ArrayOfItineraryItemWarning::__sizeItineraryItemWarning)
			a->ns16__ArrayOfItineraryItemWarning::ItineraryItemWarning = (ns16__ItineraryItemWarning **)soap_save_block(soap, soap_blist_ItineraryItemWarning1, NULL, 1);
		else
		{	a->ns16__ArrayOfItineraryItemWarning::ItineraryItemWarning = NULL;
			if (soap_blist_ItineraryItemWarning1)
				soap_end_block(soap, soap_blist_ItineraryItemWarning1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__ArrayOfItineraryItemWarning *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__ArrayOfItineraryItemWarning, 0, sizeof(ns16__ArrayOfItineraryItemWarning), 0, soap_copy_ns16__ArrayOfItineraryItemWarning);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__ArrayOfItineraryItemWarning * SOAP_FMAC4 soap_instantiate_ns16__ArrayOfItineraryItemWarning(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__ArrayOfItineraryItemWarning(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__ArrayOfItineraryItemWarning, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__ArrayOfItineraryItemWarning;
		if (size)
			*size = sizeof(ns16__ArrayOfItineraryItemWarning);
		((ns16__ArrayOfItineraryItemWarning*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__ArrayOfItineraryItemWarning[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__ArrayOfItineraryItemWarning);
		for (int i = 0; i < n; i++)
			((ns16__ArrayOfItineraryItemWarning*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__ArrayOfItineraryItemWarning*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__ArrayOfItineraryItemWarning(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__ArrayOfItineraryItemWarning %p -> %p\n", q, p));
	*(ns16__ArrayOfItineraryItemWarning*)p = *(ns16__ArrayOfItineraryItemWarning*)q;
}

void ns16__RouteSummary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__RouteSummary::BoundingRectangle = NULL;
	this->ns16__RouteSummary::Distance = NULL;
	this->ns16__RouteSummary::TimeInSeconds = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__RouteSummary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Rectangle(soap, &this->ns16__RouteSummary::BoundingRectangle);
	soap_serialize_PointerTodouble(soap, &this->ns16__RouteSummary::Distance);
	soap_serialize_PointerToLONG64(soap, &this->ns16__RouteSummary::TimeInSeconds);
	/* transient soap skipped */
}

int ns16__RouteSummary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__RouteSummary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__RouteSummary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__RouteSummary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__RouteSummary(struct soap *soap, const char *tag, int id, const ns16__RouteSummary *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__RouteSummary), "ns16:RouteSummary"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Rectangle(soap, "ns16:BoundingRectangle", -1, &(a->ns16__RouteSummary::BoundingRectangle), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns16:Distance", -1, &(a->ns16__RouteSummary::Distance), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "ns16:TimeInSeconds", -1, &(a->ns16__RouteSummary::TimeInSeconds), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns16__RouteSummary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__RouteSummary(soap, this, tag, type);
}

SOAP_FMAC3 ns16__RouteSummary * SOAP_FMAC4 soap_get_ns16__RouteSummary(struct soap *soap, ns16__RouteSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__RouteSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__RouteSummary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__RouteSummary(soap, tag, this, type);
}

SOAP_FMAC3 ns16__RouteSummary * SOAP_FMAC4 soap_in_ns16__RouteSummary(struct soap *soap, const char *tag, ns16__RouteSummary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__RouteSummary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__RouteSummary, sizeof(ns16__RouteSummary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__RouteSummary)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__RouteSummary *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_BoundingRectangle1 = 1;
	size_t soap_flag_Distance1 = 1;
	size_t soap_flag_TimeInSeconds1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_BoundingRectangle1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Rectangle(soap, "ns16:BoundingRectangle", &(a->ns16__RouteSummary::BoundingRectangle), "ns4:Rectangle"))
				{	soap_flag_BoundingRectangle1--;
					continue;
				}
			if (soap_flag_Distance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns16:Distance", &(a->ns16__RouteSummary::Distance), "xsd:double"))
				{	soap_flag_Distance1--;
					continue;
				}
			if (soap_flag_TimeInSeconds1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns16:TimeInSeconds", &(a->ns16__RouteSummary::TimeInSeconds), "xsd:long"))
				{	soap_flag_TimeInSeconds1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__RouteSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__RouteSummary, 0, sizeof(ns16__RouteSummary), 0, soap_copy_ns16__RouteSummary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__RouteSummary * SOAP_FMAC4 soap_instantiate_ns16__RouteSummary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__RouteSummary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__RouteSummary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__RouteSummary;
		if (size)
			*size = sizeof(ns16__RouteSummary);
		((ns16__RouteSummary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__RouteSummary[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__RouteSummary);
		for (int i = 0; i < n; i++)
			((ns16__RouteSummary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__RouteSummary*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__RouteSummary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__RouteSummary %p -> %p\n", q, p));
	*(ns16__RouteSummary*)p = *(ns16__RouteSummary*)q;
}

void ns16__ItineraryItemHint::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__ItineraryItemHint::HintType = NULL;
	soap_default_string(soap, &this->ns16__ItineraryItemHint::Text);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__ItineraryItemHint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons16__ItineraryItemHintType(soap, &this->ns16__ItineraryItemHint::HintType);
	soap_serialize_string(soap, &this->ns16__ItineraryItemHint::Text);
	/* transient soap skipped */
}

int ns16__ItineraryItemHint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__ItineraryItemHint);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__ItineraryItemHint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__ItineraryItemHint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ItineraryItemHint(struct soap *soap, const char *tag, int id, const ns16__ItineraryItemHint *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__ItineraryItemHint), "ns16:ItineraryItemHint"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons16__ItineraryItemHintType(soap, "ns16:HintType", -1, &(a->ns16__ItineraryItemHint::HintType), ""))
		return soap->error;
	if (soap_out_string(soap, "ns16:Text", -1, &(a->ns16__ItineraryItemHint::Text), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns16__ItineraryItemHint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__ItineraryItemHint(soap, this, tag, type);
}

SOAP_FMAC3 ns16__ItineraryItemHint * SOAP_FMAC4 soap_get_ns16__ItineraryItemHint(struct soap *soap, ns16__ItineraryItemHint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ItineraryItemHint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__ItineraryItemHint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__ItineraryItemHint(soap, tag, this, type);
}

SOAP_FMAC3 ns16__ItineraryItemHint * SOAP_FMAC4 soap_in_ns16__ItineraryItemHint(struct soap *soap, const char *tag, ns16__ItineraryItemHint *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__ItineraryItemHint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ItineraryItemHint, sizeof(ns16__ItineraryItemHint), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__ItineraryItemHint)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__ItineraryItemHint *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_HintType1 = 1;
	size_t soap_flag_Text1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_HintType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__ItineraryItemHintType(soap, "ns16:HintType", &(a->ns16__ItineraryItemHint::HintType), "ns16:ItineraryItemHintType"))
				{	soap_flag_HintType1--;
					continue;
				}
			if (soap_flag_Text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns16:Text", &(a->ns16__ItineraryItemHint::Text), "xsd:string"))
				{	soap_flag_Text1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__ItineraryItemHint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__ItineraryItemHint, 0, sizeof(ns16__ItineraryItemHint), 0, soap_copy_ns16__ItineraryItemHint);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__ItineraryItemHint * SOAP_FMAC4 soap_instantiate_ns16__ItineraryItemHint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__ItineraryItemHint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__ItineraryItemHint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__ItineraryItemHint;
		if (size)
			*size = sizeof(ns16__ItineraryItemHint);
		((ns16__ItineraryItemHint*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__ItineraryItemHint[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__ItineraryItemHint);
		for (int i = 0; i < n; i++)
			((ns16__ItineraryItemHint*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__ItineraryItemHint*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__ItineraryItemHint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__ItineraryItemHint %p -> %p\n", q, p));
	*(ns16__ItineraryItemHint*)p = *(ns16__ItineraryItemHint*)q;
}

void ns16__ArrayOfItineraryItemHint::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__ArrayOfItineraryItemHint::__sizeItineraryItemHint = 0;
	this->ns16__ArrayOfItineraryItemHint::ItineraryItemHint = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__ArrayOfItineraryItemHint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns16__ArrayOfItineraryItemHint::ItineraryItemHint)
	{	int i;
		for (i = 0; i < this->ns16__ArrayOfItineraryItemHint::__sizeItineraryItemHint; i++)
		{
			soap_serialize_PointerTons16__ItineraryItemHint(soap, this->ns16__ArrayOfItineraryItemHint::ItineraryItemHint + i);
		}
	}
	/* transient soap skipped */
}

int ns16__ArrayOfItineraryItemHint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__ArrayOfItineraryItemHint);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__ArrayOfItineraryItemHint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__ArrayOfItineraryItemHint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ArrayOfItineraryItemHint(struct soap *soap, const char *tag, int id, const ns16__ArrayOfItineraryItemHint *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__ArrayOfItineraryItemHint), "ns16:ArrayOfItineraryItemHint"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns16__ArrayOfItineraryItemHint::ItineraryItemHint)
	{	int i;
		for (i = 0; i < a->ns16__ArrayOfItineraryItemHint::__sizeItineraryItemHint; i++)
			if (soap_out_PointerTons16__ItineraryItemHint(soap, "ns16:ItineraryItemHint", -1, a->ns16__ArrayOfItineraryItemHint::ItineraryItemHint + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns16__ArrayOfItineraryItemHint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__ArrayOfItineraryItemHint(soap, this, tag, type);
}

SOAP_FMAC3 ns16__ArrayOfItineraryItemHint * SOAP_FMAC4 soap_get_ns16__ArrayOfItineraryItemHint(struct soap *soap, ns16__ArrayOfItineraryItemHint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ArrayOfItineraryItemHint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__ArrayOfItineraryItemHint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__ArrayOfItineraryItemHint(soap, tag, this, type);
}

SOAP_FMAC3 ns16__ArrayOfItineraryItemHint * SOAP_FMAC4 soap_in_ns16__ArrayOfItineraryItemHint(struct soap *soap, const char *tag, ns16__ArrayOfItineraryItemHint *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__ArrayOfItineraryItemHint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ArrayOfItineraryItemHint, sizeof(ns16__ArrayOfItineraryItemHint), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__ArrayOfItineraryItemHint)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__ArrayOfItineraryItemHint *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_ItineraryItemHint1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns16:ItineraryItemHint", 1, NULL))
			{	if (a->ns16__ArrayOfItineraryItemHint::ItineraryItemHint == NULL)
				{	if (soap_blist_ItineraryItemHint1 == NULL)
						soap_blist_ItineraryItemHint1 = soap_new_block(soap);
					a->ns16__ArrayOfItineraryItemHint::ItineraryItemHint = (ns16__ItineraryItemHint **)soap_push_block(soap, soap_blist_ItineraryItemHint1, sizeof(ns16__ItineraryItemHint *));
					if (a->ns16__ArrayOfItineraryItemHint::ItineraryItemHint == NULL)
						return NULL;
					*a->ns16__ArrayOfItineraryItemHint::ItineraryItemHint = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons16__ItineraryItemHint(soap, "ns16:ItineraryItemHint", a->ns16__ArrayOfItineraryItemHint::ItineraryItemHint, "ns16:ItineraryItemHint"))
				{	a->ns16__ArrayOfItineraryItemHint::__sizeItineraryItemHint++;
					a->ns16__ArrayOfItineraryItemHint::ItineraryItemHint = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns16__ArrayOfItineraryItemHint::ItineraryItemHint)
			soap_pop_block(soap, soap_blist_ItineraryItemHint1);
		if (a->ns16__ArrayOfItineraryItemHint::__sizeItineraryItemHint)
			a->ns16__ArrayOfItineraryItemHint::ItineraryItemHint = (ns16__ItineraryItemHint **)soap_save_block(soap, soap_blist_ItineraryItemHint1, NULL, 1);
		else
		{	a->ns16__ArrayOfItineraryItemHint::ItineraryItemHint = NULL;
			if (soap_blist_ItineraryItemHint1)
				soap_end_block(soap, soap_blist_ItineraryItemHint1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__ArrayOfItineraryItemHint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__ArrayOfItineraryItemHint, 0, sizeof(ns16__ArrayOfItineraryItemHint), 0, soap_copy_ns16__ArrayOfItineraryItemHint);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__ArrayOfItineraryItemHint * SOAP_FMAC4 soap_instantiate_ns16__ArrayOfItineraryItemHint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__ArrayOfItineraryItemHint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__ArrayOfItineraryItemHint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__ArrayOfItineraryItemHint;
		if (size)
			*size = sizeof(ns16__ArrayOfItineraryItemHint);
		((ns16__ArrayOfItineraryItemHint*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__ArrayOfItineraryItemHint[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__ArrayOfItineraryItemHint);
		for (int i = 0; i < n; i++)
			((ns16__ArrayOfItineraryItemHint*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__ArrayOfItineraryItemHint*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__ArrayOfItineraryItemHint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__ArrayOfItineraryItemHint %p -> %p\n", q, p));
	*(ns16__ArrayOfItineraryItemHint*)p = *(ns16__ArrayOfItineraryItemHint*)q;
}

void ns16__ItineraryItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns16__ItineraryItem::CompassDirection);
	this->ns16__ItineraryItem::Hints = NULL;
	this->ns16__ItineraryItem::Location = NULL;
	this->ns16__ItineraryItem::ManeuverType = NULL;
	this->ns16__ItineraryItem::Summary = NULL;
	soap_default_string(soap, &this->ns16__ItineraryItem::Text);
	this->ns16__ItineraryItem::Warnings = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__ItineraryItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns16__ItineraryItem::CompassDirection);
	soap_serialize_PointerTons16__ArrayOfItineraryItemHint(soap, &this->ns16__ItineraryItem::Hints);
	soap_serialize_PointerTons4__Location(soap, &this->ns16__ItineraryItem::Location);
	soap_serialize_PointerTons16__ManeuverType(soap, &this->ns16__ItineraryItem::ManeuverType);
	soap_serialize_PointerTons16__RouteSummary(soap, &this->ns16__ItineraryItem::Summary);
	soap_serialize_string(soap, &this->ns16__ItineraryItem::Text);
	soap_serialize_PointerTons16__ArrayOfItineraryItemWarning(soap, &this->ns16__ItineraryItem::Warnings);
	/* transient soap skipped */
}

int ns16__ItineraryItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__ItineraryItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__ItineraryItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__ItineraryItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ItineraryItem(struct soap *soap, const char *tag, int id, const ns16__ItineraryItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__ItineraryItem), "ns16:ItineraryItem"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns16:CompassDirection", -1, &(a->ns16__ItineraryItem::CompassDirection), ""))
		return soap->error;
	if (soap_out_PointerTons16__ArrayOfItineraryItemHint(soap, "ns16:Hints", -1, &(a->ns16__ItineraryItem::Hints), ""))
		return soap->error;
	if (soap_out_PointerTons4__Location(soap, "ns16:Location", -1, &(a->ns16__ItineraryItem::Location), ""))
		return soap->error;
	if (soap_out_PointerTons16__ManeuverType(soap, "ns16:ManeuverType", -1, &(a->ns16__ItineraryItem::ManeuverType), ""))
		return soap->error;
	if (soap_out_PointerTons16__RouteSummary(soap, "ns16:Summary", -1, &(a->ns16__ItineraryItem::Summary), ""))
		return soap->error;
	if (soap_out_string(soap, "ns16:Text", -1, &(a->ns16__ItineraryItem::Text), ""))
		return soap->error;
	if (soap_out_PointerTons16__ArrayOfItineraryItemWarning(soap, "ns16:Warnings", -1, &(a->ns16__ItineraryItem::Warnings), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns16__ItineraryItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__ItineraryItem(soap, this, tag, type);
}

SOAP_FMAC3 ns16__ItineraryItem * SOAP_FMAC4 soap_get_ns16__ItineraryItem(struct soap *soap, ns16__ItineraryItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ItineraryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__ItineraryItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__ItineraryItem(soap, tag, this, type);
}

SOAP_FMAC3 ns16__ItineraryItem * SOAP_FMAC4 soap_in_ns16__ItineraryItem(struct soap *soap, const char *tag, ns16__ItineraryItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__ItineraryItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ItineraryItem, sizeof(ns16__ItineraryItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__ItineraryItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__ItineraryItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_CompassDirection1 = 1;
	size_t soap_flag_Hints1 = 1;
	size_t soap_flag_Location1 = 1;
	size_t soap_flag_ManeuverType1 = 1;
	size_t soap_flag_Summary1 = 1;
	size_t soap_flag_Text1 = 1;
	size_t soap_flag_Warnings1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_CompassDirection1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns16:CompassDirection", &(a->ns16__ItineraryItem::CompassDirection), "xsd:string"))
				{	soap_flag_CompassDirection1--;
					continue;
				}
			if (soap_flag_Hints1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__ArrayOfItineraryItemHint(soap, "ns16:Hints", &(a->ns16__ItineraryItem::Hints), "ns16:ArrayOfItineraryItemHint"))
				{	soap_flag_Hints1--;
					continue;
				}
			if (soap_flag_Location1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Location(soap, "ns16:Location", &(a->ns16__ItineraryItem::Location), "ns4:Location"))
				{	soap_flag_Location1--;
					continue;
				}
			if (soap_flag_ManeuverType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__ManeuverType(soap, "ns16:ManeuverType", &(a->ns16__ItineraryItem::ManeuverType), "ns16:ManeuverType"))
				{	soap_flag_ManeuverType1--;
					continue;
				}
			if (soap_flag_Summary1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__RouteSummary(soap, "ns16:Summary", &(a->ns16__ItineraryItem::Summary), "ns16:RouteSummary"))
				{	soap_flag_Summary1--;
					continue;
				}
			if (soap_flag_Text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns16:Text", &(a->ns16__ItineraryItem::Text), "xsd:string"))
				{	soap_flag_Text1--;
					continue;
				}
			if (soap_flag_Warnings1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__ArrayOfItineraryItemWarning(soap, "ns16:Warnings", &(a->ns16__ItineraryItem::Warnings), "ns16:ArrayOfItineraryItemWarning"))
				{	soap_flag_Warnings1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__ItineraryItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__ItineraryItem, 0, sizeof(ns16__ItineraryItem), 0, soap_copy_ns16__ItineraryItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__ItineraryItem * SOAP_FMAC4 soap_instantiate_ns16__ItineraryItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__ItineraryItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__ItineraryItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__ItineraryItem;
		if (size)
			*size = sizeof(ns16__ItineraryItem);
		((ns16__ItineraryItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__ItineraryItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__ItineraryItem);
		for (int i = 0; i < n; i++)
			((ns16__ItineraryItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__ItineraryItem*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__ItineraryItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__ItineraryItem %p -> %p\n", q, p));
	*(ns16__ItineraryItem*)p = *(ns16__ItineraryItem*)q;
}

void ns16__ArrayOfItineraryItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__ArrayOfItineraryItem::__sizeItineraryItem = 0;
	this->ns16__ArrayOfItineraryItem::ItineraryItem = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__ArrayOfItineraryItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns16__ArrayOfItineraryItem::ItineraryItem)
	{	int i;
		for (i = 0; i < this->ns16__ArrayOfItineraryItem::__sizeItineraryItem; i++)
		{
			soap_serialize_PointerTons16__ItineraryItem(soap, this->ns16__ArrayOfItineraryItem::ItineraryItem + i);
		}
	}
	/* transient soap skipped */
}

int ns16__ArrayOfItineraryItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__ArrayOfItineraryItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__ArrayOfItineraryItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__ArrayOfItineraryItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ArrayOfItineraryItem(struct soap *soap, const char *tag, int id, const ns16__ArrayOfItineraryItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__ArrayOfItineraryItem), "ns16:ArrayOfItineraryItem"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns16__ArrayOfItineraryItem::ItineraryItem)
	{	int i;
		for (i = 0; i < a->ns16__ArrayOfItineraryItem::__sizeItineraryItem; i++)
			if (soap_out_PointerTons16__ItineraryItem(soap, "ns16:ItineraryItem", -1, a->ns16__ArrayOfItineraryItem::ItineraryItem + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns16__ArrayOfItineraryItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__ArrayOfItineraryItem(soap, this, tag, type);
}

SOAP_FMAC3 ns16__ArrayOfItineraryItem * SOAP_FMAC4 soap_get_ns16__ArrayOfItineraryItem(struct soap *soap, ns16__ArrayOfItineraryItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ArrayOfItineraryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__ArrayOfItineraryItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__ArrayOfItineraryItem(soap, tag, this, type);
}

SOAP_FMAC3 ns16__ArrayOfItineraryItem * SOAP_FMAC4 soap_in_ns16__ArrayOfItineraryItem(struct soap *soap, const char *tag, ns16__ArrayOfItineraryItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__ArrayOfItineraryItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ArrayOfItineraryItem, sizeof(ns16__ArrayOfItineraryItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__ArrayOfItineraryItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__ArrayOfItineraryItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_ItineraryItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns16:ItineraryItem", 1, NULL))
			{	if (a->ns16__ArrayOfItineraryItem::ItineraryItem == NULL)
				{	if (soap_blist_ItineraryItem1 == NULL)
						soap_blist_ItineraryItem1 = soap_new_block(soap);
					a->ns16__ArrayOfItineraryItem::ItineraryItem = (ns16__ItineraryItem **)soap_push_block(soap, soap_blist_ItineraryItem1, sizeof(ns16__ItineraryItem *));
					if (a->ns16__ArrayOfItineraryItem::ItineraryItem == NULL)
						return NULL;
					*a->ns16__ArrayOfItineraryItem::ItineraryItem = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons16__ItineraryItem(soap, "ns16:ItineraryItem", a->ns16__ArrayOfItineraryItem::ItineraryItem, "ns16:ItineraryItem"))
				{	a->ns16__ArrayOfItineraryItem::__sizeItineraryItem++;
					a->ns16__ArrayOfItineraryItem::ItineraryItem = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns16__ArrayOfItineraryItem::ItineraryItem)
			soap_pop_block(soap, soap_blist_ItineraryItem1);
		if (a->ns16__ArrayOfItineraryItem::__sizeItineraryItem)
			a->ns16__ArrayOfItineraryItem::ItineraryItem = (ns16__ItineraryItem **)soap_save_block(soap, soap_blist_ItineraryItem1, NULL, 1);
		else
		{	a->ns16__ArrayOfItineraryItem::ItineraryItem = NULL;
			if (soap_blist_ItineraryItem1)
				soap_end_block(soap, soap_blist_ItineraryItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__ArrayOfItineraryItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__ArrayOfItineraryItem, 0, sizeof(ns16__ArrayOfItineraryItem), 0, soap_copy_ns16__ArrayOfItineraryItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__ArrayOfItineraryItem * SOAP_FMAC4 soap_instantiate_ns16__ArrayOfItineraryItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__ArrayOfItineraryItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__ArrayOfItineraryItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__ArrayOfItineraryItem;
		if (size)
			*size = sizeof(ns16__ArrayOfItineraryItem);
		((ns16__ArrayOfItineraryItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__ArrayOfItineraryItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__ArrayOfItineraryItem);
		for (int i = 0; i < n; i++)
			((ns16__ArrayOfItineraryItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__ArrayOfItineraryItem*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__ArrayOfItineraryItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__ArrayOfItineraryItem %p -> %p\n", q, p));
	*(ns16__ArrayOfItineraryItem*)p = *(ns16__ArrayOfItineraryItem*)q;
}

void ns16__RouteLeg::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__RouteLeg::ActualEnd = NULL;
	this->ns16__RouteLeg::ActualStart = NULL;
	this->ns16__RouteLeg::Itinerary = NULL;
	this->ns16__RouteLeg::Summary = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__RouteLeg::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Location(soap, &this->ns16__RouteLeg::ActualEnd);
	soap_serialize_PointerTons4__Location(soap, &this->ns16__RouteLeg::ActualStart);
	soap_serialize_PointerTons16__ArrayOfItineraryItem(soap, &this->ns16__RouteLeg::Itinerary);
	soap_serialize_PointerTons16__RouteSummary(soap, &this->ns16__RouteLeg::Summary);
	/* transient soap skipped */
}

int ns16__RouteLeg::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__RouteLeg);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__RouteLeg::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__RouteLeg(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__RouteLeg(struct soap *soap, const char *tag, int id, const ns16__RouteLeg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__RouteLeg), "ns16:RouteLeg"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Location(soap, "ns16:ActualEnd", -1, &(a->ns16__RouteLeg::ActualEnd), ""))
		return soap->error;
	if (soap_out_PointerTons4__Location(soap, "ns16:ActualStart", -1, &(a->ns16__RouteLeg::ActualStart), ""))
		return soap->error;
	if (soap_out_PointerTons16__ArrayOfItineraryItem(soap, "ns16:Itinerary", -1, &(a->ns16__RouteLeg::Itinerary), ""))
		return soap->error;
	if (soap_out_PointerTons16__RouteSummary(soap, "ns16:Summary", -1, &(a->ns16__RouteLeg::Summary), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns16__RouteLeg::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__RouteLeg(soap, this, tag, type);
}

SOAP_FMAC3 ns16__RouteLeg * SOAP_FMAC4 soap_get_ns16__RouteLeg(struct soap *soap, ns16__RouteLeg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__RouteLeg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__RouteLeg::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__RouteLeg(soap, tag, this, type);
}

SOAP_FMAC3 ns16__RouteLeg * SOAP_FMAC4 soap_in_ns16__RouteLeg(struct soap *soap, const char *tag, ns16__RouteLeg *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__RouteLeg *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__RouteLeg, sizeof(ns16__RouteLeg), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__RouteLeg)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__RouteLeg *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ActualEnd1 = 1;
	size_t soap_flag_ActualStart1 = 1;
	size_t soap_flag_Itinerary1 = 1;
	size_t soap_flag_Summary1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ActualEnd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Location(soap, "ns16:ActualEnd", &(a->ns16__RouteLeg::ActualEnd), "ns4:Location"))
				{	soap_flag_ActualEnd1--;
					continue;
				}
			if (soap_flag_ActualStart1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Location(soap, "ns16:ActualStart", &(a->ns16__RouteLeg::ActualStart), "ns4:Location"))
				{	soap_flag_ActualStart1--;
					continue;
				}
			if (soap_flag_Itinerary1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__ArrayOfItineraryItem(soap, "ns16:Itinerary", &(a->ns16__RouteLeg::Itinerary), "ns16:ArrayOfItineraryItem"))
				{	soap_flag_Itinerary1--;
					continue;
				}
			if (soap_flag_Summary1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__RouteSummary(soap, "ns16:Summary", &(a->ns16__RouteLeg::Summary), "ns16:RouteSummary"))
				{	soap_flag_Summary1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__RouteLeg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__RouteLeg, 0, sizeof(ns16__RouteLeg), 0, soap_copy_ns16__RouteLeg);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__RouteLeg * SOAP_FMAC4 soap_instantiate_ns16__RouteLeg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__RouteLeg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__RouteLeg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__RouteLeg;
		if (size)
			*size = sizeof(ns16__RouteLeg);
		((ns16__RouteLeg*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__RouteLeg[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__RouteLeg);
		for (int i = 0; i < n; i++)
			((ns16__RouteLeg*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__RouteLeg*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__RouteLeg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__RouteLeg %p -> %p\n", q, p));
	*(ns16__RouteLeg*)p = *(ns16__RouteLeg*)q;
}

void ns16__ArrayOfRouteLeg::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__ArrayOfRouteLeg::__sizeRouteLeg = 0;
	this->ns16__ArrayOfRouteLeg::RouteLeg = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__ArrayOfRouteLeg::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns16__ArrayOfRouteLeg::RouteLeg)
	{	int i;
		for (i = 0; i < this->ns16__ArrayOfRouteLeg::__sizeRouteLeg; i++)
		{
			soap_serialize_PointerTons16__RouteLeg(soap, this->ns16__ArrayOfRouteLeg::RouteLeg + i);
		}
	}
	/* transient soap skipped */
}

int ns16__ArrayOfRouteLeg::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__ArrayOfRouteLeg);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__ArrayOfRouteLeg::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__ArrayOfRouteLeg(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ArrayOfRouteLeg(struct soap *soap, const char *tag, int id, const ns16__ArrayOfRouteLeg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__ArrayOfRouteLeg), "ns16:ArrayOfRouteLeg"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns16__ArrayOfRouteLeg::RouteLeg)
	{	int i;
		for (i = 0; i < a->ns16__ArrayOfRouteLeg::__sizeRouteLeg; i++)
			if (soap_out_PointerTons16__RouteLeg(soap, "ns16:RouteLeg", -1, a->ns16__ArrayOfRouteLeg::RouteLeg + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns16__ArrayOfRouteLeg::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__ArrayOfRouteLeg(soap, this, tag, type);
}

SOAP_FMAC3 ns16__ArrayOfRouteLeg * SOAP_FMAC4 soap_get_ns16__ArrayOfRouteLeg(struct soap *soap, ns16__ArrayOfRouteLeg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ArrayOfRouteLeg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__ArrayOfRouteLeg::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__ArrayOfRouteLeg(soap, tag, this, type);
}

SOAP_FMAC3 ns16__ArrayOfRouteLeg * SOAP_FMAC4 soap_in_ns16__ArrayOfRouteLeg(struct soap *soap, const char *tag, ns16__ArrayOfRouteLeg *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__ArrayOfRouteLeg *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ArrayOfRouteLeg, sizeof(ns16__ArrayOfRouteLeg), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__ArrayOfRouteLeg)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__ArrayOfRouteLeg *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_RouteLeg1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns16:RouteLeg", 1, NULL))
			{	if (a->ns16__ArrayOfRouteLeg::RouteLeg == NULL)
				{	if (soap_blist_RouteLeg1 == NULL)
						soap_blist_RouteLeg1 = soap_new_block(soap);
					a->ns16__ArrayOfRouteLeg::RouteLeg = (ns16__RouteLeg **)soap_push_block(soap, soap_blist_RouteLeg1, sizeof(ns16__RouteLeg *));
					if (a->ns16__ArrayOfRouteLeg::RouteLeg == NULL)
						return NULL;
					*a->ns16__ArrayOfRouteLeg::RouteLeg = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons16__RouteLeg(soap, "ns16:RouteLeg", a->ns16__ArrayOfRouteLeg::RouteLeg, "ns16:RouteLeg"))
				{	a->ns16__ArrayOfRouteLeg::__sizeRouteLeg++;
					a->ns16__ArrayOfRouteLeg::RouteLeg = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns16__ArrayOfRouteLeg::RouteLeg)
			soap_pop_block(soap, soap_blist_RouteLeg1);
		if (a->ns16__ArrayOfRouteLeg::__sizeRouteLeg)
			a->ns16__ArrayOfRouteLeg::RouteLeg = (ns16__RouteLeg **)soap_save_block(soap, soap_blist_RouteLeg1, NULL, 1);
		else
		{	a->ns16__ArrayOfRouteLeg::RouteLeg = NULL;
			if (soap_blist_RouteLeg1)
				soap_end_block(soap, soap_blist_RouteLeg1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__ArrayOfRouteLeg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__ArrayOfRouteLeg, 0, sizeof(ns16__ArrayOfRouteLeg), 0, soap_copy_ns16__ArrayOfRouteLeg);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__ArrayOfRouteLeg * SOAP_FMAC4 soap_instantiate_ns16__ArrayOfRouteLeg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__ArrayOfRouteLeg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__ArrayOfRouteLeg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__ArrayOfRouteLeg;
		if (size)
			*size = sizeof(ns16__ArrayOfRouteLeg);
		((ns16__ArrayOfRouteLeg*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__ArrayOfRouteLeg[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__ArrayOfRouteLeg);
		for (int i = 0; i < n; i++)
			((ns16__ArrayOfRouteLeg*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__ArrayOfRouteLeg*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__ArrayOfRouteLeg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__ArrayOfRouteLeg %p -> %p\n", q, p));
	*(ns16__ArrayOfRouteLeg*)p = *(ns16__ArrayOfRouteLeg*)q;
}

void ns16__RouteResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__RouteResult::Legs = NULL;
	this->ns16__RouteResult::RoutePath = NULL;
	this->ns16__RouteResult::Summary = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__RouteResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons16__ArrayOfRouteLeg(soap, &this->ns16__RouteResult::Legs);
	soap_serialize_PointerTons16__RoutePath(soap, &this->ns16__RouteResult::RoutePath);
	soap_serialize_PointerTons16__RouteSummary(soap, &this->ns16__RouteResult::Summary);
	/* transient soap skipped */
}

int ns16__RouteResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__RouteResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__RouteResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__RouteResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__RouteResult(struct soap *soap, const char *tag, int id, const ns16__RouteResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__RouteResult), "ns16:RouteResult"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons16__ArrayOfRouteLeg(soap, "ns16:Legs", -1, &(a->ns16__RouteResult::Legs), ""))
		return soap->error;
	if (soap_out_PointerTons16__RoutePath(soap, "ns16:RoutePath", -1, &(a->ns16__RouteResult::RoutePath), ""))
		return soap->error;
	if (soap_out_PointerTons16__RouteSummary(soap, "ns16:Summary", -1, &(a->ns16__RouteResult::Summary), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns16__RouteResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__RouteResult(soap, this, tag, type);
}

SOAP_FMAC3 ns16__RouteResult * SOAP_FMAC4 soap_get_ns16__RouteResult(struct soap *soap, ns16__RouteResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__RouteResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__RouteResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__RouteResult(soap, tag, this, type);
}

SOAP_FMAC3 ns16__RouteResult * SOAP_FMAC4 soap_in_ns16__RouteResult(struct soap *soap, const char *tag, ns16__RouteResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__RouteResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__RouteResult, sizeof(ns16__RouteResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__RouteResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__RouteResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Legs1 = 1;
	size_t soap_flag_RoutePath1 = 1;
	size_t soap_flag_Summary1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Legs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__ArrayOfRouteLeg(soap, "ns16:Legs", &(a->ns16__RouteResult::Legs), "ns16:ArrayOfRouteLeg"))
				{	soap_flag_Legs1--;
					continue;
				}
			if (soap_flag_RoutePath1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__RoutePath(soap, "ns16:RoutePath", &(a->ns16__RouteResult::RoutePath), "ns16:RoutePath"))
				{	soap_flag_RoutePath1--;
					continue;
				}
			if (soap_flag_Summary1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__RouteSummary(soap, "ns16:Summary", &(a->ns16__RouteResult::Summary), "ns16:RouteSummary"))
				{	soap_flag_Summary1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__RouteResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__RouteResult, 0, sizeof(ns16__RouteResult), 0, soap_copy_ns16__RouteResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__RouteResult * SOAP_FMAC4 soap_instantiate_ns16__RouteResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__RouteResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__RouteResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__RouteResult;
		if (size)
			*size = sizeof(ns16__RouteResult);
		((ns16__RouteResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__RouteResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__RouteResult);
		for (int i = 0; i < n; i++)
			((ns16__RouteResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__RouteResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__RouteResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__RouteResult %p -> %p\n", q, p));
	*(ns16__RouteResult*)p = *(ns16__RouteResult*)q;
}

void ns16__RouteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__RouteResponse::Result = NULL;
	this->ns4__ResponseBase::ResponseSummary = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__RouteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons16__RouteResult(soap, &this->ns16__RouteResponse::Result);
	soap_serialize_PointerTons4__ResponseSummary(soap, &this->ns4__ResponseBase::ResponseSummary);
	/* transient soap skipped */
}

int ns16__RouteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__RouteResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__RouteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__RouteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__RouteResponse(struct soap *soap, const char *tag, int id, const ns16__RouteResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__RouteResponse), "ns16:RouteResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__ResponseSummary(soap, "ns4:ResponseSummary", -1, &(a->ns4__ResponseBase::ResponseSummary), ""))
		return soap->error;
	if (soap_out_PointerTons16__RouteResult(soap, "ns16:Result", -1, &(a->ns16__RouteResponse::Result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns16__RouteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__RouteResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns16__RouteResponse * SOAP_FMAC4 soap_get_ns16__RouteResponse(struct soap *soap, ns16__RouteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__RouteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__RouteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__RouteResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns16__RouteResponse * SOAP_FMAC4 soap_in_ns16__RouteResponse(struct soap *soap, const char *tag, ns16__RouteResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__RouteResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__RouteResponse, sizeof(ns16__RouteResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__RouteResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__RouteResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_ResponseSummary2 = 1;
	size_t soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ResponseSummary2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ResponseSummary(soap, "ns4:ResponseSummary", &(a->ns4__ResponseBase::ResponseSummary), "ns4:ResponseSummary"))
				{	soap_flag_ResponseSummary2--;
					continue;
				}
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__RouteResult(soap, "ns16:Result", &(a->ns16__RouteResponse::Result), "ns16:RouteResult"))
				{	soap_flag_Result1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__RouteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__RouteResponse, 0, sizeof(ns16__RouteResponse), 0, soap_copy_ns16__RouteResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__RouteResponse * SOAP_FMAC4 soap_instantiate_ns16__RouteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__RouteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__RouteResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__RouteResponse;
		if (size)
			*size = sizeof(ns16__RouteResponse);
		((ns16__RouteResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__RouteResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__RouteResponse);
		for (int i = 0; i < n; i++)
			((ns16__RouteResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__RouteResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__RouteResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__RouteResponse %p -> %p\n", q, p));
	*(ns16__RouteResponse*)p = *(ns16__RouteResponse*)q;
}

void ns16__Waypoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns16__Waypoint::Description);
	this->ns16__Waypoint::Location = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__Waypoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns16__Waypoint::Description);
	soap_serialize_PointerTons4__Location(soap, &this->ns16__Waypoint::Location);
	/* transient soap skipped */
}

int ns16__Waypoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__Waypoint);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__Waypoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__Waypoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__Waypoint(struct soap *soap, const char *tag, int id, const ns16__Waypoint *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__Waypoint), "ns16:Waypoint"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns16:Description", -1, &(a->ns16__Waypoint::Description), ""))
		return soap->error;
	if (soap_out_PointerTons4__Location(soap, "ns16:Location", -1, &(a->ns16__Waypoint::Location), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns16__Waypoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__Waypoint(soap, this, tag, type);
}

SOAP_FMAC3 ns16__Waypoint * SOAP_FMAC4 soap_get_ns16__Waypoint(struct soap *soap, ns16__Waypoint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__Waypoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__Waypoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__Waypoint(soap, tag, this, type);
}

SOAP_FMAC3 ns16__Waypoint * SOAP_FMAC4 soap_in_ns16__Waypoint(struct soap *soap, const char *tag, ns16__Waypoint *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__Waypoint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__Waypoint, sizeof(ns16__Waypoint), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__Waypoint)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__Waypoint *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_Location1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns16:Description", &(a->ns16__Waypoint::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_Location1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Location(soap, "ns16:Location", &(a->ns16__Waypoint::Location), "ns4:Location"))
				{	soap_flag_Location1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__Waypoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__Waypoint, 0, sizeof(ns16__Waypoint), 0, soap_copy_ns16__Waypoint);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__Waypoint * SOAP_FMAC4 soap_instantiate_ns16__Waypoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__Waypoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__Waypoint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__Waypoint;
		if (size)
			*size = sizeof(ns16__Waypoint);
		((ns16__Waypoint*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__Waypoint[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__Waypoint);
		for (int i = 0; i < n; i++)
			((ns16__Waypoint*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__Waypoint*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__Waypoint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__Waypoint %p -> %p\n", q, p));
	*(ns16__Waypoint*)p = *(ns16__Waypoint*)q;
}

void ns16__ArrayOfWaypoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__ArrayOfWaypoint::__sizeWaypoint = 0;
	this->ns16__ArrayOfWaypoint::Waypoint = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__ArrayOfWaypoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns16__ArrayOfWaypoint::Waypoint)
	{	int i;
		for (i = 0; i < this->ns16__ArrayOfWaypoint::__sizeWaypoint; i++)
		{
			soap_serialize_PointerTons16__Waypoint(soap, this->ns16__ArrayOfWaypoint::Waypoint + i);
		}
	}
	/* transient soap skipped */
}

int ns16__ArrayOfWaypoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__ArrayOfWaypoint);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__ArrayOfWaypoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__ArrayOfWaypoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__ArrayOfWaypoint(struct soap *soap, const char *tag, int id, const ns16__ArrayOfWaypoint *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__ArrayOfWaypoint), "ns16:ArrayOfWaypoint"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns16__ArrayOfWaypoint::Waypoint)
	{	int i;
		for (i = 0; i < a->ns16__ArrayOfWaypoint::__sizeWaypoint; i++)
			if (soap_out_PointerTons16__Waypoint(soap, "ns16:Waypoint", -1, a->ns16__ArrayOfWaypoint::Waypoint + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns16__ArrayOfWaypoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__ArrayOfWaypoint(soap, this, tag, type);
}

SOAP_FMAC3 ns16__ArrayOfWaypoint * SOAP_FMAC4 soap_get_ns16__ArrayOfWaypoint(struct soap *soap, ns16__ArrayOfWaypoint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__ArrayOfWaypoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__ArrayOfWaypoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__ArrayOfWaypoint(soap, tag, this, type);
}

SOAP_FMAC3 ns16__ArrayOfWaypoint * SOAP_FMAC4 soap_in_ns16__ArrayOfWaypoint(struct soap *soap, const char *tag, ns16__ArrayOfWaypoint *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__ArrayOfWaypoint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__ArrayOfWaypoint, sizeof(ns16__ArrayOfWaypoint), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__ArrayOfWaypoint)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__ArrayOfWaypoint *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_Waypoint1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns16:Waypoint", 1, NULL))
			{	if (a->ns16__ArrayOfWaypoint::Waypoint == NULL)
				{	if (soap_blist_Waypoint1 == NULL)
						soap_blist_Waypoint1 = soap_new_block(soap);
					a->ns16__ArrayOfWaypoint::Waypoint = (ns16__Waypoint **)soap_push_block(soap, soap_blist_Waypoint1, sizeof(ns16__Waypoint *));
					if (a->ns16__ArrayOfWaypoint::Waypoint == NULL)
						return NULL;
					*a->ns16__ArrayOfWaypoint::Waypoint = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons16__Waypoint(soap, "ns16:Waypoint", a->ns16__ArrayOfWaypoint::Waypoint, "ns16:Waypoint"))
				{	a->ns16__ArrayOfWaypoint::__sizeWaypoint++;
					a->ns16__ArrayOfWaypoint::Waypoint = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns16__ArrayOfWaypoint::Waypoint)
			soap_pop_block(soap, soap_blist_Waypoint1);
		if (a->ns16__ArrayOfWaypoint::__sizeWaypoint)
			a->ns16__ArrayOfWaypoint::Waypoint = (ns16__Waypoint **)soap_save_block(soap, soap_blist_Waypoint1, NULL, 1);
		else
		{	a->ns16__ArrayOfWaypoint::Waypoint = NULL;
			if (soap_blist_Waypoint1)
				soap_end_block(soap, soap_blist_Waypoint1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__ArrayOfWaypoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__ArrayOfWaypoint, 0, sizeof(ns16__ArrayOfWaypoint), 0, soap_copy_ns16__ArrayOfWaypoint);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__ArrayOfWaypoint * SOAP_FMAC4 soap_instantiate_ns16__ArrayOfWaypoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__ArrayOfWaypoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__ArrayOfWaypoint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__ArrayOfWaypoint;
		if (size)
			*size = sizeof(ns16__ArrayOfWaypoint);
		((ns16__ArrayOfWaypoint*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__ArrayOfWaypoint[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__ArrayOfWaypoint);
		for (int i = 0; i < n; i++)
			((ns16__ArrayOfWaypoint*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__ArrayOfWaypoint*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__ArrayOfWaypoint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__ArrayOfWaypoint %p -> %p\n", q, p));
	*(ns16__ArrayOfWaypoint*)p = *(ns16__ArrayOfWaypoint*)q;
}

void ns16__RouteOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__RouteOptions::Mode = NULL;
	this->ns16__RouteOptions::Optimization = NULL;
	this->ns16__RouteOptions::RoutePathType = NULL;
	this->ns16__RouteOptions::TrafficUsage = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__RouteOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons16__TravelMode(soap, &this->ns16__RouteOptions::Mode);
	soap_serialize_PointerTons16__RouteOptimization(soap, &this->ns16__RouteOptions::Optimization);
	soap_serialize_PointerTons16__RoutePathType(soap, &this->ns16__RouteOptions::RoutePathType);
	soap_serialize_PointerTons16__TrafficUsage(soap, &this->ns16__RouteOptions::TrafficUsage);
	/* transient soap skipped */
}

int ns16__RouteOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__RouteOptions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__RouteOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__RouteOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__RouteOptions(struct soap *soap, const char *tag, int id, const ns16__RouteOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__RouteOptions), "ns16:RouteOptions"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons16__TravelMode(soap, "ns16:Mode", -1, &(a->ns16__RouteOptions::Mode), ""))
		return soap->error;
	if (soap_out_PointerTons16__RouteOptimization(soap, "ns16:Optimization", -1, &(a->ns16__RouteOptions::Optimization), ""))
		return soap->error;
	if (soap_out_PointerTons16__RoutePathType(soap, "ns16:RoutePathType", -1, &(a->ns16__RouteOptions::RoutePathType), ""))
		return soap->error;
	if (soap_out_PointerTons16__TrafficUsage(soap, "ns16:TrafficUsage", -1, &(a->ns16__RouteOptions::TrafficUsage), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns16__RouteOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__RouteOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns16__RouteOptions * SOAP_FMAC4 soap_get_ns16__RouteOptions(struct soap *soap, ns16__RouteOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__RouteOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__RouteOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__RouteOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns16__RouteOptions * SOAP_FMAC4 soap_in_ns16__RouteOptions(struct soap *soap, const char *tag, ns16__RouteOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__RouteOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__RouteOptions, sizeof(ns16__RouteOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__RouteOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__RouteOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Optimization1 = 1;
	size_t soap_flag_RoutePathType1 = 1;
	size_t soap_flag_TrafficUsage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__TravelMode(soap, "ns16:Mode", &(a->ns16__RouteOptions::Mode), "ns16:TravelMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			if (soap_flag_Optimization1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__RouteOptimization(soap, "ns16:Optimization", &(a->ns16__RouteOptions::Optimization), "ns16:RouteOptimization"))
				{	soap_flag_Optimization1--;
					continue;
				}
			if (soap_flag_RoutePathType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__RoutePathType(soap, "ns16:RoutePathType", &(a->ns16__RouteOptions::RoutePathType), "ns16:RoutePathType"))
				{	soap_flag_RoutePathType1--;
					continue;
				}
			if (soap_flag_TrafficUsage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__TrafficUsage(soap, "ns16:TrafficUsage", &(a->ns16__RouteOptions::TrafficUsage), "ns16:TrafficUsage"))
				{	soap_flag_TrafficUsage1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__RouteOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__RouteOptions, 0, sizeof(ns16__RouteOptions), 0, soap_copy_ns16__RouteOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__RouteOptions * SOAP_FMAC4 soap_instantiate_ns16__RouteOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__RouteOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__RouteOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns16:MajorRoutesOptions"))
	{	cp->type = SOAP_TYPE_ns16__MajorRoutesOptions;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__MajorRoutesOptions;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__MajorRoutesOptions);
			((ns16__MajorRoutesOptions*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__MajorRoutesOptions[n];
			if (size)
				*size = n * sizeof(ns16__MajorRoutesOptions);
			for (int i = 0; i < n; i++)
				((ns16__MajorRoutesOptions*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__MajorRoutesOptions*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns16__RouteOptions;
		if (size)
			*size = sizeof(ns16__RouteOptions);
		((ns16__RouteOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__RouteOptions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__RouteOptions);
		for (int i = 0; i < n; i++)
			((ns16__RouteOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__RouteOptions*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__RouteOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__RouteOptions %p -> %p\n", q, p));
	*(ns16__RouteOptions*)p = *(ns16__RouteOptions*)q;
}

void ns16__RouteRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns16__RouteRequest::Options = NULL;
	this->ns16__RouteRequest::Waypoints = NULL;
	this->ns4__RequestBase::Credentials = NULL;
	soap_default_string(soap, &this->ns4__RequestBase::Culture);
	this->ns4__RequestBase::ExecutionOptions = NULL;
	this->ns4__RequestBase::UserProfile = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns16__RouteRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons16__RouteOptions(soap, &this->ns16__RouteRequest::Options);
	soap_serialize_PointerTons16__ArrayOfWaypoint(soap, &this->ns16__RouteRequest::Waypoints);
	soap_serialize_PointerTons4__Credentials(soap, &this->ns4__RequestBase::Credentials);
	soap_serialize_string(soap, &this->ns4__RequestBase::Culture);
	soap_serialize_PointerTons4__ExecutionOptions(soap, &this->ns4__RequestBase::ExecutionOptions);
	soap_serialize_PointerTons4__UserProfile(soap, &this->ns4__RequestBase::UserProfile);
	/* transient soap skipped */
}

int ns16__RouteRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__RouteRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__RouteRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__RouteRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__RouteRequest(struct soap *soap, const char *tag, int id, const ns16__RouteRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__RouteRequest), "ns16:RouteRequest"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Credentials(soap, "ns4:Credentials", -1, &(a->ns4__RequestBase::Credentials), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Culture", -1, &(a->ns4__RequestBase::Culture), ""))
		return soap->error;
	if (soap_out_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", -1, &(a->ns4__RequestBase::ExecutionOptions), ""))
		return soap->error;
	if (soap_out_PointerTons4__UserProfile(soap, "ns4:UserProfile", -1, &(a->ns4__RequestBase::UserProfile), ""))
		return soap->error;
	if (soap_out_PointerTons16__RouteOptions(soap, "ns16:Options", -1, &(a->ns16__RouteRequest::Options), ""))
		return soap->error;
	if (soap_out_PointerTons16__ArrayOfWaypoint(soap, "ns16:Waypoints", -1, &(a->ns16__RouteRequest::Waypoints), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns16__RouteRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__RouteRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns16__RouteRequest * SOAP_FMAC4 soap_get_ns16__RouteRequest(struct soap *soap, ns16__RouteRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__RouteRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns16__RouteRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__RouteRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns16__RouteRequest * SOAP_FMAC4 soap_in_ns16__RouteRequest(struct soap *soap, const char *tag, ns16__RouteRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__RouteRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__RouteRequest, sizeof(ns16__RouteRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__RouteRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__RouteRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Credentials2 = 1;
	size_t soap_flag_Culture2 = 1;
	size_t soap_flag_ExecutionOptions2 = 1;
	size_t soap_flag_UserProfile2 = 1;
	size_t soap_flag_Options1 = 1;
	size_t soap_flag_Waypoints1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Credentials2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Credentials(soap, "ns4:Credentials", &(a->ns4__RequestBase::Credentials), "ns4:Credentials"))
				{	soap_flag_Credentials2--;
					continue;
				}
			if (soap_flag_Culture2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Culture", &(a->ns4__RequestBase::Culture), "xsd:string"))
				{	soap_flag_Culture2--;
					continue;
				}
			if (soap_flag_ExecutionOptions2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", &(a->ns4__RequestBase::ExecutionOptions), "ns4:ExecutionOptions"))
				{	soap_flag_ExecutionOptions2--;
					continue;
				}
			if (soap_flag_UserProfile2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserProfile(soap, "ns4:UserProfile", &(a->ns4__RequestBase::UserProfile), "ns4:UserProfile"))
				{	soap_flag_UserProfile2--;
					continue;
				}
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__RouteOptions(soap, "ns16:Options", &(a->ns16__RouteRequest::Options), "ns16:RouteOptions"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap_flag_Waypoints1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__ArrayOfWaypoint(soap, "ns16:Waypoints", &(a->ns16__RouteRequest::Waypoints), "ns16:ArrayOfWaypoint"))
				{	soap_flag_Waypoints1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__RouteRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns16__RouteRequest, 0, sizeof(ns16__RouteRequest), 0, soap_copy_ns16__RouteRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns16__RouteRequest * SOAP_FMAC4 soap_instantiate_ns16__RouteRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__RouteRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__RouteRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__RouteRequest;
		if (size)
			*size = sizeof(ns16__RouteRequest);
		((ns16__RouteRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__RouteRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns16__RouteRequest);
		for (int i = 0; i < n; i++)
			((ns16__RouteRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__RouteRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__RouteRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__RouteRequest %p -> %p\n", q, p));
	*(ns16__RouteRequest*)p = *(ns16__RouteRequest*)q;
}

void _ns15__CalculateRoutesFromMajorRoadsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns15__CalculateRoutesFromMajorRoadsResponse::CalculateRoutesFromMajorRoadsResult = NULL;
	/* transient soap skipped */
}

void _ns15__CalculateRoutesFromMajorRoadsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons16__MajorRoutesResponse(soap, &this->_ns15__CalculateRoutesFromMajorRoadsResponse::CalculateRoutesFromMajorRoadsResult);
	/* transient soap skipped */
}

int _ns15__CalculateRoutesFromMajorRoadsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoadsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns15__CalculateRoutesFromMajorRoadsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns15__CalculateRoutesFromMajorRoadsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns15__CalculateRoutesFromMajorRoadsResponse(struct soap *soap, const char *tag, int id, const _ns15__CalculateRoutesFromMajorRoadsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoadsResponse), type))
		return soap->error;
	if (a->CalculateRoutesFromMajorRoadsResult)
		soap_element_result(soap, "ns15:CalculateRoutesFromMajorRoadsResult");
	if (soap_out_PointerTons16__MajorRoutesResponse(soap, "ns15:CalculateRoutesFromMajorRoadsResult", -1, &(a->_ns15__CalculateRoutesFromMajorRoadsResponse::CalculateRoutesFromMajorRoadsResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns15__CalculateRoutesFromMajorRoadsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns15__CalculateRoutesFromMajorRoadsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns15__CalculateRoutesFromMajorRoadsResponse * SOAP_FMAC4 soap_get__ns15__CalculateRoutesFromMajorRoadsResponse(struct soap *soap, _ns15__CalculateRoutesFromMajorRoadsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns15__CalculateRoutesFromMajorRoadsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns15__CalculateRoutesFromMajorRoadsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns15__CalculateRoutesFromMajorRoadsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns15__CalculateRoutesFromMajorRoadsResponse * SOAP_FMAC4 soap_in__ns15__CalculateRoutesFromMajorRoadsResponse(struct soap *soap, const char *tag, _ns15__CalculateRoutesFromMajorRoadsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns15__CalculateRoutesFromMajorRoadsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoadsResponse, sizeof(_ns15__CalculateRoutesFromMajorRoadsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns15__CalculateRoutesFromMajorRoadsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns15__CalculateRoutesFromMajorRoadsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CalculateRoutesFromMajorRoadsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CalculateRoutesFromMajorRoadsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__MajorRoutesResponse(soap, "ns15:CalculateRoutesFromMajorRoadsResult", &(a->_ns15__CalculateRoutesFromMajorRoadsResponse::CalculateRoutesFromMajorRoadsResult), "ns16:MajorRoutesResponse"))
				{	soap_flag_CalculateRoutesFromMajorRoadsResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns15:CalculateRoutesFromMajorRoadsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns15__CalculateRoutesFromMajorRoadsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoadsResponse, 0, sizeof(_ns15__CalculateRoutesFromMajorRoadsResponse), 0, soap_copy__ns15__CalculateRoutesFromMajorRoadsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns15__CalculateRoutesFromMajorRoadsResponse * SOAP_FMAC4 soap_instantiate__ns15__CalculateRoutesFromMajorRoadsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns15__CalculateRoutesFromMajorRoadsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoadsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns15__CalculateRoutesFromMajorRoadsResponse;
		if (size)
			*size = sizeof(_ns15__CalculateRoutesFromMajorRoadsResponse);
		((_ns15__CalculateRoutesFromMajorRoadsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns15__CalculateRoutesFromMajorRoadsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns15__CalculateRoutesFromMajorRoadsResponse);
		for (int i = 0; i < n; i++)
			((_ns15__CalculateRoutesFromMajorRoadsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns15__CalculateRoutesFromMajorRoadsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns15__CalculateRoutesFromMajorRoadsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns15__CalculateRoutesFromMajorRoadsResponse %p -> %p\n", q, p));
	*(_ns15__CalculateRoutesFromMajorRoadsResponse*)p = *(_ns15__CalculateRoutesFromMajorRoadsResponse*)q;
}

void _ns15__CalculateRoutesFromMajorRoads::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns15__CalculateRoutesFromMajorRoads::request = NULL;
	/* transient soap skipped */
}

void _ns15__CalculateRoutesFromMajorRoads::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons16__MajorRoutesRequest(soap, &this->_ns15__CalculateRoutesFromMajorRoads::request);
	/* transient soap skipped */
}

int _ns15__CalculateRoutesFromMajorRoads::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoads);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns15__CalculateRoutesFromMajorRoads::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns15__CalculateRoutesFromMajorRoads(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns15__CalculateRoutesFromMajorRoads(struct soap *soap, const char *tag, int id, const _ns15__CalculateRoutesFromMajorRoads *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoads), type))
		return soap->error;
	if (soap_out_PointerTons16__MajorRoutesRequest(soap, "ns15:request", -1, &(a->_ns15__CalculateRoutesFromMajorRoads::request), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns15__CalculateRoutesFromMajorRoads::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns15__CalculateRoutesFromMajorRoads(soap, this, tag, type);
}

SOAP_FMAC3 _ns15__CalculateRoutesFromMajorRoads * SOAP_FMAC4 soap_get__ns15__CalculateRoutesFromMajorRoads(struct soap *soap, _ns15__CalculateRoutesFromMajorRoads *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns15__CalculateRoutesFromMajorRoads(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns15__CalculateRoutesFromMajorRoads::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns15__CalculateRoutesFromMajorRoads(soap, tag, this, type);
}

SOAP_FMAC3 _ns15__CalculateRoutesFromMajorRoads * SOAP_FMAC4 soap_in__ns15__CalculateRoutesFromMajorRoads(struct soap *soap, const char *tag, _ns15__CalculateRoutesFromMajorRoads *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns15__CalculateRoutesFromMajorRoads *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoads, sizeof(_ns15__CalculateRoutesFromMajorRoads), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns15__CalculateRoutesFromMajorRoads)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns15__CalculateRoutesFromMajorRoads *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_request1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__MajorRoutesRequest(soap, "ns15:request", &(a->_ns15__CalculateRoutesFromMajorRoads::request), "ns16:MajorRoutesRequest"))
				{	soap_flag_request1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns15__CalculateRoutesFromMajorRoads *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoads, 0, sizeof(_ns15__CalculateRoutesFromMajorRoads), 0, soap_copy__ns15__CalculateRoutesFromMajorRoads);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns15__CalculateRoutesFromMajorRoads * SOAP_FMAC4 soap_instantiate__ns15__CalculateRoutesFromMajorRoads(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns15__CalculateRoutesFromMajorRoads(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoads, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns15__CalculateRoutesFromMajorRoads;
		if (size)
			*size = sizeof(_ns15__CalculateRoutesFromMajorRoads);
		((_ns15__CalculateRoutesFromMajorRoads*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns15__CalculateRoutesFromMajorRoads[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns15__CalculateRoutesFromMajorRoads);
		for (int i = 0; i < n; i++)
			((_ns15__CalculateRoutesFromMajorRoads*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns15__CalculateRoutesFromMajorRoads*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns15__CalculateRoutesFromMajorRoads(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns15__CalculateRoutesFromMajorRoads %p -> %p\n", q, p));
	*(_ns15__CalculateRoutesFromMajorRoads*)p = *(_ns15__CalculateRoutesFromMajorRoads*)q;
}

void _ns15__CalculateRouteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns15__CalculateRouteResponse::CalculateRouteResult = NULL;
	/* transient soap skipped */
}

void _ns15__CalculateRouteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons16__RouteResponse(soap, &this->_ns15__CalculateRouteResponse::CalculateRouteResult);
	/* transient soap skipped */
}

int _ns15__CalculateRouteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns15__CalculateRouteResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns15__CalculateRouteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns15__CalculateRouteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns15__CalculateRouteResponse(struct soap *soap, const char *tag, int id, const _ns15__CalculateRouteResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns15__CalculateRouteResponse), type))
		return soap->error;
	if (a->CalculateRouteResult)
		soap_element_result(soap, "ns15:CalculateRouteResult");
	if (soap_out_PointerTons16__RouteResponse(soap, "ns15:CalculateRouteResult", -1, &(a->_ns15__CalculateRouteResponse::CalculateRouteResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns15__CalculateRouteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns15__CalculateRouteResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns15__CalculateRouteResponse * SOAP_FMAC4 soap_get__ns15__CalculateRouteResponse(struct soap *soap, _ns15__CalculateRouteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns15__CalculateRouteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns15__CalculateRouteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns15__CalculateRouteResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns15__CalculateRouteResponse * SOAP_FMAC4 soap_in__ns15__CalculateRouteResponse(struct soap *soap, const char *tag, _ns15__CalculateRouteResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns15__CalculateRouteResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns15__CalculateRouteResponse, sizeof(_ns15__CalculateRouteResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns15__CalculateRouteResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns15__CalculateRouteResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CalculateRouteResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CalculateRouteResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__RouteResponse(soap, "ns15:CalculateRouteResult", &(a->_ns15__CalculateRouteResponse::CalculateRouteResult), "ns16:RouteResponse"))
				{	soap_flag_CalculateRouteResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns15:CalculateRouteResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns15__CalculateRouteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns15__CalculateRouteResponse, 0, sizeof(_ns15__CalculateRouteResponse), 0, soap_copy__ns15__CalculateRouteResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns15__CalculateRouteResponse * SOAP_FMAC4 soap_instantiate__ns15__CalculateRouteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns15__CalculateRouteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns15__CalculateRouteResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns15__CalculateRouteResponse;
		if (size)
			*size = sizeof(_ns15__CalculateRouteResponse);
		((_ns15__CalculateRouteResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns15__CalculateRouteResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns15__CalculateRouteResponse);
		for (int i = 0; i < n; i++)
			((_ns15__CalculateRouteResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns15__CalculateRouteResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns15__CalculateRouteResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns15__CalculateRouteResponse %p -> %p\n", q, p));
	*(_ns15__CalculateRouteResponse*)p = *(_ns15__CalculateRouteResponse*)q;
}

void _ns15__CalculateRoute::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns15__CalculateRoute::request = NULL;
	/* transient soap skipped */
}

void _ns15__CalculateRoute::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons16__RouteRequest(soap, &this->_ns15__CalculateRoute::request);
	/* transient soap skipped */
}

int _ns15__CalculateRoute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns15__CalculateRoute);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns15__CalculateRoute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns15__CalculateRoute(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns15__CalculateRoute(struct soap *soap, const char *tag, int id, const _ns15__CalculateRoute *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns15__CalculateRoute), type))
		return soap->error;
	if (soap_out_PointerTons16__RouteRequest(soap, "ns15:request", -1, &(a->_ns15__CalculateRoute::request), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns15__CalculateRoute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns15__CalculateRoute(soap, this, tag, type);
}

SOAP_FMAC3 _ns15__CalculateRoute * SOAP_FMAC4 soap_get__ns15__CalculateRoute(struct soap *soap, _ns15__CalculateRoute *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns15__CalculateRoute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns15__CalculateRoute::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns15__CalculateRoute(soap, tag, this, type);
}

SOAP_FMAC3 _ns15__CalculateRoute * SOAP_FMAC4 soap_in__ns15__CalculateRoute(struct soap *soap, const char *tag, _ns15__CalculateRoute *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns15__CalculateRoute *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns15__CalculateRoute, sizeof(_ns15__CalculateRoute), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns15__CalculateRoute)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns15__CalculateRoute *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_request1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons16__RouteRequest(soap, "ns15:request", &(a->_ns15__CalculateRoute::request), "ns16:RouteRequest"))
				{	soap_flag_request1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns15__CalculateRoute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns15__CalculateRoute, 0, sizeof(_ns15__CalculateRoute), 0, soap_copy__ns15__CalculateRoute);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns15__CalculateRoute * SOAP_FMAC4 soap_instantiate__ns15__CalculateRoute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns15__CalculateRoute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns15__CalculateRoute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns15__CalculateRoute;
		if (size)
			*size = sizeof(_ns15__CalculateRoute);
		((_ns15__CalculateRoute*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns15__CalculateRoute[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns15__CalculateRoute);
		for (int i = 0; i < n; i++)
			((_ns15__CalculateRoute*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns15__CalculateRoute*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns15__CalculateRoute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns15__CalculateRoute %p -> %p\n", q, p));
	*(_ns15__CalculateRoute*)p = *(_ns15__CalculateRoute*)q;
}

void ns13__MapUriResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns13__MapUriResponse::Uri);
	this->ns4__ResponseBase::ResponseSummary = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns13__MapUriResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns13__MapUriResponse::Uri);
	soap_serialize_PointerTons4__ResponseSummary(soap, &this->ns4__ResponseBase::ResponseSummary);
	/* transient soap skipped */
}

int ns13__MapUriResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns13__MapUriResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns13__MapUriResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns13__MapUriResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns13__MapUriResponse(struct soap *soap, const char *tag, int id, const ns13__MapUriResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns13__MapUriResponse), "ns13:MapUriResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__ResponseSummary(soap, "ns4:ResponseSummary", -1, &(a->ns4__ResponseBase::ResponseSummary), ""))
		return soap->error;
	if (soap_out_string(soap, "ns13:Uri", -1, &(a->ns13__MapUriResponse::Uri), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns13__MapUriResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns13__MapUriResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns13__MapUriResponse * SOAP_FMAC4 soap_get_ns13__MapUriResponse(struct soap *soap, ns13__MapUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns13__MapUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns13__MapUriResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns13__MapUriResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns13__MapUriResponse * SOAP_FMAC4 soap_in_ns13__MapUriResponse(struct soap *soap, const char *tag, ns13__MapUriResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns13__MapUriResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns13__MapUriResponse, sizeof(ns13__MapUriResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns13__MapUriResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns13__MapUriResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_ResponseSummary2 = 1;
	size_t soap_flag_Uri1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ResponseSummary2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ResponseSummary(soap, "ns4:ResponseSummary", &(a->ns4__ResponseBase::ResponseSummary), "ns4:ResponseSummary"))
				{	soap_flag_ResponseSummary2--;
					continue;
				}
			if (soap_flag_Uri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns13:Uri", &(a->ns13__MapUriResponse::Uri), "xsd:string"))
				{	soap_flag_Uri1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns13__MapUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns13__MapUriResponse, 0, sizeof(ns13__MapUriResponse), 0, soap_copy_ns13__MapUriResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns13__MapUriResponse * SOAP_FMAC4 soap_instantiate_ns13__MapUriResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns13__MapUriResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns13__MapUriResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns13__MapUriResponse;
		if (size)
			*size = sizeof(ns13__MapUriResponse);
		((ns13__MapUriResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns13__MapUriResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns13__MapUriResponse);
		for (int i = 0; i < n; i++)
			((ns13__MapUriResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns13__MapUriResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns13__MapUriResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns13__MapUriResponse %p -> %p\n", q, p));
	*(ns13__MapUriResponse*)p = *(ns13__MapUriResponse*)q;
}

void ns13__MapUriOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns13__MapUriOptions::DisplayLayers = NULL;
	this->ns13__MapUriOptions::ImageSize = NULL;
	this->ns13__MapUriOptions::ImageType = NULL;
	this->ns13__MapUriOptions::PreventIconCollision = NULL;
	this->ns13__MapUriOptions::Style = NULL;
	this->ns13__MapUriOptions::UriScheme = NULL;
	this->ns13__MapUriOptions::ZoomLevel = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns13__MapUriOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons7__ArrayOfstring(soap, &this->ns13__MapUriOptions::DisplayLayers);
	soap_serialize_PointerTons4__SizeOfint(soap, &this->ns13__MapUriOptions::ImageSize);
	soap_serialize_PointerTons4__ImageType(soap, &this->ns13__MapUriOptions::ImageType);
	soap_serialize_PointerTobool(soap, &this->ns13__MapUriOptions::PreventIconCollision);
	soap_serialize_PointerTons4__MapStyle(soap, &this->ns13__MapUriOptions::Style);
	soap_serialize_PointerTons4__UriScheme(soap, &this->ns13__MapUriOptions::UriScheme);
	soap_serialize_PointerToint(soap, &this->ns13__MapUriOptions::ZoomLevel);
	/* transient soap skipped */
}

int ns13__MapUriOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns13__MapUriOptions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns13__MapUriOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns13__MapUriOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns13__MapUriOptions(struct soap *soap, const char *tag, int id, const ns13__MapUriOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns13__MapUriOptions), "ns13:MapUriOptions"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons7__ArrayOfstring(soap, "ns13:DisplayLayers", -1, &(a->ns13__MapUriOptions::DisplayLayers), ""))
		return soap->error;
	if (soap_out_PointerTons4__SizeOfint(soap, "ns13:ImageSize", -1, &(a->ns13__MapUriOptions::ImageSize), ""))
		return soap->error;
	if (soap_out_PointerTons4__ImageType(soap, "ns13:ImageType", -1, &(a->ns13__MapUriOptions::ImageType), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns13:PreventIconCollision", -1, &(a->ns13__MapUriOptions::PreventIconCollision), ""))
		return soap->error;
	if (soap_out_PointerTons4__MapStyle(soap, "ns13:Style", -1, &(a->ns13__MapUriOptions::Style), ""))
		return soap->error;
	if (soap_out_PointerTons4__UriScheme(soap, "ns13:UriScheme", -1, &(a->ns13__MapUriOptions::UriScheme), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns13:ZoomLevel", -1, &(a->ns13__MapUriOptions::ZoomLevel), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns13__MapUriOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns13__MapUriOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns13__MapUriOptions * SOAP_FMAC4 soap_get_ns13__MapUriOptions(struct soap *soap, ns13__MapUriOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns13__MapUriOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns13__MapUriOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns13__MapUriOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns13__MapUriOptions * SOAP_FMAC4 soap_in_ns13__MapUriOptions(struct soap *soap, const char *tag, ns13__MapUriOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns13__MapUriOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns13__MapUriOptions, sizeof(ns13__MapUriOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns13__MapUriOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns13__MapUriOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_DisplayLayers1 = 1;
	size_t soap_flag_ImageSize1 = 1;
	size_t soap_flag_ImageType1 = 1;
	size_t soap_flag_PreventIconCollision1 = 1;
	size_t soap_flag_Style1 = 1;
	size_t soap_flag_UriScheme1 = 1;
	size_t soap_flag_ZoomLevel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DisplayLayers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ArrayOfstring(soap, "ns13:DisplayLayers", &(a->ns13__MapUriOptions::DisplayLayers), "ns7:ArrayOfstring"))
				{	soap_flag_DisplayLayers1--;
					continue;
				}
			if (soap_flag_ImageSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SizeOfint(soap, "ns13:ImageSize", &(a->ns13__MapUriOptions::ImageSize), "ns4:SizeOfint"))
				{	soap_flag_ImageSize1--;
					continue;
				}
			if (soap_flag_ImageType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ImageType(soap, "ns13:ImageType", &(a->ns13__MapUriOptions::ImageType), "ns4:ImageType"))
				{	soap_flag_ImageType1--;
					continue;
				}
			if (soap_flag_PreventIconCollision1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns13:PreventIconCollision", &(a->ns13__MapUriOptions::PreventIconCollision), "xsd:boolean"))
				{	soap_flag_PreventIconCollision1--;
					continue;
				}
			if (soap_flag_Style1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__MapStyle(soap, "ns13:Style", &(a->ns13__MapUriOptions::Style), "ns4:MapStyle"))
				{	soap_flag_Style1--;
					continue;
				}
			if (soap_flag_UriScheme1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UriScheme(soap, "ns13:UriScheme", &(a->ns13__MapUriOptions::UriScheme), "ns4:UriScheme"))
				{	soap_flag_UriScheme1--;
					continue;
				}
			if (soap_flag_ZoomLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns13:ZoomLevel", &(a->ns13__MapUriOptions::ZoomLevel), "xsd:int"))
				{	soap_flag_ZoomLevel1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns13__MapUriOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns13__MapUriOptions, 0, sizeof(ns13__MapUriOptions), 0, soap_copy_ns13__MapUriOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns13__MapUriOptions * SOAP_FMAC4 soap_instantiate_ns13__MapUriOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns13__MapUriOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns13__MapUriOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns13__MapUriOptions;
		if (size)
			*size = sizeof(ns13__MapUriOptions);
		((ns13__MapUriOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns13__MapUriOptions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns13__MapUriOptions);
		for (int i = 0; i < n; i++)
			((ns13__MapUriOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns13__MapUriOptions*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns13__MapUriOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns13__MapUriOptions %p -> %p\n", q, p));
	*(ns13__MapUriOptions*)p = *(ns13__MapUriOptions*)q;
}

void ns13__MapUriRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns13__MapUriRequest::Center = NULL;
	this->ns13__MapUriRequest::MajorRoutesDestination = NULL;
	this->ns13__MapUriRequest::Options = NULL;
	this->ns13__MapUriRequest::Pushpins = NULL;
	this->ns4__RequestBase::Credentials = NULL;
	soap_default_string(soap, &this->ns4__RequestBase::Culture);
	this->ns4__RequestBase::ExecutionOptions = NULL;
	this->ns4__RequestBase::UserProfile = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns13__MapUriRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Location(soap, &this->ns13__MapUriRequest::Center);
	soap_serialize_PointerTons4__Location(soap, &this->ns13__MapUriRequest::MajorRoutesDestination);
	soap_serialize_PointerTons13__MapUriOptions(soap, &this->ns13__MapUriRequest::Options);
	soap_serialize_PointerTons4__ArrayOfPushpin(soap, &this->ns13__MapUriRequest::Pushpins);
	soap_serialize_PointerTons4__Credentials(soap, &this->ns4__RequestBase::Credentials);
	soap_serialize_string(soap, &this->ns4__RequestBase::Culture);
	soap_serialize_PointerTons4__ExecutionOptions(soap, &this->ns4__RequestBase::ExecutionOptions);
	soap_serialize_PointerTons4__UserProfile(soap, &this->ns4__RequestBase::UserProfile);
	/* transient soap skipped */
}

int ns13__MapUriRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns13__MapUriRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns13__MapUriRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns13__MapUriRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns13__MapUriRequest(struct soap *soap, const char *tag, int id, const ns13__MapUriRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns13__MapUriRequest), "ns13:MapUriRequest"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Credentials(soap, "ns4:Credentials", -1, &(a->ns4__RequestBase::Credentials), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Culture", -1, &(a->ns4__RequestBase::Culture), ""))
		return soap->error;
	if (soap_out_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", -1, &(a->ns4__RequestBase::ExecutionOptions), ""))
		return soap->error;
	if (soap_out_PointerTons4__UserProfile(soap, "ns4:UserProfile", -1, &(a->ns4__RequestBase::UserProfile), ""))
		return soap->error;
	if (soap_out_PointerTons4__Location(soap, "ns13:Center", -1, &(a->ns13__MapUriRequest::Center), ""))
		return soap->error;
	if (soap_out_PointerTons4__Location(soap, "ns13:MajorRoutesDestination", -1, &(a->ns13__MapUriRequest::MajorRoutesDestination), ""))
		return soap->error;
	if (soap_out_PointerTons13__MapUriOptions(soap, "ns13:Options", -1, &(a->ns13__MapUriRequest::Options), ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfPushpin(soap, "ns13:Pushpins", -1, &(a->ns13__MapUriRequest::Pushpins), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns13__MapUriRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns13__MapUriRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns13__MapUriRequest * SOAP_FMAC4 soap_get_ns13__MapUriRequest(struct soap *soap, ns13__MapUriRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns13__MapUriRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns13__MapUriRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns13__MapUriRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns13__MapUriRequest * SOAP_FMAC4 soap_in_ns13__MapUriRequest(struct soap *soap, const char *tag, ns13__MapUriRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns13__MapUriRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns13__MapUriRequest, sizeof(ns13__MapUriRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns13__MapUriRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns13__MapUriRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Credentials2 = 1;
	size_t soap_flag_Culture2 = 1;
	size_t soap_flag_ExecutionOptions2 = 1;
	size_t soap_flag_UserProfile2 = 1;
	size_t soap_flag_Center1 = 1;
	size_t soap_flag_MajorRoutesDestination1 = 1;
	size_t soap_flag_Options1 = 1;
	size_t soap_flag_Pushpins1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Credentials2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Credentials(soap, "ns4:Credentials", &(a->ns4__RequestBase::Credentials), "ns4:Credentials"))
				{	soap_flag_Credentials2--;
					continue;
				}
			if (soap_flag_Culture2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Culture", &(a->ns4__RequestBase::Culture), "xsd:string"))
				{	soap_flag_Culture2--;
					continue;
				}
			if (soap_flag_ExecutionOptions2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", &(a->ns4__RequestBase::ExecutionOptions), "ns4:ExecutionOptions"))
				{	soap_flag_ExecutionOptions2--;
					continue;
				}
			if (soap_flag_UserProfile2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserProfile(soap, "ns4:UserProfile", &(a->ns4__RequestBase::UserProfile), "ns4:UserProfile"))
				{	soap_flag_UserProfile2--;
					continue;
				}
			if (soap_flag_Center1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Location(soap, "ns13:Center", &(a->ns13__MapUriRequest::Center), "ns4:Location"))
				{	soap_flag_Center1--;
					continue;
				}
			if (soap_flag_MajorRoutesDestination1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Location(soap, "ns13:MajorRoutesDestination", &(a->ns13__MapUriRequest::MajorRoutesDestination), "ns4:Location"))
				{	soap_flag_MajorRoutesDestination1--;
					continue;
				}
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons13__MapUriOptions(soap, "ns13:Options", &(a->ns13__MapUriRequest::Options), "ns13:MapUriOptions"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap_flag_Pushpins1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfPushpin(soap, "ns13:Pushpins", &(a->ns13__MapUriRequest::Pushpins), "ns4:ArrayOfPushpin"))
				{	soap_flag_Pushpins1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns13__MapUriRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns13__MapUriRequest, 0, sizeof(ns13__MapUriRequest), 0, soap_copy_ns13__MapUriRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns13__MapUriRequest * SOAP_FMAC4 soap_instantiate_ns13__MapUriRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns13__MapUriRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns13__MapUriRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns13__MapUriRequest;
		if (size)
			*size = sizeof(ns13__MapUriRequest);
		((ns13__MapUriRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns13__MapUriRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns13__MapUriRequest);
		for (int i = 0; i < n; i++)
			((ns13__MapUriRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns13__MapUriRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns13__MapUriRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns13__MapUriRequest %p -> %p\n", q, p));
	*(ns13__MapUriRequest*)p = *(ns13__MapUriRequest*)q;
}

void ns13__ImageryMetadataBirdseyeResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns13__ImageryMetadataBirdseyeResult::Heading = NULL;
	this->ns13__ImageryMetadataBirdseyeResult::TilesX = NULL;
	this->ns13__ImageryMetadataBirdseyeResult::TilesY = NULL;
	this->ns13__ImageryMetadataResult::ImageSize = NULL;
	soap_default_string(soap, &this->ns13__ImageryMetadataResult::ImageUri);
	this->ns13__ImageryMetadataResult::ImageUriSubdomains = NULL;
	this->ns13__ImageryMetadataResult::ImageryProviders = NULL;
	this->ns13__ImageryMetadataResult::Vintage = NULL;
	this->ns13__ImageryMetadataResult::ZoomRange = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns13__ImageryMetadataBirdseyeResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Heading(soap, &this->ns13__ImageryMetadataBirdseyeResult::Heading);
	soap_serialize_PointerToint(soap, &this->ns13__ImageryMetadataBirdseyeResult::TilesX);
	soap_serialize_PointerToint(soap, &this->ns13__ImageryMetadataBirdseyeResult::TilesY);
	soap_serialize_PointerTons4__SizeOfint(soap, &this->ns13__ImageryMetadataResult::ImageSize);
	soap_serialize_string(soap, &this->ns13__ImageryMetadataResult::ImageUri);
	soap_serialize_PointerTons7__ArrayOfstring(soap, &this->ns13__ImageryMetadataResult::ImageUriSubdomains);
	soap_serialize_PointerTons13__ArrayOfImageryProvider(soap, &this->ns13__ImageryMetadataResult::ImageryProviders);
	soap_serialize_PointerTons4__RangeOfdateTime(soap, &this->ns13__ImageryMetadataResult::Vintage);
	soap_serialize_PointerTons4__RangeOfint(soap, &this->ns13__ImageryMetadataResult::ZoomRange);
	/* transient soap skipped */
}

int ns13__ImageryMetadataBirdseyeResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns13__ImageryMetadataBirdseyeResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns13__ImageryMetadataBirdseyeResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns13__ImageryMetadataBirdseyeResult(struct soap *soap, const char *tag, int id, const ns13__ImageryMetadataBirdseyeResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult), "ns13:ImageryMetadataBirdseyeResult"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__SizeOfint(soap, "ns13:ImageSize", -1, &(a->ns13__ImageryMetadataResult::ImageSize), ""))
		return soap->error;
	if (soap_out_string(soap, "ns13:ImageUri", -1, &(a->ns13__ImageryMetadataResult::ImageUri), ""))
		return soap->error;
	if (soap_out_PointerTons7__ArrayOfstring(soap, "ns13:ImageUriSubdomains", -1, &(a->ns13__ImageryMetadataResult::ImageUriSubdomains), ""))
		return soap->error;
	if (soap_out_PointerTons13__ArrayOfImageryProvider(soap, "ns13:ImageryProviders", -1, &(a->ns13__ImageryMetadataResult::ImageryProviders), ""))
		return soap->error;
	if (soap_out_PointerTons4__RangeOfdateTime(soap, "ns13:Vintage", -1, &(a->ns13__ImageryMetadataResult::Vintage), ""))
		return soap->error;
	if (soap_out_PointerTons4__RangeOfint(soap, "ns13:ZoomRange", -1, &(a->ns13__ImageryMetadataResult::ZoomRange), ""))
		return soap->error;
	if (soap_out_PointerTons4__Heading(soap, "ns13:Heading", -1, &(a->ns13__ImageryMetadataBirdseyeResult::Heading), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns13:TilesX", -1, &(a->ns13__ImageryMetadataBirdseyeResult::TilesX), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns13:TilesY", -1, &(a->ns13__ImageryMetadataBirdseyeResult::TilesY), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns13__ImageryMetadataBirdseyeResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns13__ImageryMetadataBirdseyeResult(soap, this, tag, type);
}

SOAP_FMAC3 ns13__ImageryMetadataBirdseyeResult * SOAP_FMAC4 soap_get_ns13__ImageryMetadataBirdseyeResult(struct soap *soap, ns13__ImageryMetadataBirdseyeResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns13__ImageryMetadataBirdseyeResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns13__ImageryMetadataBirdseyeResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns13__ImageryMetadataBirdseyeResult(soap, tag, this, type);
}

SOAP_FMAC3 ns13__ImageryMetadataBirdseyeResult * SOAP_FMAC4 soap_in_ns13__ImageryMetadataBirdseyeResult(struct soap *soap, const char *tag, ns13__ImageryMetadataBirdseyeResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns13__ImageryMetadataBirdseyeResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult, sizeof(ns13__ImageryMetadataBirdseyeResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns13__ImageryMetadataBirdseyeResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_ImageSize2 = 1;
	size_t soap_flag_ImageUri2 = 1;
	size_t soap_flag_ImageUriSubdomains2 = 1;
	size_t soap_flag_ImageryProviders2 = 1;
	size_t soap_flag_Vintage2 = 1;
	size_t soap_flag_ZoomRange2 = 1;
	size_t soap_flag_Heading1 = 1;
	size_t soap_flag_TilesX1 = 1;
	size_t soap_flag_TilesY1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ImageSize2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SizeOfint(soap, "ns13:ImageSize", &(a->ns13__ImageryMetadataResult::ImageSize), "ns4:SizeOfint"))
				{	soap_flag_ImageSize2--;
					continue;
				}
			if (soap_flag_ImageUri2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns13:ImageUri", &(a->ns13__ImageryMetadataResult::ImageUri), "xsd:string"))
				{	soap_flag_ImageUri2--;
					continue;
				}
			if (soap_flag_ImageUriSubdomains2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ArrayOfstring(soap, "ns13:ImageUriSubdomains", &(a->ns13__ImageryMetadataResult::ImageUriSubdomains), "ns7:ArrayOfstring"))
				{	soap_flag_ImageUriSubdomains2--;
					continue;
				}
			if (soap_flag_ImageryProviders2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons13__ArrayOfImageryProvider(soap, "ns13:ImageryProviders", &(a->ns13__ImageryMetadataResult::ImageryProviders), "ns13:ArrayOfImageryProvider"))
				{	soap_flag_ImageryProviders2--;
					continue;
				}
			if (soap_flag_Vintage2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__RangeOfdateTime(soap, "ns13:Vintage", &(a->ns13__ImageryMetadataResult::Vintage), "ns4:RangeOfdateTime"))
				{	soap_flag_Vintage2--;
					continue;
				}
			if (soap_flag_ZoomRange2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__RangeOfint(soap, "ns13:ZoomRange", &(a->ns13__ImageryMetadataResult::ZoomRange), "ns4:RangeOfint"))
				{	soap_flag_ZoomRange2--;
					continue;
				}
			if (soap_flag_Heading1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Heading(soap, "ns13:Heading", &(a->ns13__ImageryMetadataBirdseyeResult::Heading), "ns4:Heading"))
				{	soap_flag_Heading1--;
					continue;
				}
			if (soap_flag_TilesX1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns13:TilesX", &(a->ns13__ImageryMetadataBirdseyeResult::TilesX), "xsd:int"))
				{	soap_flag_TilesX1--;
					continue;
				}
			if (soap_flag_TilesY1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns13:TilesY", &(a->ns13__ImageryMetadataBirdseyeResult::TilesY), "xsd:int"))
				{	soap_flag_TilesY1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns13__ImageryMetadataBirdseyeResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult, 0, sizeof(ns13__ImageryMetadataBirdseyeResult), 0, soap_copy_ns13__ImageryMetadataBirdseyeResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns13__ImageryMetadataBirdseyeResult * SOAP_FMAC4 soap_instantiate_ns13__ImageryMetadataBirdseyeResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns13__ImageryMetadataBirdseyeResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns13__ImageryMetadataBirdseyeResult;
		if (size)
			*size = sizeof(ns13__ImageryMetadataBirdseyeResult);
		((ns13__ImageryMetadataBirdseyeResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns13__ImageryMetadataBirdseyeResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns13__ImageryMetadataBirdseyeResult);
		for (int i = 0; i < n; i++)
			((ns13__ImageryMetadataBirdseyeResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns13__ImageryMetadataBirdseyeResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns13__ImageryMetadataBirdseyeResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns13__ImageryMetadataBirdseyeResult %p -> %p\n", q, p));
	*(ns13__ImageryMetadataBirdseyeResult*)p = *(ns13__ImageryMetadataBirdseyeResult*)q;
}

void ns13__CoverageArea::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns13__CoverageArea::BoundingRectangle = NULL;
	this->ns13__CoverageArea::ZoomRange = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns13__CoverageArea::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Rectangle(soap, &this->ns13__CoverageArea::BoundingRectangle);
	soap_serialize_PointerTons4__RangeOfint(soap, &this->ns13__CoverageArea::ZoomRange);
	/* transient soap skipped */
}

int ns13__CoverageArea::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns13__CoverageArea);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns13__CoverageArea::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns13__CoverageArea(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns13__CoverageArea(struct soap *soap, const char *tag, int id, const ns13__CoverageArea *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns13__CoverageArea), "ns13:CoverageArea"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Rectangle(soap, "ns13:BoundingRectangle", -1, &(a->ns13__CoverageArea::BoundingRectangle), ""))
		return soap->error;
	if (soap_out_PointerTons4__RangeOfint(soap, "ns13:ZoomRange", -1, &(a->ns13__CoverageArea::ZoomRange), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns13__CoverageArea::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns13__CoverageArea(soap, this, tag, type);
}

SOAP_FMAC3 ns13__CoverageArea * SOAP_FMAC4 soap_get_ns13__CoverageArea(struct soap *soap, ns13__CoverageArea *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns13__CoverageArea(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns13__CoverageArea::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns13__CoverageArea(soap, tag, this, type);
}

SOAP_FMAC3 ns13__CoverageArea * SOAP_FMAC4 soap_in_ns13__CoverageArea(struct soap *soap, const char *tag, ns13__CoverageArea *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns13__CoverageArea *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns13__CoverageArea, sizeof(ns13__CoverageArea), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns13__CoverageArea)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns13__CoverageArea *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_BoundingRectangle1 = 1;
	size_t soap_flag_ZoomRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_BoundingRectangle1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Rectangle(soap, "ns13:BoundingRectangle", &(a->ns13__CoverageArea::BoundingRectangle), "ns4:Rectangle"))
				{	soap_flag_BoundingRectangle1--;
					continue;
				}
			if (soap_flag_ZoomRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__RangeOfint(soap, "ns13:ZoomRange", &(a->ns13__CoverageArea::ZoomRange), "ns4:RangeOfint"))
				{	soap_flag_ZoomRange1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns13__CoverageArea *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns13__CoverageArea, 0, sizeof(ns13__CoverageArea), 0, soap_copy_ns13__CoverageArea);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns13__CoverageArea * SOAP_FMAC4 soap_instantiate_ns13__CoverageArea(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns13__CoverageArea(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns13__CoverageArea, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns13__CoverageArea;
		if (size)
			*size = sizeof(ns13__CoverageArea);
		((ns13__CoverageArea*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns13__CoverageArea[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns13__CoverageArea);
		for (int i = 0; i < n; i++)
			((ns13__CoverageArea*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns13__CoverageArea*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns13__CoverageArea(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns13__CoverageArea %p -> %p\n", q, p));
	*(ns13__CoverageArea*)p = *(ns13__CoverageArea*)q;
}

void ns13__ArrayOfCoverageArea::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns13__ArrayOfCoverageArea::__sizeCoverageArea = 0;
	this->ns13__ArrayOfCoverageArea::CoverageArea = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns13__ArrayOfCoverageArea::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns13__ArrayOfCoverageArea::CoverageArea)
	{	int i;
		for (i = 0; i < this->ns13__ArrayOfCoverageArea::__sizeCoverageArea; i++)
		{
			soap_serialize_PointerTons13__CoverageArea(soap, this->ns13__ArrayOfCoverageArea::CoverageArea + i);
		}
	}
	/* transient soap skipped */
}

int ns13__ArrayOfCoverageArea::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns13__ArrayOfCoverageArea);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns13__ArrayOfCoverageArea::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns13__ArrayOfCoverageArea(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns13__ArrayOfCoverageArea(struct soap *soap, const char *tag, int id, const ns13__ArrayOfCoverageArea *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns13__ArrayOfCoverageArea), "ns13:ArrayOfCoverageArea"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns13__ArrayOfCoverageArea::CoverageArea)
	{	int i;
		for (i = 0; i < a->ns13__ArrayOfCoverageArea::__sizeCoverageArea; i++)
			if (soap_out_PointerTons13__CoverageArea(soap, "ns13:CoverageArea", -1, a->ns13__ArrayOfCoverageArea::CoverageArea + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns13__ArrayOfCoverageArea::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns13__ArrayOfCoverageArea(soap, this, tag, type);
}

SOAP_FMAC3 ns13__ArrayOfCoverageArea * SOAP_FMAC4 soap_get_ns13__ArrayOfCoverageArea(struct soap *soap, ns13__ArrayOfCoverageArea *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns13__ArrayOfCoverageArea(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns13__ArrayOfCoverageArea::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns13__ArrayOfCoverageArea(soap, tag, this, type);
}

SOAP_FMAC3 ns13__ArrayOfCoverageArea * SOAP_FMAC4 soap_in_ns13__ArrayOfCoverageArea(struct soap *soap, const char *tag, ns13__ArrayOfCoverageArea *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns13__ArrayOfCoverageArea *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns13__ArrayOfCoverageArea, sizeof(ns13__ArrayOfCoverageArea), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns13__ArrayOfCoverageArea)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns13__ArrayOfCoverageArea *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_CoverageArea1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns13:CoverageArea", 1, NULL))
			{	if (a->ns13__ArrayOfCoverageArea::CoverageArea == NULL)
				{	if (soap_blist_CoverageArea1 == NULL)
						soap_blist_CoverageArea1 = soap_new_block(soap);
					a->ns13__ArrayOfCoverageArea::CoverageArea = (ns13__CoverageArea **)soap_push_block(soap, soap_blist_CoverageArea1, sizeof(ns13__CoverageArea *));
					if (a->ns13__ArrayOfCoverageArea::CoverageArea == NULL)
						return NULL;
					*a->ns13__ArrayOfCoverageArea::CoverageArea = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons13__CoverageArea(soap, "ns13:CoverageArea", a->ns13__ArrayOfCoverageArea::CoverageArea, "ns13:CoverageArea"))
				{	a->ns13__ArrayOfCoverageArea::__sizeCoverageArea++;
					a->ns13__ArrayOfCoverageArea::CoverageArea = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns13__ArrayOfCoverageArea::CoverageArea)
			soap_pop_block(soap, soap_blist_CoverageArea1);
		if (a->ns13__ArrayOfCoverageArea::__sizeCoverageArea)
			a->ns13__ArrayOfCoverageArea::CoverageArea = (ns13__CoverageArea **)soap_save_block(soap, soap_blist_CoverageArea1, NULL, 1);
		else
		{	a->ns13__ArrayOfCoverageArea::CoverageArea = NULL;
			if (soap_blist_CoverageArea1)
				soap_end_block(soap, soap_blist_CoverageArea1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns13__ArrayOfCoverageArea *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns13__ArrayOfCoverageArea, 0, sizeof(ns13__ArrayOfCoverageArea), 0, soap_copy_ns13__ArrayOfCoverageArea);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns13__ArrayOfCoverageArea * SOAP_FMAC4 soap_instantiate_ns13__ArrayOfCoverageArea(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns13__ArrayOfCoverageArea(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns13__ArrayOfCoverageArea, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns13__ArrayOfCoverageArea;
		if (size)
			*size = sizeof(ns13__ArrayOfCoverageArea);
		((ns13__ArrayOfCoverageArea*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns13__ArrayOfCoverageArea[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns13__ArrayOfCoverageArea);
		for (int i = 0; i < n; i++)
			((ns13__ArrayOfCoverageArea*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns13__ArrayOfCoverageArea*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns13__ArrayOfCoverageArea(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns13__ArrayOfCoverageArea %p -> %p\n", q, p));
	*(ns13__ArrayOfCoverageArea*)p = *(ns13__ArrayOfCoverageArea*)q;
}

void ns13__ImageryProvider::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns13__ImageryProvider::Attribution);
	this->ns13__ImageryProvider::CoverageAreas = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns13__ImageryProvider::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns13__ImageryProvider::Attribution);
	soap_serialize_PointerTons13__ArrayOfCoverageArea(soap, &this->ns13__ImageryProvider::CoverageAreas);
	/* transient soap skipped */
}

int ns13__ImageryProvider::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns13__ImageryProvider);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns13__ImageryProvider::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns13__ImageryProvider(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns13__ImageryProvider(struct soap *soap, const char *tag, int id, const ns13__ImageryProvider *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns13__ImageryProvider), "ns13:ImageryProvider"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns13:Attribution", -1, &(a->ns13__ImageryProvider::Attribution), ""))
		return soap->error;
	if (soap_out_PointerTons13__ArrayOfCoverageArea(soap, "ns13:CoverageAreas", -1, &(a->ns13__ImageryProvider::CoverageAreas), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns13__ImageryProvider::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns13__ImageryProvider(soap, this, tag, type);
}

SOAP_FMAC3 ns13__ImageryProvider * SOAP_FMAC4 soap_get_ns13__ImageryProvider(struct soap *soap, ns13__ImageryProvider *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns13__ImageryProvider(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns13__ImageryProvider::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns13__ImageryProvider(soap, tag, this, type);
}

SOAP_FMAC3 ns13__ImageryProvider * SOAP_FMAC4 soap_in_ns13__ImageryProvider(struct soap *soap, const char *tag, ns13__ImageryProvider *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns13__ImageryProvider *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns13__ImageryProvider, sizeof(ns13__ImageryProvider), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns13__ImageryProvider)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns13__ImageryProvider *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Attribution1 = 1;
	size_t soap_flag_CoverageAreas1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Attribution1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns13:Attribution", &(a->ns13__ImageryProvider::Attribution), "xsd:string"))
				{	soap_flag_Attribution1--;
					continue;
				}
			if (soap_flag_CoverageAreas1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons13__ArrayOfCoverageArea(soap, "ns13:CoverageAreas", &(a->ns13__ImageryProvider::CoverageAreas), "ns13:ArrayOfCoverageArea"))
				{	soap_flag_CoverageAreas1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns13__ImageryProvider *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns13__ImageryProvider, 0, sizeof(ns13__ImageryProvider), 0, soap_copy_ns13__ImageryProvider);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns13__ImageryProvider * SOAP_FMAC4 soap_instantiate_ns13__ImageryProvider(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns13__ImageryProvider(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns13__ImageryProvider, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns13__ImageryProvider;
		if (size)
			*size = sizeof(ns13__ImageryProvider);
		((ns13__ImageryProvider*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns13__ImageryProvider[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns13__ImageryProvider);
		for (int i = 0; i < n; i++)
			((ns13__ImageryProvider*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns13__ImageryProvider*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns13__ImageryProvider(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns13__ImageryProvider %p -> %p\n", q, p));
	*(ns13__ImageryProvider*)p = *(ns13__ImageryProvider*)q;
}

void ns13__ArrayOfImageryProvider::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns13__ArrayOfImageryProvider::__sizeImageryProvider = 0;
	this->ns13__ArrayOfImageryProvider::ImageryProvider = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns13__ArrayOfImageryProvider::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns13__ArrayOfImageryProvider::ImageryProvider)
	{	int i;
		for (i = 0; i < this->ns13__ArrayOfImageryProvider::__sizeImageryProvider; i++)
		{
			soap_serialize_PointerTons13__ImageryProvider(soap, this->ns13__ArrayOfImageryProvider::ImageryProvider + i);
		}
	}
	/* transient soap skipped */
}

int ns13__ArrayOfImageryProvider::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns13__ArrayOfImageryProvider);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns13__ArrayOfImageryProvider::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns13__ArrayOfImageryProvider(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns13__ArrayOfImageryProvider(struct soap *soap, const char *tag, int id, const ns13__ArrayOfImageryProvider *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns13__ArrayOfImageryProvider), "ns13:ArrayOfImageryProvider"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns13__ArrayOfImageryProvider::ImageryProvider)
	{	int i;
		for (i = 0; i < a->ns13__ArrayOfImageryProvider::__sizeImageryProvider; i++)
			if (soap_out_PointerTons13__ImageryProvider(soap, "ns13:ImageryProvider", -1, a->ns13__ArrayOfImageryProvider::ImageryProvider + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns13__ArrayOfImageryProvider::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns13__ArrayOfImageryProvider(soap, this, tag, type);
}

SOAP_FMAC3 ns13__ArrayOfImageryProvider * SOAP_FMAC4 soap_get_ns13__ArrayOfImageryProvider(struct soap *soap, ns13__ArrayOfImageryProvider *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns13__ArrayOfImageryProvider(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns13__ArrayOfImageryProvider::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns13__ArrayOfImageryProvider(soap, tag, this, type);
}

SOAP_FMAC3 ns13__ArrayOfImageryProvider * SOAP_FMAC4 soap_in_ns13__ArrayOfImageryProvider(struct soap *soap, const char *tag, ns13__ArrayOfImageryProvider *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns13__ArrayOfImageryProvider *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns13__ArrayOfImageryProvider, sizeof(ns13__ArrayOfImageryProvider), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns13__ArrayOfImageryProvider)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns13__ArrayOfImageryProvider *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_ImageryProvider1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns13:ImageryProvider", 1, NULL))
			{	if (a->ns13__ArrayOfImageryProvider::ImageryProvider == NULL)
				{	if (soap_blist_ImageryProvider1 == NULL)
						soap_blist_ImageryProvider1 = soap_new_block(soap);
					a->ns13__ArrayOfImageryProvider::ImageryProvider = (ns13__ImageryProvider **)soap_push_block(soap, soap_blist_ImageryProvider1, sizeof(ns13__ImageryProvider *));
					if (a->ns13__ArrayOfImageryProvider::ImageryProvider == NULL)
						return NULL;
					*a->ns13__ArrayOfImageryProvider::ImageryProvider = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons13__ImageryProvider(soap, "ns13:ImageryProvider", a->ns13__ArrayOfImageryProvider::ImageryProvider, "ns13:ImageryProvider"))
				{	a->ns13__ArrayOfImageryProvider::__sizeImageryProvider++;
					a->ns13__ArrayOfImageryProvider::ImageryProvider = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns13__ArrayOfImageryProvider::ImageryProvider)
			soap_pop_block(soap, soap_blist_ImageryProvider1);
		if (a->ns13__ArrayOfImageryProvider::__sizeImageryProvider)
			a->ns13__ArrayOfImageryProvider::ImageryProvider = (ns13__ImageryProvider **)soap_save_block(soap, soap_blist_ImageryProvider1, NULL, 1);
		else
		{	a->ns13__ArrayOfImageryProvider::ImageryProvider = NULL;
			if (soap_blist_ImageryProvider1)
				soap_end_block(soap, soap_blist_ImageryProvider1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns13__ArrayOfImageryProvider *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns13__ArrayOfImageryProvider, 0, sizeof(ns13__ArrayOfImageryProvider), 0, soap_copy_ns13__ArrayOfImageryProvider);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns13__ArrayOfImageryProvider * SOAP_FMAC4 soap_instantiate_ns13__ArrayOfImageryProvider(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns13__ArrayOfImageryProvider(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns13__ArrayOfImageryProvider, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns13__ArrayOfImageryProvider;
		if (size)
			*size = sizeof(ns13__ArrayOfImageryProvider);
		((ns13__ArrayOfImageryProvider*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns13__ArrayOfImageryProvider[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns13__ArrayOfImageryProvider);
		for (int i = 0; i < n; i++)
			((ns13__ArrayOfImageryProvider*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns13__ArrayOfImageryProvider*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns13__ArrayOfImageryProvider(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns13__ArrayOfImageryProvider %p -> %p\n", q, p));
	*(ns13__ArrayOfImageryProvider*)p = *(ns13__ArrayOfImageryProvider*)q;
}

void ns13__ImageryMetadataResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns13__ImageryMetadataResult::ImageSize = NULL;
	soap_default_string(soap, &this->ns13__ImageryMetadataResult::ImageUri);
	this->ns13__ImageryMetadataResult::ImageUriSubdomains = NULL;
	this->ns13__ImageryMetadataResult::ImageryProviders = NULL;
	this->ns13__ImageryMetadataResult::Vintage = NULL;
	this->ns13__ImageryMetadataResult::ZoomRange = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns13__ImageryMetadataResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__SizeOfint(soap, &this->ns13__ImageryMetadataResult::ImageSize);
	soap_serialize_string(soap, &this->ns13__ImageryMetadataResult::ImageUri);
	soap_serialize_PointerTons7__ArrayOfstring(soap, &this->ns13__ImageryMetadataResult::ImageUriSubdomains);
	soap_serialize_PointerTons13__ArrayOfImageryProvider(soap, &this->ns13__ImageryMetadataResult::ImageryProviders);
	soap_serialize_PointerTons4__RangeOfdateTime(soap, &this->ns13__ImageryMetadataResult::Vintage);
	soap_serialize_PointerTons4__RangeOfint(soap, &this->ns13__ImageryMetadataResult::ZoomRange);
	/* transient soap skipped */
}

int ns13__ImageryMetadataResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns13__ImageryMetadataResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns13__ImageryMetadataResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns13__ImageryMetadataResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns13__ImageryMetadataResult(struct soap *soap, const char *tag, int id, const ns13__ImageryMetadataResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns13__ImageryMetadataResult), "ns13:ImageryMetadataResult"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__SizeOfint(soap, "ns13:ImageSize", -1, &(a->ns13__ImageryMetadataResult::ImageSize), ""))
		return soap->error;
	if (soap_out_string(soap, "ns13:ImageUri", -1, &(a->ns13__ImageryMetadataResult::ImageUri), ""))
		return soap->error;
	if (soap_out_PointerTons7__ArrayOfstring(soap, "ns13:ImageUriSubdomains", -1, &(a->ns13__ImageryMetadataResult::ImageUriSubdomains), ""))
		return soap->error;
	if (soap_out_PointerTons13__ArrayOfImageryProvider(soap, "ns13:ImageryProviders", -1, &(a->ns13__ImageryMetadataResult::ImageryProviders), ""))
		return soap->error;
	if (soap_out_PointerTons4__RangeOfdateTime(soap, "ns13:Vintage", -1, &(a->ns13__ImageryMetadataResult::Vintage), ""))
		return soap->error;
	if (soap_out_PointerTons4__RangeOfint(soap, "ns13:ZoomRange", -1, &(a->ns13__ImageryMetadataResult::ZoomRange), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns13__ImageryMetadataResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns13__ImageryMetadataResult(soap, this, tag, type);
}

SOAP_FMAC3 ns13__ImageryMetadataResult * SOAP_FMAC4 soap_get_ns13__ImageryMetadataResult(struct soap *soap, ns13__ImageryMetadataResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns13__ImageryMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns13__ImageryMetadataResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns13__ImageryMetadataResult(soap, tag, this, type);
}

SOAP_FMAC3 ns13__ImageryMetadataResult * SOAP_FMAC4 soap_in_ns13__ImageryMetadataResult(struct soap *soap, const char *tag, ns13__ImageryMetadataResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns13__ImageryMetadataResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns13__ImageryMetadataResult, sizeof(ns13__ImageryMetadataResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns13__ImageryMetadataResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns13__ImageryMetadataResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ImageSize1 = 1;
	size_t soap_flag_ImageUri1 = 1;
	size_t soap_flag_ImageUriSubdomains1 = 1;
	size_t soap_flag_ImageryProviders1 = 1;
	size_t soap_flag_Vintage1 = 1;
	size_t soap_flag_ZoomRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ImageSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SizeOfint(soap, "ns13:ImageSize", &(a->ns13__ImageryMetadataResult::ImageSize), "ns4:SizeOfint"))
				{	soap_flag_ImageSize1--;
					continue;
				}
			if (soap_flag_ImageUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns13:ImageUri", &(a->ns13__ImageryMetadataResult::ImageUri), "xsd:string"))
				{	soap_flag_ImageUri1--;
					continue;
				}
			if (soap_flag_ImageUriSubdomains1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ArrayOfstring(soap, "ns13:ImageUriSubdomains", &(a->ns13__ImageryMetadataResult::ImageUriSubdomains), "ns7:ArrayOfstring"))
				{	soap_flag_ImageUriSubdomains1--;
					continue;
				}
			if (soap_flag_ImageryProviders1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons13__ArrayOfImageryProvider(soap, "ns13:ImageryProviders", &(a->ns13__ImageryMetadataResult::ImageryProviders), "ns13:ArrayOfImageryProvider"))
				{	soap_flag_ImageryProviders1--;
					continue;
				}
			if (soap_flag_Vintage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__RangeOfdateTime(soap, "ns13:Vintage", &(a->ns13__ImageryMetadataResult::Vintage), "ns4:RangeOfdateTime"))
				{	soap_flag_Vintage1--;
					continue;
				}
			if (soap_flag_ZoomRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__RangeOfint(soap, "ns13:ZoomRange", &(a->ns13__ImageryMetadataResult::ZoomRange), "ns4:RangeOfint"))
				{	soap_flag_ZoomRange1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns13__ImageryMetadataResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns13__ImageryMetadataResult, 0, sizeof(ns13__ImageryMetadataResult), 0, soap_copy_ns13__ImageryMetadataResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns13__ImageryMetadataResult * SOAP_FMAC4 soap_instantiate_ns13__ImageryMetadataResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns13__ImageryMetadataResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns13__ImageryMetadataResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns13:ImageryMetadataBirdseyeResult"))
	{	cp->type = SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__ImageryMetadataBirdseyeResult;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__ImageryMetadataBirdseyeResult);
			((ns13__ImageryMetadataBirdseyeResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__ImageryMetadataBirdseyeResult[n];
			if (size)
				*size = n * sizeof(ns13__ImageryMetadataBirdseyeResult);
			for (int i = 0; i < n; i++)
				((ns13__ImageryMetadataBirdseyeResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__ImageryMetadataBirdseyeResult*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns13__ImageryMetadataResult;
		if (size)
			*size = sizeof(ns13__ImageryMetadataResult);
		((ns13__ImageryMetadataResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns13__ImageryMetadataResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns13__ImageryMetadataResult);
		for (int i = 0; i < n; i++)
			((ns13__ImageryMetadataResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns13__ImageryMetadataResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns13__ImageryMetadataResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns13__ImageryMetadataResult %p -> %p\n", q, p));
	*(ns13__ImageryMetadataResult*)p = *(ns13__ImageryMetadataResult*)q;
}

void ns13__ArrayOfImageryMetadataResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns13__ArrayOfImageryMetadataResult::__sizeImageryMetadataResult = 0;
	this->ns13__ArrayOfImageryMetadataResult::ImageryMetadataResult = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns13__ArrayOfImageryMetadataResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns13__ArrayOfImageryMetadataResult::ImageryMetadataResult)
	{	int i;
		for (i = 0; i < this->ns13__ArrayOfImageryMetadataResult::__sizeImageryMetadataResult; i++)
		{
			soap_serialize_PointerTons13__ImageryMetadataResult(soap, this->ns13__ArrayOfImageryMetadataResult::ImageryMetadataResult + i);
		}
	}
	/* transient soap skipped */
}

int ns13__ArrayOfImageryMetadataResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns13__ArrayOfImageryMetadataResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns13__ArrayOfImageryMetadataResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns13__ArrayOfImageryMetadataResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns13__ArrayOfImageryMetadataResult(struct soap *soap, const char *tag, int id, const ns13__ArrayOfImageryMetadataResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns13__ArrayOfImageryMetadataResult), "ns13:ArrayOfImageryMetadataResult"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns13__ArrayOfImageryMetadataResult::ImageryMetadataResult)
	{	int i;
		for (i = 0; i < a->ns13__ArrayOfImageryMetadataResult::__sizeImageryMetadataResult; i++)
			if (soap_out_PointerTons13__ImageryMetadataResult(soap, "ns13:ImageryMetadataResult", -1, a->ns13__ArrayOfImageryMetadataResult::ImageryMetadataResult + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns13__ArrayOfImageryMetadataResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns13__ArrayOfImageryMetadataResult(soap, this, tag, type);
}

SOAP_FMAC3 ns13__ArrayOfImageryMetadataResult * SOAP_FMAC4 soap_get_ns13__ArrayOfImageryMetadataResult(struct soap *soap, ns13__ArrayOfImageryMetadataResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns13__ArrayOfImageryMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns13__ArrayOfImageryMetadataResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns13__ArrayOfImageryMetadataResult(soap, tag, this, type);
}

SOAP_FMAC3 ns13__ArrayOfImageryMetadataResult * SOAP_FMAC4 soap_in_ns13__ArrayOfImageryMetadataResult(struct soap *soap, const char *tag, ns13__ArrayOfImageryMetadataResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns13__ArrayOfImageryMetadataResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns13__ArrayOfImageryMetadataResult, sizeof(ns13__ArrayOfImageryMetadataResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns13__ArrayOfImageryMetadataResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns13__ArrayOfImageryMetadataResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_ImageryMetadataResult1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns13:ImageryMetadataResult", 1, NULL))
			{	if (a->ns13__ArrayOfImageryMetadataResult::ImageryMetadataResult == NULL)
				{	if (soap_blist_ImageryMetadataResult1 == NULL)
						soap_blist_ImageryMetadataResult1 = soap_new_block(soap);
					a->ns13__ArrayOfImageryMetadataResult::ImageryMetadataResult = (ns13__ImageryMetadataResult **)soap_push_block(soap, soap_blist_ImageryMetadataResult1, sizeof(ns13__ImageryMetadataResult *));
					if (a->ns13__ArrayOfImageryMetadataResult::ImageryMetadataResult == NULL)
						return NULL;
					*a->ns13__ArrayOfImageryMetadataResult::ImageryMetadataResult = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons13__ImageryMetadataResult(soap, "ns13:ImageryMetadataResult", a->ns13__ArrayOfImageryMetadataResult::ImageryMetadataResult, "ns13:ImageryMetadataResult"))
				{	a->ns13__ArrayOfImageryMetadataResult::__sizeImageryMetadataResult++;
					a->ns13__ArrayOfImageryMetadataResult::ImageryMetadataResult = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns13__ArrayOfImageryMetadataResult::ImageryMetadataResult)
			soap_pop_block(soap, soap_blist_ImageryMetadataResult1);
		if (a->ns13__ArrayOfImageryMetadataResult::__sizeImageryMetadataResult)
			a->ns13__ArrayOfImageryMetadataResult::ImageryMetadataResult = (ns13__ImageryMetadataResult **)soap_save_block(soap, soap_blist_ImageryMetadataResult1, NULL, 1);
		else
		{	a->ns13__ArrayOfImageryMetadataResult::ImageryMetadataResult = NULL;
			if (soap_blist_ImageryMetadataResult1)
				soap_end_block(soap, soap_blist_ImageryMetadataResult1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns13__ArrayOfImageryMetadataResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns13__ArrayOfImageryMetadataResult, 0, sizeof(ns13__ArrayOfImageryMetadataResult), 0, soap_copy_ns13__ArrayOfImageryMetadataResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns13__ArrayOfImageryMetadataResult * SOAP_FMAC4 soap_instantiate_ns13__ArrayOfImageryMetadataResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns13__ArrayOfImageryMetadataResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns13__ArrayOfImageryMetadataResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns13__ArrayOfImageryMetadataResult;
		if (size)
			*size = sizeof(ns13__ArrayOfImageryMetadataResult);
		((ns13__ArrayOfImageryMetadataResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns13__ArrayOfImageryMetadataResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns13__ArrayOfImageryMetadataResult);
		for (int i = 0; i < n; i++)
			((ns13__ArrayOfImageryMetadataResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns13__ArrayOfImageryMetadataResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns13__ArrayOfImageryMetadataResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns13__ArrayOfImageryMetadataResult %p -> %p\n", q, p));
	*(ns13__ArrayOfImageryMetadataResult*)p = *(ns13__ArrayOfImageryMetadataResult*)q;
}

void ns13__ImageryMetadataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns13__ImageryMetadataResponse::Results = NULL;
	this->ns4__ResponseBase::ResponseSummary = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns13__ImageryMetadataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons13__ArrayOfImageryMetadataResult(soap, &this->ns13__ImageryMetadataResponse::Results);
	soap_serialize_PointerTons4__ResponseSummary(soap, &this->ns4__ResponseBase::ResponseSummary);
	/* transient soap skipped */
}

int ns13__ImageryMetadataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns13__ImageryMetadataResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns13__ImageryMetadataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns13__ImageryMetadataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns13__ImageryMetadataResponse(struct soap *soap, const char *tag, int id, const ns13__ImageryMetadataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns13__ImageryMetadataResponse), "ns13:ImageryMetadataResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__ResponseSummary(soap, "ns4:ResponseSummary", -1, &(a->ns4__ResponseBase::ResponseSummary), ""))
		return soap->error;
	if (soap_out_PointerTons13__ArrayOfImageryMetadataResult(soap, "ns13:Results", -1, &(a->ns13__ImageryMetadataResponse::Results), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns13__ImageryMetadataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns13__ImageryMetadataResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns13__ImageryMetadataResponse * SOAP_FMAC4 soap_get_ns13__ImageryMetadataResponse(struct soap *soap, ns13__ImageryMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns13__ImageryMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns13__ImageryMetadataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns13__ImageryMetadataResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns13__ImageryMetadataResponse * SOAP_FMAC4 soap_in_ns13__ImageryMetadataResponse(struct soap *soap, const char *tag, ns13__ImageryMetadataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns13__ImageryMetadataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns13__ImageryMetadataResponse, sizeof(ns13__ImageryMetadataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns13__ImageryMetadataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns13__ImageryMetadataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_ResponseSummary2 = 1;
	size_t soap_flag_Results1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ResponseSummary2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ResponseSummary(soap, "ns4:ResponseSummary", &(a->ns4__ResponseBase::ResponseSummary), "ns4:ResponseSummary"))
				{	soap_flag_ResponseSummary2--;
					continue;
				}
			if (soap_flag_Results1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons13__ArrayOfImageryMetadataResult(soap, "ns13:Results", &(a->ns13__ImageryMetadataResponse::Results), "ns13:ArrayOfImageryMetadataResult"))
				{	soap_flag_Results1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns13__ImageryMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns13__ImageryMetadataResponse, 0, sizeof(ns13__ImageryMetadataResponse), 0, soap_copy_ns13__ImageryMetadataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns13__ImageryMetadataResponse * SOAP_FMAC4 soap_instantiate_ns13__ImageryMetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns13__ImageryMetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns13__ImageryMetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns13__ImageryMetadataResponse;
		if (size)
			*size = sizeof(ns13__ImageryMetadataResponse);
		((ns13__ImageryMetadataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns13__ImageryMetadataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns13__ImageryMetadataResponse);
		for (int i = 0; i < n; i++)
			((ns13__ImageryMetadataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns13__ImageryMetadataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns13__ImageryMetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns13__ImageryMetadataResponse %p -> %p\n", q, p));
	*(ns13__ImageryMetadataResponse*)p = *(ns13__ImageryMetadataResponse*)q;
}

void ns13__ImageryMetadataOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns13__ImageryMetadataOptions::Heading = NULL;
	this->ns13__ImageryMetadataOptions::Location = NULL;
	this->ns13__ImageryMetadataOptions::ReturnImageryProviders = NULL;
	this->ns13__ImageryMetadataOptions::UriScheme = NULL;
	this->ns13__ImageryMetadataOptions::ZoomLevel = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns13__ImageryMetadataOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Heading(soap, &this->ns13__ImageryMetadataOptions::Heading);
	soap_serialize_PointerTons4__Location(soap, &this->ns13__ImageryMetadataOptions::Location);
	soap_serialize_PointerTobool(soap, &this->ns13__ImageryMetadataOptions::ReturnImageryProviders);
	soap_serialize_PointerTons4__UriScheme(soap, &this->ns13__ImageryMetadataOptions::UriScheme);
	soap_serialize_PointerToint(soap, &this->ns13__ImageryMetadataOptions::ZoomLevel);
	/* transient soap skipped */
}

int ns13__ImageryMetadataOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns13__ImageryMetadataOptions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns13__ImageryMetadataOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns13__ImageryMetadataOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns13__ImageryMetadataOptions(struct soap *soap, const char *tag, int id, const ns13__ImageryMetadataOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns13__ImageryMetadataOptions), "ns13:ImageryMetadataOptions"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Heading(soap, "ns13:Heading", -1, &(a->ns13__ImageryMetadataOptions::Heading), ""))
		return soap->error;
	if (soap_out_PointerTons4__Location(soap, "ns13:Location", -1, &(a->ns13__ImageryMetadataOptions::Location), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns13:ReturnImageryProviders", -1, &(a->ns13__ImageryMetadataOptions::ReturnImageryProviders), ""))
		return soap->error;
	if (soap_out_PointerTons4__UriScheme(soap, "ns13:UriScheme", -1, &(a->ns13__ImageryMetadataOptions::UriScheme), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns13:ZoomLevel", -1, &(a->ns13__ImageryMetadataOptions::ZoomLevel), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns13__ImageryMetadataOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns13__ImageryMetadataOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns13__ImageryMetadataOptions * SOAP_FMAC4 soap_get_ns13__ImageryMetadataOptions(struct soap *soap, ns13__ImageryMetadataOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns13__ImageryMetadataOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns13__ImageryMetadataOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns13__ImageryMetadataOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns13__ImageryMetadataOptions * SOAP_FMAC4 soap_in_ns13__ImageryMetadataOptions(struct soap *soap, const char *tag, ns13__ImageryMetadataOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns13__ImageryMetadataOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns13__ImageryMetadataOptions, sizeof(ns13__ImageryMetadataOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns13__ImageryMetadataOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns13__ImageryMetadataOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Heading1 = 1;
	size_t soap_flag_Location1 = 1;
	size_t soap_flag_ReturnImageryProviders1 = 1;
	size_t soap_flag_UriScheme1 = 1;
	size_t soap_flag_ZoomLevel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Heading1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Heading(soap, "ns13:Heading", &(a->ns13__ImageryMetadataOptions::Heading), "ns4:Heading"))
				{	soap_flag_Heading1--;
					continue;
				}
			if (soap_flag_Location1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Location(soap, "ns13:Location", &(a->ns13__ImageryMetadataOptions::Location), "ns4:Location"))
				{	soap_flag_Location1--;
					continue;
				}
			if (soap_flag_ReturnImageryProviders1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns13:ReturnImageryProviders", &(a->ns13__ImageryMetadataOptions::ReturnImageryProviders), "xsd:boolean"))
				{	soap_flag_ReturnImageryProviders1--;
					continue;
				}
			if (soap_flag_UriScheme1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UriScheme(soap, "ns13:UriScheme", &(a->ns13__ImageryMetadataOptions::UriScheme), "ns4:UriScheme"))
				{	soap_flag_UriScheme1--;
					continue;
				}
			if (soap_flag_ZoomLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns13:ZoomLevel", &(a->ns13__ImageryMetadataOptions::ZoomLevel), "xsd:int"))
				{	soap_flag_ZoomLevel1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns13__ImageryMetadataOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns13__ImageryMetadataOptions, 0, sizeof(ns13__ImageryMetadataOptions), 0, soap_copy_ns13__ImageryMetadataOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns13__ImageryMetadataOptions * SOAP_FMAC4 soap_instantiate_ns13__ImageryMetadataOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns13__ImageryMetadataOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns13__ImageryMetadataOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns13__ImageryMetadataOptions;
		if (size)
			*size = sizeof(ns13__ImageryMetadataOptions);
		((ns13__ImageryMetadataOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns13__ImageryMetadataOptions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns13__ImageryMetadataOptions);
		for (int i = 0; i < n; i++)
			((ns13__ImageryMetadataOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns13__ImageryMetadataOptions*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns13__ImageryMetadataOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns13__ImageryMetadataOptions %p -> %p\n", q, p));
	*(ns13__ImageryMetadataOptions*)p = *(ns13__ImageryMetadataOptions*)q;
}

void ns13__ImageryMetadataRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns13__ImageryMetadataRequest::Options = NULL;
	this->ns13__ImageryMetadataRequest::Style = NULL;
	this->ns4__RequestBase::Credentials = NULL;
	soap_default_string(soap, &this->ns4__RequestBase::Culture);
	this->ns4__RequestBase::ExecutionOptions = NULL;
	this->ns4__RequestBase::UserProfile = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns13__ImageryMetadataRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons13__ImageryMetadataOptions(soap, &this->ns13__ImageryMetadataRequest::Options);
	soap_serialize_PointerTons4__MapStyle(soap, &this->ns13__ImageryMetadataRequest::Style);
	soap_serialize_PointerTons4__Credentials(soap, &this->ns4__RequestBase::Credentials);
	soap_serialize_string(soap, &this->ns4__RequestBase::Culture);
	soap_serialize_PointerTons4__ExecutionOptions(soap, &this->ns4__RequestBase::ExecutionOptions);
	soap_serialize_PointerTons4__UserProfile(soap, &this->ns4__RequestBase::UserProfile);
	/* transient soap skipped */
}

int ns13__ImageryMetadataRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns13__ImageryMetadataRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns13__ImageryMetadataRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns13__ImageryMetadataRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns13__ImageryMetadataRequest(struct soap *soap, const char *tag, int id, const ns13__ImageryMetadataRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns13__ImageryMetadataRequest), "ns13:ImageryMetadataRequest"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Credentials(soap, "ns4:Credentials", -1, &(a->ns4__RequestBase::Credentials), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Culture", -1, &(a->ns4__RequestBase::Culture), ""))
		return soap->error;
	if (soap_out_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", -1, &(a->ns4__RequestBase::ExecutionOptions), ""))
		return soap->error;
	if (soap_out_PointerTons4__UserProfile(soap, "ns4:UserProfile", -1, &(a->ns4__RequestBase::UserProfile), ""))
		return soap->error;
	if (soap_out_PointerTons13__ImageryMetadataOptions(soap, "ns13:Options", -1, &(a->ns13__ImageryMetadataRequest::Options), ""))
		return soap->error;
	if (soap_out_PointerTons4__MapStyle(soap, "ns13:Style", -1, &(a->ns13__ImageryMetadataRequest::Style), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns13__ImageryMetadataRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns13__ImageryMetadataRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns13__ImageryMetadataRequest * SOAP_FMAC4 soap_get_ns13__ImageryMetadataRequest(struct soap *soap, ns13__ImageryMetadataRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns13__ImageryMetadataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns13__ImageryMetadataRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns13__ImageryMetadataRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns13__ImageryMetadataRequest * SOAP_FMAC4 soap_in_ns13__ImageryMetadataRequest(struct soap *soap, const char *tag, ns13__ImageryMetadataRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns13__ImageryMetadataRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns13__ImageryMetadataRequest, sizeof(ns13__ImageryMetadataRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns13__ImageryMetadataRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns13__ImageryMetadataRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Credentials2 = 1;
	size_t soap_flag_Culture2 = 1;
	size_t soap_flag_ExecutionOptions2 = 1;
	size_t soap_flag_UserProfile2 = 1;
	size_t soap_flag_Options1 = 1;
	size_t soap_flag_Style1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Credentials2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Credentials(soap, "ns4:Credentials", &(a->ns4__RequestBase::Credentials), "ns4:Credentials"))
				{	soap_flag_Credentials2--;
					continue;
				}
			if (soap_flag_Culture2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Culture", &(a->ns4__RequestBase::Culture), "xsd:string"))
				{	soap_flag_Culture2--;
					continue;
				}
			if (soap_flag_ExecutionOptions2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", &(a->ns4__RequestBase::ExecutionOptions), "ns4:ExecutionOptions"))
				{	soap_flag_ExecutionOptions2--;
					continue;
				}
			if (soap_flag_UserProfile2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserProfile(soap, "ns4:UserProfile", &(a->ns4__RequestBase::UserProfile), "ns4:UserProfile"))
				{	soap_flag_UserProfile2--;
					continue;
				}
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons13__ImageryMetadataOptions(soap, "ns13:Options", &(a->ns13__ImageryMetadataRequest::Options), "ns13:ImageryMetadataOptions"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap_flag_Style1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__MapStyle(soap, "ns13:Style", &(a->ns13__ImageryMetadataRequest::Style), "ns4:MapStyle"))
				{	soap_flag_Style1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns13__ImageryMetadataRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns13__ImageryMetadataRequest, 0, sizeof(ns13__ImageryMetadataRequest), 0, soap_copy_ns13__ImageryMetadataRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns13__ImageryMetadataRequest * SOAP_FMAC4 soap_instantiate_ns13__ImageryMetadataRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns13__ImageryMetadataRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns13__ImageryMetadataRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns13__ImageryMetadataRequest;
		if (size)
			*size = sizeof(ns13__ImageryMetadataRequest);
		((ns13__ImageryMetadataRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns13__ImageryMetadataRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns13__ImageryMetadataRequest);
		for (int i = 0; i < n; i++)
			((ns13__ImageryMetadataRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns13__ImageryMetadataRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns13__ImageryMetadataRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns13__ImageryMetadataRequest %p -> %p\n", q, p));
	*(ns13__ImageryMetadataRequest*)p = *(ns13__ImageryMetadataRequest*)q;
}

void _ns12__GetMapUriResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns12__GetMapUriResponse::GetMapUriResult = NULL;
	/* transient soap skipped */
}

void _ns12__GetMapUriResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons13__MapUriResponse(soap, &this->_ns12__GetMapUriResponse::GetMapUriResult);
	/* transient soap skipped */
}

int _ns12__GetMapUriResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns12__GetMapUriResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns12__GetMapUriResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns12__GetMapUriResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns12__GetMapUriResponse(struct soap *soap, const char *tag, int id, const _ns12__GetMapUriResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns12__GetMapUriResponse), type))
		return soap->error;
	if (a->GetMapUriResult)
		soap_element_result(soap, "ns12:GetMapUriResult");
	if (soap_out_PointerTons13__MapUriResponse(soap, "ns12:GetMapUriResult", -1, &(a->_ns12__GetMapUriResponse::GetMapUriResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns12__GetMapUriResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns12__GetMapUriResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns12__GetMapUriResponse * SOAP_FMAC4 soap_get__ns12__GetMapUriResponse(struct soap *soap, _ns12__GetMapUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns12__GetMapUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns12__GetMapUriResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns12__GetMapUriResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns12__GetMapUriResponse * SOAP_FMAC4 soap_in__ns12__GetMapUriResponse(struct soap *soap, const char *tag, _ns12__GetMapUriResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns12__GetMapUriResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns12__GetMapUriResponse, sizeof(_ns12__GetMapUriResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns12__GetMapUriResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns12__GetMapUriResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetMapUriResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMapUriResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons13__MapUriResponse(soap, "ns12:GetMapUriResult", &(a->_ns12__GetMapUriResponse::GetMapUriResult), "ns13:MapUriResponse"))
				{	soap_flag_GetMapUriResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns12:GetMapUriResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns12__GetMapUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns12__GetMapUriResponse, 0, sizeof(_ns12__GetMapUriResponse), 0, soap_copy__ns12__GetMapUriResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns12__GetMapUriResponse * SOAP_FMAC4 soap_instantiate__ns12__GetMapUriResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns12__GetMapUriResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns12__GetMapUriResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns12__GetMapUriResponse;
		if (size)
			*size = sizeof(_ns12__GetMapUriResponse);
		((_ns12__GetMapUriResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns12__GetMapUriResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns12__GetMapUriResponse);
		for (int i = 0; i < n; i++)
			((_ns12__GetMapUriResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns12__GetMapUriResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns12__GetMapUriResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns12__GetMapUriResponse %p -> %p\n", q, p));
	*(_ns12__GetMapUriResponse*)p = *(_ns12__GetMapUriResponse*)q;
}

void _ns12__GetMapUri::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns12__GetMapUri::request = NULL;
	/* transient soap skipped */
}

void _ns12__GetMapUri::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons13__MapUriRequest(soap, &this->_ns12__GetMapUri::request);
	/* transient soap skipped */
}

int _ns12__GetMapUri::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns12__GetMapUri);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns12__GetMapUri::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns12__GetMapUri(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns12__GetMapUri(struct soap *soap, const char *tag, int id, const _ns12__GetMapUri *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns12__GetMapUri), type))
		return soap->error;
	if (soap_out_PointerTons13__MapUriRequest(soap, "ns12:request", -1, &(a->_ns12__GetMapUri::request), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns12__GetMapUri::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns12__GetMapUri(soap, this, tag, type);
}

SOAP_FMAC3 _ns12__GetMapUri * SOAP_FMAC4 soap_get__ns12__GetMapUri(struct soap *soap, _ns12__GetMapUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns12__GetMapUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns12__GetMapUri::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns12__GetMapUri(soap, tag, this, type);
}

SOAP_FMAC3 _ns12__GetMapUri * SOAP_FMAC4 soap_in__ns12__GetMapUri(struct soap *soap, const char *tag, _ns12__GetMapUri *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns12__GetMapUri *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns12__GetMapUri, sizeof(_ns12__GetMapUri), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns12__GetMapUri)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns12__GetMapUri *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_request1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons13__MapUriRequest(soap, "ns12:request", &(a->_ns12__GetMapUri::request), "ns13:MapUriRequest"))
				{	soap_flag_request1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns12__GetMapUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns12__GetMapUri, 0, sizeof(_ns12__GetMapUri), 0, soap_copy__ns12__GetMapUri);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns12__GetMapUri * SOAP_FMAC4 soap_instantiate__ns12__GetMapUri(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns12__GetMapUri(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns12__GetMapUri, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns12__GetMapUri;
		if (size)
			*size = sizeof(_ns12__GetMapUri);
		((_ns12__GetMapUri*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns12__GetMapUri[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns12__GetMapUri);
		for (int i = 0; i < n; i++)
			((_ns12__GetMapUri*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns12__GetMapUri*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns12__GetMapUri(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns12__GetMapUri %p -> %p\n", q, p));
	*(_ns12__GetMapUri*)p = *(_ns12__GetMapUri*)q;
}

void _ns12__GetImageryMetadataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns12__GetImageryMetadataResponse::GetImageryMetadataResult = NULL;
	/* transient soap skipped */
}

void _ns12__GetImageryMetadataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons13__ImageryMetadataResponse(soap, &this->_ns12__GetImageryMetadataResponse::GetImageryMetadataResult);
	/* transient soap skipped */
}

int _ns12__GetImageryMetadataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns12__GetImageryMetadataResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns12__GetImageryMetadataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns12__GetImageryMetadataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns12__GetImageryMetadataResponse(struct soap *soap, const char *tag, int id, const _ns12__GetImageryMetadataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns12__GetImageryMetadataResponse), type))
		return soap->error;
	if (a->GetImageryMetadataResult)
		soap_element_result(soap, "ns12:GetImageryMetadataResult");
	if (soap_out_PointerTons13__ImageryMetadataResponse(soap, "ns12:GetImageryMetadataResult", -1, &(a->_ns12__GetImageryMetadataResponse::GetImageryMetadataResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns12__GetImageryMetadataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns12__GetImageryMetadataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns12__GetImageryMetadataResponse * SOAP_FMAC4 soap_get__ns12__GetImageryMetadataResponse(struct soap *soap, _ns12__GetImageryMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns12__GetImageryMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns12__GetImageryMetadataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns12__GetImageryMetadataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns12__GetImageryMetadataResponse * SOAP_FMAC4 soap_in__ns12__GetImageryMetadataResponse(struct soap *soap, const char *tag, _ns12__GetImageryMetadataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns12__GetImageryMetadataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns12__GetImageryMetadataResponse, sizeof(_ns12__GetImageryMetadataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns12__GetImageryMetadataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns12__GetImageryMetadataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetImageryMetadataResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetImageryMetadataResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons13__ImageryMetadataResponse(soap, "ns12:GetImageryMetadataResult", &(a->_ns12__GetImageryMetadataResponse::GetImageryMetadataResult), "ns13:ImageryMetadataResponse"))
				{	soap_flag_GetImageryMetadataResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns12:GetImageryMetadataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns12__GetImageryMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns12__GetImageryMetadataResponse, 0, sizeof(_ns12__GetImageryMetadataResponse), 0, soap_copy__ns12__GetImageryMetadataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns12__GetImageryMetadataResponse * SOAP_FMAC4 soap_instantiate__ns12__GetImageryMetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns12__GetImageryMetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns12__GetImageryMetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns12__GetImageryMetadataResponse;
		if (size)
			*size = sizeof(_ns12__GetImageryMetadataResponse);
		((_ns12__GetImageryMetadataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns12__GetImageryMetadataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns12__GetImageryMetadataResponse);
		for (int i = 0; i < n; i++)
			((_ns12__GetImageryMetadataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns12__GetImageryMetadataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns12__GetImageryMetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns12__GetImageryMetadataResponse %p -> %p\n", q, p));
	*(_ns12__GetImageryMetadataResponse*)p = *(_ns12__GetImageryMetadataResponse*)q;
}

void _ns12__GetImageryMetadata::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns12__GetImageryMetadata::request = NULL;
	/* transient soap skipped */
}

void _ns12__GetImageryMetadata::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons13__ImageryMetadataRequest(soap, &this->_ns12__GetImageryMetadata::request);
	/* transient soap skipped */
}

int _ns12__GetImageryMetadata::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns12__GetImageryMetadata);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns12__GetImageryMetadata::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns12__GetImageryMetadata(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns12__GetImageryMetadata(struct soap *soap, const char *tag, int id, const _ns12__GetImageryMetadata *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns12__GetImageryMetadata), type))
		return soap->error;
	if (soap_out_PointerTons13__ImageryMetadataRequest(soap, "ns12:request", -1, &(a->_ns12__GetImageryMetadata::request), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns12__GetImageryMetadata::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns12__GetImageryMetadata(soap, this, tag, type);
}

SOAP_FMAC3 _ns12__GetImageryMetadata * SOAP_FMAC4 soap_get__ns12__GetImageryMetadata(struct soap *soap, _ns12__GetImageryMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns12__GetImageryMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns12__GetImageryMetadata::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns12__GetImageryMetadata(soap, tag, this, type);
}

SOAP_FMAC3 _ns12__GetImageryMetadata * SOAP_FMAC4 soap_in__ns12__GetImageryMetadata(struct soap *soap, const char *tag, _ns12__GetImageryMetadata *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns12__GetImageryMetadata *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns12__GetImageryMetadata, sizeof(_ns12__GetImageryMetadata), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns12__GetImageryMetadata)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns12__GetImageryMetadata *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_request1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons13__ImageryMetadataRequest(soap, "ns12:request", &(a->_ns12__GetImageryMetadata::request), "ns13:ImageryMetadataRequest"))
				{	soap_flag_request1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns12__GetImageryMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns12__GetImageryMetadata, 0, sizeof(_ns12__GetImageryMetadata), 0, soap_copy__ns12__GetImageryMetadata);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns12__GetImageryMetadata * SOAP_FMAC4 soap_instantiate__ns12__GetImageryMetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns12__GetImageryMetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns12__GetImageryMetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns12__GetImageryMetadata;
		if (size)
			*size = sizeof(_ns12__GetImageryMetadata);
		((_ns12__GetImageryMetadata*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns12__GetImageryMetadata[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns12__GetImageryMetadata);
		for (int i = 0; i < n; i++)
			((_ns12__GetImageryMetadata*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns12__GetImageryMetadata*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns12__GetImageryMetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns12__GetImageryMetadata %p -> %p\n", q, p));
	*(_ns12__GetImageryMetadata*)p = *(_ns12__GetImageryMetadata*)q;
}

void ns10__ReverseGeocodeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns10__ReverseGeocodeRequest::Location = NULL;
	this->ns4__RequestBase::Credentials = NULL;
	soap_default_string(soap, &this->ns4__RequestBase::Culture);
	this->ns4__RequestBase::ExecutionOptions = NULL;
	this->ns4__RequestBase::UserProfile = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns10__ReverseGeocodeRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Location(soap, &this->ns10__ReverseGeocodeRequest::Location);
	soap_serialize_PointerTons4__Credentials(soap, &this->ns4__RequestBase::Credentials);
	soap_serialize_string(soap, &this->ns4__RequestBase::Culture);
	soap_serialize_PointerTons4__ExecutionOptions(soap, &this->ns4__RequestBase::ExecutionOptions);
	soap_serialize_PointerTons4__UserProfile(soap, &this->ns4__RequestBase::UserProfile);
	/* transient soap skipped */
}

int ns10__ReverseGeocodeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns10__ReverseGeocodeRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns10__ReverseGeocodeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns10__ReverseGeocodeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__ReverseGeocodeRequest(struct soap *soap, const char *tag, int id, const ns10__ReverseGeocodeRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__ReverseGeocodeRequest), "ns10:ReverseGeocodeRequest"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Credentials(soap, "ns4:Credentials", -1, &(a->ns4__RequestBase::Credentials), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Culture", -1, &(a->ns4__RequestBase::Culture), ""))
		return soap->error;
	if (soap_out_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", -1, &(a->ns4__RequestBase::ExecutionOptions), ""))
		return soap->error;
	if (soap_out_PointerTons4__UserProfile(soap, "ns4:UserProfile", -1, &(a->ns4__RequestBase::UserProfile), ""))
		return soap->error;
	if (soap_out_PointerTons4__Location(soap, "ns10:Location", -1, &(a->ns10__ReverseGeocodeRequest::Location), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns10__ReverseGeocodeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns10__ReverseGeocodeRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns10__ReverseGeocodeRequest * SOAP_FMAC4 soap_get_ns10__ReverseGeocodeRequest(struct soap *soap, ns10__ReverseGeocodeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__ReverseGeocodeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns10__ReverseGeocodeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns10__ReverseGeocodeRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns10__ReverseGeocodeRequest * SOAP_FMAC4 soap_in_ns10__ReverseGeocodeRequest(struct soap *soap, const char *tag, ns10__ReverseGeocodeRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns10__ReverseGeocodeRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__ReverseGeocodeRequest, sizeof(ns10__ReverseGeocodeRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns10__ReverseGeocodeRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns10__ReverseGeocodeRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Credentials2 = 1;
	size_t soap_flag_Culture2 = 1;
	size_t soap_flag_ExecutionOptions2 = 1;
	size_t soap_flag_UserProfile2 = 1;
	size_t soap_flag_Location1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Credentials2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Credentials(soap, "ns4:Credentials", &(a->ns4__RequestBase::Credentials), "ns4:Credentials"))
				{	soap_flag_Credentials2--;
					continue;
				}
			if (soap_flag_Culture2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Culture", &(a->ns4__RequestBase::Culture), "xsd:string"))
				{	soap_flag_Culture2--;
					continue;
				}
			if (soap_flag_ExecutionOptions2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", &(a->ns4__RequestBase::ExecutionOptions), "ns4:ExecutionOptions"))
				{	soap_flag_ExecutionOptions2--;
					continue;
				}
			if (soap_flag_UserProfile2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserProfile(soap, "ns4:UserProfile", &(a->ns4__RequestBase::UserProfile), "ns4:UserProfile"))
				{	soap_flag_UserProfile2--;
					continue;
				}
			if (soap_flag_Location1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Location(soap, "ns10:Location", &(a->ns10__ReverseGeocodeRequest::Location), "ns4:Location"))
				{	soap_flag_Location1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns10__ReverseGeocodeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__ReverseGeocodeRequest, 0, sizeof(ns10__ReverseGeocodeRequest), 0, soap_copy_ns10__ReverseGeocodeRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns10__ReverseGeocodeRequest * SOAP_FMAC4 soap_instantiate_ns10__ReverseGeocodeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns10__ReverseGeocodeRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns10__ReverseGeocodeRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns10__ReverseGeocodeRequest;
		if (size)
			*size = sizeof(ns10__ReverseGeocodeRequest);
		((ns10__ReverseGeocodeRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns10__ReverseGeocodeRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns10__ReverseGeocodeRequest);
		for (int i = 0; i < n; i++)
			((ns10__ReverseGeocodeRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns10__ReverseGeocodeRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns10__ReverseGeocodeRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns10__ReverseGeocodeRequest %p -> %p\n", q, p));
	*(ns10__ReverseGeocodeRequest*)p = *(ns10__ReverseGeocodeRequest*)q;
}

void ns10__GeocodeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns10__GeocodeResponse::Results = NULL;
	this->ns4__ResponseBase::ResponseSummary = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns10__GeocodeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfGeocodeResult(soap, &this->ns10__GeocodeResponse::Results);
	soap_serialize_PointerTons4__ResponseSummary(soap, &this->ns4__ResponseBase::ResponseSummary);
	/* transient soap skipped */
}

int ns10__GeocodeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns10__GeocodeResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns10__GeocodeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns10__GeocodeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__GeocodeResponse(struct soap *soap, const char *tag, int id, const ns10__GeocodeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__GeocodeResponse), "ns10:GeocodeResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__ResponseSummary(soap, "ns4:ResponseSummary", -1, &(a->ns4__ResponseBase::ResponseSummary), ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfGeocodeResult(soap, "ns10:Results", -1, &(a->ns10__GeocodeResponse::Results), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns10__GeocodeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns10__GeocodeResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns10__GeocodeResponse * SOAP_FMAC4 soap_get_ns10__GeocodeResponse(struct soap *soap, ns10__GeocodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__GeocodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns10__GeocodeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns10__GeocodeResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns10__GeocodeResponse * SOAP_FMAC4 soap_in_ns10__GeocodeResponse(struct soap *soap, const char *tag, ns10__GeocodeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns10__GeocodeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__GeocodeResponse, sizeof(ns10__GeocodeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns10__GeocodeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns10__GeocodeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_ResponseSummary2 = 1;
	size_t soap_flag_Results1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ResponseSummary2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ResponseSummary(soap, "ns4:ResponseSummary", &(a->ns4__ResponseBase::ResponseSummary), "ns4:ResponseSummary"))
				{	soap_flag_ResponseSummary2--;
					continue;
				}
			if (soap_flag_Results1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfGeocodeResult(soap, "ns10:Results", &(a->ns10__GeocodeResponse::Results), "ns4:ArrayOfGeocodeResult"))
				{	soap_flag_Results1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns10__GeocodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__GeocodeResponse, 0, sizeof(ns10__GeocodeResponse), 0, soap_copy_ns10__GeocodeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns10__GeocodeResponse * SOAP_FMAC4 soap_instantiate_ns10__GeocodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns10__GeocodeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns10__GeocodeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns10__GeocodeResponse;
		if (size)
			*size = sizeof(ns10__GeocodeResponse);
		((ns10__GeocodeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns10__GeocodeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns10__GeocodeResponse);
		for (int i = 0; i < n; i++)
			((ns10__GeocodeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns10__GeocodeResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns10__GeocodeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns10__GeocodeResponse %p -> %p\n", q, p));
	*(ns10__GeocodeResponse*)p = *(ns10__GeocodeResponse*)q;
}

void ns10__ConfidenceFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns10__ConfidenceFilter::MinimumConfidence = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns10__ConfidenceFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Confidence(soap, &this->ns10__ConfidenceFilter::MinimumConfidence);
	/* transient soap skipped */
}

int ns10__ConfidenceFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns10__ConfidenceFilter);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns10__ConfidenceFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns10__ConfidenceFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__ConfidenceFilter(struct soap *soap, const char *tag, int id, const ns10__ConfidenceFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__ConfidenceFilter), "ns10:ConfidenceFilter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Confidence(soap, "ns10:MinimumConfidence", -1, &(a->ns10__ConfidenceFilter::MinimumConfidence), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns10__ConfidenceFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns10__ConfidenceFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns10__ConfidenceFilter * SOAP_FMAC4 soap_get_ns10__ConfidenceFilter(struct soap *soap, ns10__ConfidenceFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__ConfidenceFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns10__ConfidenceFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns10__ConfidenceFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns10__ConfidenceFilter * SOAP_FMAC4 soap_in_ns10__ConfidenceFilter(struct soap *soap, const char *tag, ns10__ConfidenceFilter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns10__ConfidenceFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__ConfidenceFilter, sizeof(ns10__ConfidenceFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns10__ConfidenceFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns10__ConfidenceFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_MinimumConfidence1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_MinimumConfidence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Confidence(soap, "ns10:MinimumConfidence", &(a->ns10__ConfidenceFilter::MinimumConfidence), "ns4:Confidence"))
				{	soap_flag_MinimumConfidence1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns10__ConfidenceFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__ConfidenceFilter, 0, sizeof(ns10__ConfidenceFilter), 0, soap_copy_ns10__ConfidenceFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns10__ConfidenceFilter * SOAP_FMAC4 soap_instantiate_ns10__ConfidenceFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns10__ConfidenceFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns10__ConfidenceFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns10__ConfidenceFilter;
		if (size)
			*size = sizeof(ns10__ConfidenceFilter);
		((ns10__ConfidenceFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns10__ConfidenceFilter[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns10__ConfidenceFilter);
		for (int i = 0; i < n; i++)
			((ns10__ConfidenceFilter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns10__ConfidenceFilter*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns10__ConfidenceFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns10__ConfidenceFilter %p -> %p\n", q, p));
	*(ns10__ConfidenceFilter*)p = *(ns10__ConfidenceFilter*)q;
}

void ns10__FilterBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns10__FilterBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns10__FilterBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns10__FilterBase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns10__FilterBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns10__FilterBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__FilterBase(struct soap *soap, const char *tag, int id, const ns10__FilterBase *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns10:FilterBase");
}

void *ns10__FilterBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns10__FilterBase(soap, this, tag, type);
}

SOAP_FMAC3 ns10__FilterBase * SOAP_FMAC4 soap_get_ns10__FilterBase(struct soap *soap, ns10__FilterBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__FilterBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns10__FilterBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns10__FilterBase(soap, tag, this, type);
}

SOAP_FMAC3 ns10__FilterBase * SOAP_FMAC4 soap_in_ns10__FilterBase(struct soap *soap, const char *tag, ns10__FilterBase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns10__FilterBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__FilterBase, sizeof(ns10__FilterBase), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns10__FilterBase)
			return (ns10__FilterBase *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

SOAP_FMAC3 ns10__FilterBase * SOAP_FMAC4 soap_instantiate_ns10__FilterBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns10__FilterBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns10__FilterBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns10:ConfidenceFilter"))
	{	cp->type = SOAP_TYPE_ns10__ConfidenceFilter;
		if (n < 0)
		{	cp->ptr = (void*)new ns10__ConfidenceFilter;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns10__ConfidenceFilter);
			((ns10__ConfidenceFilter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns10__ConfidenceFilter[n];
			if (size)
				*size = n * sizeof(ns10__ConfidenceFilter);
			for (int i = 0; i < n; i++)
				((ns10__ConfidenceFilter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns10__ConfidenceFilter*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns10__FilterBase;
		if (size)
			*size = sizeof(ns10__FilterBase);
		((ns10__FilterBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns10__FilterBase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns10__FilterBase);
		for (int i = 0; i < n; i++)
			((ns10__FilterBase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns10__FilterBase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns10__FilterBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns10__FilterBase %p -> %p\n", q, p));
	*(ns10__FilterBase*)p = *(ns10__FilterBase*)q;
}

void ns10__ArrayOfFilterBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns10__ArrayOfFilterBase::__sizeFilterBase = 0;
	this->ns10__ArrayOfFilterBase::FilterBase = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns10__ArrayOfFilterBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns10__ArrayOfFilterBase::FilterBase)
	{	int i;
		for (i = 0; i < this->ns10__ArrayOfFilterBase::__sizeFilterBase; i++)
		{
			soap_serialize_PointerTons10__FilterBase(soap, this->ns10__ArrayOfFilterBase::FilterBase + i);
		}
	}
	/* transient soap skipped */
}

int ns10__ArrayOfFilterBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns10__ArrayOfFilterBase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns10__ArrayOfFilterBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns10__ArrayOfFilterBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__ArrayOfFilterBase(struct soap *soap, const char *tag, int id, const ns10__ArrayOfFilterBase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__ArrayOfFilterBase), "ns10:ArrayOfFilterBase"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns10__ArrayOfFilterBase::FilterBase)
	{	int i;
		for (i = 0; i < a->ns10__ArrayOfFilterBase::__sizeFilterBase; i++)
			if (soap_out_PointerTons10__FilterBase(soap, "ns10:FilterBase", -1, a->ns10__ArrayOfFilterBase::FilterBase + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns10__ArrayOfFilterBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns10__ArrayOfFilterBase(soap, this, tag, type);
}

SOAP_FMAC3 ns10__ArrayOfFilterBase * SOAP_FMAC4 soap_get_ns10__ArrayOfFilterBase(struct soap *soap, ns10__ArrayOfFilterBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__ArrayOfFilterBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns10__ArrayOfFilterBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns10__ArrayOfFilterBase(soap, tag, this, type);
}

SOAP_FMAC3 ns10__ArrayOfFilterBase * SOAP_FMAC4 soap_in_ns10__ArrayOfFilterBase(struct soap *soap, const char *tag, ns10__ArrayOfFilterBase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns10__ArrayOfFilterBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__ArrayOfFilterBase, sizeof(ns10__ArrayOfFilterBase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns10__ArrayOfFilterBase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns10__ArrayOfFilterBase *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_FilterBase1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns10:FilterBase", 1, NULL))
			{	if (a->ns10__ArrayOfFilterBase::FilterBase == NULL)
				{	if (soap_blist_FilterBase1 == NULL)
						soap_blist_FilterBase1 = soap_new_block(soap);
					a->ns10__ArrayOfFilterBase::FilterBase = (ns10__FilterBase **)soap_push_block(soap, soap_blist_FilterBase1, sizeof(ns10__FilterBase *));
					if (a->ns10__ArrayOfFilterBase::FilterBase == NULL)
						return NULL;
					*a->ns10__ArrayOfFilterBase::FilterBase = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons10__FilterBase(soap, "ns10:FilterBase", a->ns10__ArrayOfFilterBase::FilterBase, "ns10:FilterBase"))
				{	a->ns10__ArrayOfFilterBase::__sizeFilterBase++;
					a->ns10__ArrayOfFilterBase::FilterBase = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns10__ArrayOfFilterBase::FilterBase)
			soap_pop_block(soap, soap_blist_FilterBase1);
		if (a->ns10__ArrayOfFilterBase::__sizeFilterBase)
			a->ns10__ArrayOfFilterBase::FilterBase = (ns10__FilterBase **)soap_save_block(soap, soap_blist_FilterBase1, NULL, 1);
		else
		{	a->ns10__ArrayOfFilterBase::FilterBase = NULL;
			if (soap_blist_FilterBase1)
				soap_end_block(soap, soap_blist_FilterBase1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns10__ArrayOfFilterBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__ArrayOfFilterBase, 0, sizeof(ns10__ArrayOfFilterBase), 0, soap_copy_ns10__ArrayOfFilterBase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns10__ArrayOfFilterBase * SOAP_FMAC4 soap_instantiate_ns10__ArrayOfFilterBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns10__ArrayOfFilterBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns10__ArrayOfFilterBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns10__ArrayOfFilterBase;
		if (size)
			*size = sizeof(ns10__ArrayOfFilterBase);
		((ns10__ArrayOfFilterBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns10__ArrayOfFilterBase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns10__ArrayOfFilterBase);
		for (int i = 0; i < n; i++)
			((ns10__ArrayOfFilterBase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns10__ArrayOfFilterBase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns10__ArrayOfFilterBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns10__ArrayOfFilterBase %p -> %p\n", q, p));
	*(ns10__ArrayOfFilterBase*)p = *(ns10__ArrayOfFilterBase*)q;
}

void ns10__GeocodeOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns10__GeocodeOptions::Count = NULL;
	this->ns10__GeocodeOptions::Filters = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns10__GeocodeOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns10__GeocodeOptions::Count);
	soap_serialize_PointerTons10__ArrayOfFilterBase(soap, &this->ns10__GeocodeOptions::Filters);
	/* transient soap skipped */
}

int ns10__GeocodeOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns10__GeocodeOptions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns10__GeocodeOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns10__GeocodeOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__GeocodeOptions(struct soap *soap, const char *tag, int id, const ns10__GeocodeOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__GeocodeOptions), "ns10:GeocodeOptions"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToint(soap, "ns10:Count", -1, &(a->ns10__GeocodeOptions::Count), ""))
		return soap->error;
	if (soap_out_PointerTons10__ArrayOfFilterBase(soap, "ns10:Filters", -1, &(a->ns10__GeocodeOptions::Filters), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns10__GeocodeOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns10__GeocodeOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns10__GeocodeOptions * SOAP_FMAC4 soap_get_ns10__GeocodeOptions(struct soap *soap, ns10__GeocodeOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__GeocodeOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns10__GeocodeOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns10__GeocodeOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns10__GeocodeOptions * SOAP_FMAC4 soap_in_ns10__GeocodeOptions(struct soap *soap, const char *tag, ns10__GeocodeOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns10__GeocodeOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__GeocodeOptions, sizeof(ns10__GeocodeOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns10__GeocodeOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns10__GeocodeOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Count1 = 1;
	size_t soap_flag_Filters1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns10:Count", &(a->ns10__GeocodeOptions::Count), "xsd:int"))
				{	soap_flag_Count1--;
					continue;
				}
			if (soap_flag_Filters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons10__ArrayOfFilterBase(soap, "ns10:Filters", &(a->ns10__GeocodeOptions::Filters), "ns10:ArrayOfFilterBase"))
				{	soap_flag_Filters1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns10__GeocodeOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__GeocodeOptions, 0, sizeof(ns10__GeocodeOptions), 0, soap_copy_ns10__GeocodeOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns10__GeocodeOptions * SOAP_FMAC4 soap_instantiate_ns10__GeocodeOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns10__GeocodeOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns10__GeocodeOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns10__GeocodeOptions;
		if (size)
			*size = sizeof(ns10__GeocodeOptions);
		((ns10__GeocodeOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns10__GeocodeOptions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns10__GeocodeOptions);
		for (int i = 0; i < n; i++)
			((ns10__GeocodeOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns10__GeocodeOptions*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns10__GeocodeOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns10__GeocodeOptions %p -> %p\n", q, p));
	*(ns10__GeocodeOptions*)p = *(ns10__GeocodeOptions*)q;
}

void ns10__GeocodeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns10__GeocodeRequest::Address = NULL;
	this->ns10__GeocodeRequest::Options = NULL;
	soap_default_string(soap, &this->ns10__GeocodeRequest::Query);
	this->ns4__RequestBase::Credentials = NULL;
	soap_default_string(soap, &this->ns4__RequestBase::Culture);
	this->ns4__RequestBase::ExecutionOptions = NULL;
	this->ns4__RequestBase::UserProfile = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns10__GeocodeRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Address(soap, &this->ns10__GeocodeRequest::Address);
	soap_serialize_PointerTons10__GeocodeOptions(soap, &this->ns10__GeocodeRequest::Options);
	soap_serialize_string(soap, &this->ns10__GeocodeRequest::Query);
	soap_serialize_PointerTons4__Credentials(soap, &this->ns4__RequestBase::Credentials);
	soap_serialize_string(soap, &this->ns4__RequestBase::Culture);
	soap_serialize_PointerTons4__ExecutionOptions(soap, &this->ns4__RequestBase::ExecutionOptions);
	soap_serialize_PointerTons4__UserProfile(soap, &this->ns4__RequestBase::UserProfile);
	/* transient soap skipped */
}

int ns10__GeocodeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns10__GeocodeRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns10__GeocodeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns10__GeocodeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__GeocodeRequest(struct soap *soap, const char *tag, int id, const ns10__GeocodeRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__GeocodeRequest), "ns10:GeocodeRequest"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Credentials(soap, "ns4:Credentials", -1, &(a->ns4__RequestBase::Credentials), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Culture", -1, &(a->ns4__RequestBase::Culture), ""))
		return soap->error;
	if (soap_out_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", -1, &(a->ns4__RequestBase::ExecutionOptions), ""))
		return soap->error;
	if (soap_out_PointerTons4__UserProfile(soap, "ns4:UserProfile", -1, &(a->ns4__RequestBase::UserProfile), ""))
		return soap->error;
	if (soap_out_PointerTons4__Address(soap, "ns10:Address", -1, &(a->ns10__GeocodeRequest::Address), ""))
		return soap->error;
	if (soap_out_PointerTons10__GeocodeOptions(soap, "ns10:Options", -1, &(a->ns10__GeocodeRequest::Options), ""))
		return soap->error;
	if (soap_out_string(soap, "ns10:Query", -1, &(a->ns10__GeocodeRequest::Query), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns10__GeocodeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns10__GeocodeRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns10__GeocodeRequest * SOAP_FMAC4 soap_get_ns10__GeocodeRequest(struct soap *soap, ns10__GeocodeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__GeocodeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns10__GeocodeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns10__GeocodeRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns10__GeocodeRequest * SOAP_FMAC4 soap_in_ns10__GeocodeRequest(struct soap *soap, const char *tag, ns10__GeocodeRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns10__GeocodeRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__GeocodeRequest, sizeof(ns10__GeocodeRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns10__GeocodeRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns10__GeocodeRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Credentials2 = 1;
	size_t soap_flag_Culture2 = 1;
	size_t soap_flag_ExecutionOptions2 = 1;
	size_t soap_flag_UserProfile2 = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_Options1 = 1;
	size_t soap_flag_Query1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Credentials2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Credentials(soap, "ns4:Credentials", &(a->ns4__RequestBase::Credentials), "ns4:Credentials"))
				{	soap_flag_Credentials2--;
					continue;
				}
			if (soap_flag_Culture2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Culture", &(a->ns4__RequestBase::Culture), "xsd:string"))
				{	soap_flag_Culture2--;
					continue;
				}
			if (soap_flag_ExecutionOptions2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", &(a->ns4__RequestBase::ExecutionOptions), "ns4:ExecutionOptions"))
				{	soap_flag_ExecutionOptions2--;
					continue;
				}
			if (soap_flag_UserProfile2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserProfile(soap, "ns4:UserProfile", &(a->ns4__RequestBase::UserProfile), "ns4:UserProfile"))
				{	soap_flag_UserProfile2--;
					continue;
				}
			if (soap_flag_Address1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Address(soap, "ns10:Address", &(a->ns10__GeocodeRequest::Address), "ns4:Address"))
				{	soap_flag_Address1--;
					continue;
				}
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons10__GeocodeOptions(soap, "ns10:Options", &(a->ns10__GeocodeRequest::Options), "ns10:GeocodeOptions"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap_flag_Query1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns10:Query", &(a->ns10__GeocodeRequest::Query), "xsd:string"))
				{	soap_flag_Query1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns10__GeocodeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns10__GeocodeRequest, 0, sizeof(ns10__GeocodeRequest), 0, soap_copy_ns10__GeocodeRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns10__GeocodeRequest * SOAP_FMAC4 soap_instantiate_ns10__GeocodeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns10__GeocodeRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns10__GeocodeRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns10__GeocodeRequest;
		if (size)
			*size = sizeof(ns10__GeocodeRequest);
		((ns10__GeocodeRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns10__GeocodeRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns10__GeocodeRequest);
		for (int i = 0; i < n; i++)
			((ns10__GeocodeRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns10__GeocodeRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns10__GeocodeRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns10__GeocodeRequest %p -> %p\n", q, p));
	*(ns10__GeocodeRequest*)p = *(ns10__GeocodeRequest*)q;
}

void _ns9__ReverseGeocodeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns9__ReverseGeocodeResponse::ReverseGeocodeResult = NULL;
	/* transient soap skipped */
}

void _ns9__ReverseGeocodeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons10__GeocodeResponse(soap, &this->_ns9__ReverseGeocodeResponse::ReverseGeocodeResult);
	/* transient soap skipped */
}

int _ns9__ReverseGeocodeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns9__ReverseGeocodeResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns9__ReverseGeocodeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns9__ReverseGeocodeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns9__ReverseGeocodeResponse(struct soap *soap, const char *tag, int id, const _ns9__ReverseGeocodeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns9__ReverseGeocodeResponse), type))
		return soap->error;
	if (a->ReverseGeocodeResult)
		soap_element_result(soap, "ns9:ReverseGeocodeResult");
	if (soap_out_PointerTons10__GeocodeResponse(soap, "ns9:ReverseGeocodeResult", -1, &(a->_ns9__ReverseGeocodeResponse::ReverseGeocodeResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns9__ReverseGeocodeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns9__ReverseGeocodeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns9__ReverseGeocodeResponse * SOAP_FMAC4 soap_get__ns9__ReverseGeocodeResponse(struct soap *soap, _ns9__ReverseGeocodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns9__ReverseGeocodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns9__ReverseGeocodeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns9__ReverseGeocodeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns9__ReverseGeocodeResponse * SOAP_FMAC4 soap_in__ns9__ReverseGeocodeResponse(struct soap *soap, const char *tag, _ns9__ReverseGeocodeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns9__ReverseGeocodeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns9__ReverseGeocodeResponse, sizeof(_ns9__ReverseGeocodeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns9__ReverseGeocodeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns9__ReverseGeocodeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ReverseGeocodeResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReverseGeocodeResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons10__GeocodeResponse(soap, "ns9:ReverseGeocodeResult", &(a->_ns9__ReverseGeocodeResponse::ReverseGeocodeResult), "ns10:GeocodeResponse"))
				{	soap_flag_ReverseGeocodeResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns9:ReverseGeocodeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns9__ReverseGeocodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns9__ReverseGeocodeResponse, 0, sizeof(_ns9__ReverseGeocodeResponse), 0, soap_copy__ns9__ReverseGeocodeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns9__ReverseGeocodeResponse * SOAP_FMAC4 soap_instantiate__ns9__ReverseGeocodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns9__ReverseGeocodeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns9__ReverseGeocodeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns9__ReverseGeocodeResponse;
		if (size)
			*size = sizeof(_ns9__ReverseGeocodeResponse);
		((_ns9__ReverseGeocodeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns9__ReverseGeocodeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns9__ReverseGeocodeResponse);
		for (int i = 0; i < n; i++)
			((_ns9__ReverseGeocodeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns9__ReverseGeocodeResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns9__ReverseGeocodeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns9__ReverseGeocodeResponse %p -> %p\n", q, p));
	*(_ns9__ReverseGeocodeResponse*)p = *(_ns9__ReverseGeocodeResponse*)q;
}

void _ns9__ReverseGeocode::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns9__ReverseGeocode::request = NULL;
	/* transient soap skipped */
}

void _ns9__ReverseGeocode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons10__ReverseGeocodeRequest(soap, &this->_ns9__ReverseGeocode::request);
	/* transient soap skipped */
}

int _ns9__ReverseGeocode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns9__ReverseGeocode);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns9__ReverseGeocode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns9__ReverseGeocode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns9__ReverseGeocode(struct soap *soap, const char *tag, int id, const _ns9__ReverseGeocode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns9__ReverseGeocode), type))
		return soap->error;
	if (soap_out_PointerTons10__ReverseGeocodeRequest(soap, "ns9:request", -1, &(a->_ns9__ReverseGeocode::request), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns9__ReverseGeocode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns9__ReverseGeocode(soap, this, tag, type);
}

SOAP_FMAC3 _ns9__ReverseGeocode * SOAP_FMAC4 soap_get__ns9__ReverseGeocode(struct soap *soap, _ns9__ReverseGeocode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns9__ReverseGeocode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns9__ReverseGeocode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns9__ReverseGeocode(soap, tag, this, type);
}

SOAP_FMAC3 _ns9__ReverseGeocode * SOAP_FMAC4 soap_in__ns9__ReverseGeocode(struct soap *soap, const char *tag, _ns9__ReverseGeocode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns9__ReverseGeocode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns9__ReverseGeocode, sizeof(_ns9__ReverseGeocode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns9__ReverseGeocode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns9__ReverseGeocode *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_request1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons10__ReverseGeocodeRequest(soap, "ns9:request", &(a->_ns9__ReverseGeocode::request), "ns10:ReverseGeocodeRequest"))
				{	soap_flag_request1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns9__ReverseGeocode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns9__ReverseGeocode, 0, sizeof(_ns9__ReverseGeocode), 0, soap_copy__ns9__ReverseGeocode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns9__ReverseGeocode * SOAP_FMAC4 soap_instantiate__ns9__ReverseGeocode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns9__ReverseGeocode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns9__ReverseGeocode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns9__ReverseGeocode;
		if (size)
			*size = sizeof(_ns9__ReverseGeocode);
		((_ns9__ReverseGeocode*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns9__ReverseGeocode[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns9__ReverseGeocode);
		for (int i = 0; i < n; i++)
			((_ns9__ReverseGeocode*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns9__ReverseGeocode*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns9__ReverseGeocode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns9__ReverseGeocode %p -> %p\n", q, p));
	*(_ns9__ReverseGeocode*)p = *(_ns9__ReverseGeocode*)q;
}

void _ns9__GeocodeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns9__GeocodeResponse::GeocodeResult = NULL;
	/* transient soap skipped */
}

void _ns9__GeocodeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons10__GeocodeResponse(soap, &this->_ns9__GeocodeResponse::GeocodeResult);
	/* transient soap skipped */
}

int _ns9__GeocodeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns9__GeocodeResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns9__GeocodeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns9__GeocodeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns9__GeocodeResponse(struct soap *soap, const char *tag, int id, const _ns9__GeocodeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns9__GeocodeResponse), type))
		return soap->error;
	if (a->GeocodeResult)
		soap_element_result(soap, "ns9:GeocodeResult");
	if (soap_out_PointerTons10__GeocodeResponse(soap, "ns9:GeocodeResult", -1, &(a->_ns9__GeocodeResponse::GeocodeResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns9__GeocodeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns9__GeocodeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns9__GeocodeResponse * SOAP_FMAC4 soap_get__ns9__GeocodeResponse(struct soap *soap, _ns9__GeocodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns9__GeocodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns9__GeocodeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns9__GeocodeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns9__GeocodeResponse * SOAP_FMAC4 soap_in__ns9__GeocodeResponse(struct soap *soap, const char *tag, _ns9__GeocodeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns9__GeocodeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns9__GeocodeResponse, sizeof(_ns9__GeocodeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns9__GeocodeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns9__GeocodeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GeocodeResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GeocodeResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons10__GeocodeResponse(soap, "ns9:GeocodeResult", &(a->_ns9__GeocodeResponse::GeocodeResult), "ns10:GeocodeResponse"))
				{	soap_flag_GeocodeResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns9:GeocodeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns9__GeocodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns9__GeocodeResponse, 0, sizeof(_ns9__GeocodeResponse), 0, soap_copy__ns9__GeocodeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns9__GeocodeResponse * SOAP_FMAC4 soap_instantiate__ns9__GeocodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns9__GeocodeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns9__GeocodeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns9__GeocodeResponse;
		if (size)
			*size = sizeof(_ns9__GeocodeResponse);
		((_ns9__GeocodeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns9__GeocodeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns9__GeocodeResponse);
		for (int i = 0; i < n; i++)
			((_ns9__GeocodeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns9__GeocodeResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns9__GeocodeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns9__GeocodeResponse %p -> %p\n", q, p));
	*(_ns9__GeocodeResponse*)p = *(_ns9__GeocodeResponse*)q;
}

void _ns9__Geocode::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns9__Geocode::request = NULL;
	/* transient soap skipped */
}

void _ns9__Geocode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons10__GeocodeRequest(soap, &this->_ns9__Geocode::request);
	/* transient soap skipped */
}

int _ns9__Geocode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns9__Geocode);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns9__Geocode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns9__Geocode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns9__Geocode(struct soap *soap, const char *tag, int id, const _ns9__Geocode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns9__Geocode), type))
		return soap->error;
	if (soap_out_PointerTons10__GeocodeRequest(soap, "ns9:request", -1, &(a->_ns9__Geocode::request), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns9__Geocode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns9__Geocode(soap, this, tag, type);
}

SOAP_FMAC3 _ns9__Geocode * SOAP_FMAC4 soap_get__ns9__Geocode(struct soap *soap, _ns9__Geocode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns9__Geocode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns9__Geocode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns9__Geocode(soap, tag, this, type);
}

SOAP_FMAC3 _ns9__Geocode * SOAP_FMAC4 soap_in__ns9__Geocode(struct soap *soap, const char *tag, _ns9__Geocode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns9__Geocode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns9__Geocode, sizeof(_ns9__Geocode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns9__Geocode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns9__Geocode *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_request1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons10__GeocodeRequest(soap, "ns9:request", &(a->_ns9__Geocode::request), "ns10:GeocodeRequest"))
				{	soap_flag_request1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns9__Geocode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns9__Geocode, 0, sizeof(_ns9__Geocode), 0, soap_copy__ns9__Geocode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns9__Geocode * SOAP_FMAC4 soap_instantiate__ns9__Geocode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns9__Geocode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns9__Geocode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns9__Geocode;
		if (size)
			*size = sizeof(_ns9__Geocode);
		((_ns9__Geocode*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns9__Geocode[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns9__Geocode);
		for (int i = 0; i < n; i++)
			((_ns9__Geocode*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns9__Geocode*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns9__Geocode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns9__Geocode %p -> %p\n", q, p));
	*(_ns9__Geocode*)p = *(_ns9__Geocode*)q;
}

void ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::__sizeKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s = 0;
	this->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s)
	{	int i;
		for (i = 0; i < this->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::__sizeKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s; i++)
		{
			soap_embedded(soap, this->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s + i, SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
			this->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, const char *tag, int id, const ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s), "ns7:ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_P9s"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s)
	{	int i;
		for (i = 0; i < a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::__sizeKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s; i++)
			if (a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s[i].soap_out(soap, "ns7:KeyValueOfintCategorySpecificPropertySetn6Q9q_P9s", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s * SOAP_FMAC4 soap_get_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s * SOAP_FMAC4 soap_in_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, const char *tag, ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s, sizeof(ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:KeyValueOfintCategorySpecificPropertySetn6Q9q_P9s", 1, NULL))
			{	if (a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s == NULL)
				{	if (soap_blist_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s1 == NULL)
						soap_blist_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s1 = soap_new_block(soap);
					a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s = (_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *)soap_push_block(soap, soap_blist_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s1, sizeof(_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s));
					if (a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s == NULL)
						return NULL;
					_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s p;
					memcpy(a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s, &p, sizeof(_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s)); // a bit rough but portable
					a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s->soap_default(soap);
				}soap_revert(soap);
				if (soap_in__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, "ns7:KeyValueOfintCategorySpecificPropertySetn6Q9q_P9s", a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s, ""))
				{	a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::__sizeKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s++;
					a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s)
			soap_pop_block(soap, soap_blist_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s1);
		if (a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::__sizeKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s)
			a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s = (_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *)soap_save_block(soap, soap_blist_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s1, NULL, 1);
		else
		{	a->ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s::KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s = NULL;
			if (soap_blist_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s1)
				soap_end_block(soap, soap_blist_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s, 0, sizeof(ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s), 0, soap_copy_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s * SOAP_FMAC4 soap_instantiate_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s;
		if (size)
			*size = sizeof(ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
		((ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
		for (int i = 0; i < n; i++)
			((ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s %p -> %p\n", q, p));
	*(ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)p = *(ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)q;
}

void ns7__ArrayOfKeyValueOfstringanyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__ArrayOfKeyValueOfstringanyType::__sizeKeyValueOfstringanyType = 0;
	this->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns7__ArrayOfKeyValueOfstringanyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType)
	{	int i;
		for (i = 0; i < this->ns7__ArrayOfKeyValueOfstringanyType::__sizeKeyValueOfstringanyType; i++)
		{
			soap_embedded(soap, this->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType + i, SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType);
			this->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int ns7__ArrayOfKeyValueOfstringanyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__ArrayOfKeyValueOfstringanyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ArrayOfKeyValueOfstringanyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ArrayOfKeyValueOfstringanyType(struct soap *soap, const char *tag, int id, const ns7__ArrayOfKeyValueOfstringanyType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType), "ns7:ArrayOfKeyValueOfstringanyType"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType)
	{	int i;
		for (i = 0; i < a->ns7__ArrayOfKeyValueOfstringanyType::__sizeKeyValueOfstringanyType; i++)
			if (a->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType[i].soap_out(soap, "ns7:KeyValueOfstringanyType", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns7__ArrayOfKeyValueOfstringanyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ArrayOfKeyValueOfstringanyType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfstringanyType * SOAP_FMAC4 soap_get_ns7__ArrayOfKeyValueOfstringanyType(struct soap *soap, ns7__ArrayOfKeyValueOfstringanyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__ArrayOfKeyValueOfstringanyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns7__ArrayOfKeyValueOfstringanyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__ArrayOfKeyValueOfstringanyType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfstringanyType * SOAP_FMAC4 soap_in_ns7__ArrayOfKeyValueOfstringanyType(struct soap *soap, const char *tag, ns7__ArrayOfKeyValueOfstringanyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ArrayOfKeyValueOfstringanyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType, sizeof(ns7__ArrayOfKeyValueOfstringanyType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ArrayOfKeyValueOfstringanyType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_KeyValueOfstringanyType1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:KeyValueOfstringanyType", 1, NULL))
			{	if (a->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType == NULL)
				{	if (soap_blist_KeyValueOfstringanyType1 == NULL)
						soap_blist_KeyValueOfstringanyType1 = soap_new_block(soap);
					a->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType = (_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *)soap_push_block(soap, soap_blist_KeyValueOfstringanyType1, sizeof(_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType));
					if (a->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType == NULL)
						return NULL;
					_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType p;
					memcpy(a->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType, &p, sizeof(_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType)); // a bit rough but portable
					a->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType->soap_default(soap);
				}soap_revert(soap);
				if (soap_in__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(soap, "ns7:KeyValueOfstringanyType", a->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType, ""))
				{	a->ns7__ArrayOfKeyValueOfstringanyType::__sizeKeyValueOfstringanyType++;
					a->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType)
			soap_pop_block(soap, soap_blist_KeyValueOfstringanyType1);
		if (a->ns7__ArrayOfKeyValueOfstringanyType::__sizeKeyValueOfstringanyType)
			a->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType = (_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *)soap_save_block(soap, soap_blist_KeyValueOfstringanyType1, NULL, 1);
		else
		{	a->ns7__ArrayOfKeyValueOfstringanyType::KeyValueOfstringanyType = NULL;
			if (soap_blist_KeyValueOfstringanyType1)
				soap_end_block(soap, soap_blist_KeyValueOfstringanyType1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__ArrayOfKeyValueOfstringanyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType, 0, sizeof(ns7__ArrayOfKeyValueOfstringanyType), 0, soap_copy_ns7__ArrayOfKeyValueOfstringanyType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfstringanyType * SOAP_FMAC4 soap_instantiate_ns7__ArrayOfKeyValueOfstringanyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ArrayOfKeyValueOfstringanyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__ArrayOfKeyValueOfstringanyType;
		if (size)
			*size = sizeof(ns7__ArrayOfKeyValueOfstringanyType);
		((ns7__ArrayOfKeyValueOfstringanyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__ArrayOfKeyValueOfstringanyType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns7__ArrayOfKeyValueOfstringanyType);
		for (int i = 0; i < n; i++)
			((ns7__ArrayOfKeyValueOfstringanyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ArrayOfKeyValueOfstringanyType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ArrayOfKeyValueOfstringanyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ArrayOfKeyValueOfstringanyType %p -> %p\n", q, p));
	*(ns7__ArrayOfKeyValueOfstringanyType*)p = *(ns7__ArrayOfKeyValueOfstringanyType*)q;
}

void ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::__sizeKeyValueOfNeighborhoodintkC8b0tr6 = 0;
	this->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6 = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6)
	{	int i;
		for (i = 0; i < this->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::__sizeKeyValueOfNeighborhoodintkC8b0tr6; i++)
		{
			soap_embedded(soap, this->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6 + i, SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6);
			this->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, const char *tag, int id, const ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6), "ns7:ArrayOfKeyValueOfNeighborhoodintkC8b0tr6"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6)
	{	int i;
		for (i = 0; i < a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::__sizeKeyValueOfNeighborhoodintkC8b0tr6; i++)
			if (a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6[i].soap_out(soap, "ns7:KeyValueOfNeighborhoodintkC8b0tr6", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 * SOAP_FMAC4 soap_get_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 * SOAP_FMAC4 soap_in_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, const char *tag, ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6, sizeof(ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_KeyValueOfNeighborhoodintkC8b0tr61 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:KeyValueOfNeighborhoodintkC8b0tr6", 1, NULL))
			{	if (a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6 == NULL)
				{	if (soap_blist_KeyValueOfNeighborhoodintkC8b0tr61 == NULL)
						soap_blist_KeyValueOfNeighborhoodintkC8b0tr61 = soap_new_block(soap);
					a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6 = (_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *)soap_push_block(soap, soap_blist_KeyValueOfNeighborhoodintkC8b0tr61, sizeof(_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6));
					if (a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6 == NULL)
						return NULL;
					_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 p;
					memcpy(a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6, &p, sizeof(_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6)); // a bit rough but portable
					a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6->soap_default(soap);
				}soap_revert(soap);
				if (soap_in__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(soap, "ns7:KeyValueOfNeighborhoodintkC8b0tr6", a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6, ""))
				{	a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::__sizeKeyValueOfNeighborhoodintkC8b0tr6++;
					a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6 = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6)
			soap_pop_block(soap, soap_blist_KeyValueOfNeighborhoodintkC8b0tr61);
		if (a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::__sizeKeyValueOfNeighborhoodintkC8b0tr6)
			a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6 = (_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *)soap_save_block(soap, soap_blist_KeyValueOfNeighborhoodintkC8b0tr61, NULL, 1);
		else
		{	a->ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6::KeyValueOfNeighborhoodintkC8b0tr6 = NULL;
			if (soap_blist_KeyValueOfNeighborhoodintkC8b0tr61)
				soap_end_block(soap, soap_blist_KeyValueOfNeighborhoodintkC8b0tr61);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6, 0, sizeof(ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6), 0, soap_copy_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 * SOAP_FMAC4 soap_instantiate_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6;
		if (size)
			*size = sizeof(ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6);
		((ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6);
		for (int i = 0; i < n; i++)
			((ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 %p -> %p\n", q, p));
	*(ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6*)p = *(ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6*)q;
}

void ns7__ArrayOfanyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__ArrayOfanyType::__sizeanyType = 0;
	this->ns7__ArrayOfanyType::anyType = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns7__ArrayOfanyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns7__ArrayOfanyType::anyType)
	{	int i;
		for (i = 0; i < this->ns7__ArrayOfanyType::__sizeanyType; i++)
		{
			soap_serialize_PointerToxsd__anyType(soap, this->ns7__ArrayOfanyType::anyType + i);
		}
	}
	/* transient soap skipped */
}

int ns7__ArrayOfanyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ArrayOfanyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__ArrayOfanyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ArrayOfanyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ArrayOfanyType(struct soap *soap, const char *tag, int id, const ns7__ArrayOfanyType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ArrayOfanyType), "ns7:ArrayOfanyType"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns7__ArrayOfanyType::anyType)
	{	int i;
		for (i = 0; i < a->ns7__ArrayOfanyType::__sizeanyType; i++)
			if (soap_out_PointerToxsd__anyType(soap, "ns7:anyType", -1, a->ns7__ArrayOfanyType::anyType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns7__ArrayOfanyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ArrayOfanyType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ArrayOfanyType * SOAP_FMAC4 soap_get_ns7__ArrayOfanyType(struct soap *soap, ns7__ArrayOfanyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__ArrayOfanyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns7__ArrayOfanyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__ArrayOfanyType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ArrayOfanyType * SOAP_FMAC4 soap_in_ns7__ArrayOfanyType(struct soap *soap, const char *tag, ns7__ArrayOfanyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ArrayOfanyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ArrayOfanyType, sizeof(ns7__ArrayOfanyType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__ArrayOfanyType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ArrayOfanyType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_anyType1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:anyType", 1, NULL))
			{	if (a->ns7__ArrayOfanyType::anyType == NULL)
				{	if (soap_blist_anyType1 == NULL)
						soap_blist_anyType1 = soap_new_block(soap);
					a->ns7__ArrayOfanyType::anyType = (xsd__anyType **)soap_push_block(soap, soap_blist_anyType1, sizeof(xsd__anyType *));
					if (a->ns7__ArrayOfanyType::anyType == NULL)
						return NULL;
					*a->ns7__ArrayOfanyType::anyType = NULL;
				}soap_revert(soap);
				if (soap_in_PointerToxsd__anyType(soap, "ns7:anyType", a->ns7__ArrayOfanyType::anyType, "xsd:anyType"))
				{	a->ns7__ArrayOfanyType::__sizeanyType++;
					a->ns7__ArrayOfanyType::anyType = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns7__ArrayOfanyType::anyType)
			soap_pop_block(soap, soap_blist_anyType1);
		if (a->ns7__ArrayOfanyType::__sizeanyType)
			a->ns7__ArrayOfanyType::anyType = (xsd__anyType **)soap_save_block(soap, soap_blist_anyType1, NULL, 1);
		else
		{	a->ns7__ArrayOfanyType::anyType = NULL;
			if (soap_blist_anyType1)
				soap_end_block(soap, soap_blist_anyType1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__ArrayOfanyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ArrayOfanyType, 0, sizeof(ns7__ArrayOfanyType), 0, soap_copy_ns7__ArrayOfanyType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns7__ArrayOfanyType * SOAP_FMAC4 soap_instantiate_ns7__ArrayOfanyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ArrayOfanyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ArrayOfanyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__ArrayOfanyType;
		if (size)
			*size = sizeof(ns7__ArrayOfanyType);
		((ns7__ArrayOfanyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__ArrayOfanyType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns7__ArrayOfanyType);
		for (int i = 0; i < n; i++)
			((ns7__ArrayOfanyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ArrayOfanyType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ArrayOfanyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ArrayOfanyType %p -> %p\n", q, p));
	*(ns7__ArrayOfanyType*)p = *(ns7__ArrayOfanyType*)q;
}

void ns7__ArrayOfstring::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__ArrayOfstring::__sizestring = 0;
	this->ns7__ArrayOfstring::string = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns7__ArrayOfstring::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns7__ArrayOfstring::string)
	{	int i;
		for (i = 0; i < this->ns7__ArrayOfstring::__sizestring; i++)
		{
			soap_serialize_string(soap, this->ns7__ArrayOfstring::string + i);
		}
	}
	/* transient soap skipped */
}

int ns7__ArrayOfstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ArrayOfstring);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__ArrayOfstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ArrayOfstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ArrayOfstring(struct soap *soap, const char *tag, int id, const ns7__ArrayOfstring *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ArrayOfstring), "ns7:ArrayOfstring"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns7__ArrayOfstring::string)
	{	int i;
		for (i = 0; i < a->ns7__ArrayOfstring::__sizestring; i++)
			if (soap_out_string(soap, "ns7:string", -1, a->ns7__ArrayOfstring::string + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns7__ArrayOfstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ArrayOfstring(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ArrayOfstring * SOAP_FMAC4 soap_get_ns7__ArrayOfstring(struct soap *soap, ns7__ArrayOfstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns7__ArrayOfstring::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__ArrayOfstring(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ArrayOfstring * SOAP_FMAC4 soap_in_ns7__ArrayOfstring(struct soap *soap, const char *tag, ns7__ArrayOfstring *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ArrayOfstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ArrayOfstring, sizeof(ns7__ArrayOfstring), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__ArrayOfstring)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ArrayOfstring *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_string1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:string", 1, NULL))
			{	if (a->ns7__ArrayOfstring::string == NULL)
				{	if (soap_blist_string1 == NULL)
						soap_blist_string1 = soap_new_block(soap);
					a->ns7__ArrayOfstring::string = (char **)soap_push_block(soap, soap_blist_string1, sizeof(char *));
					if (a->ns7__ArrayOfstring::string == NULL)
						return NULL;
					*a->ns7__ArrayOfstring::string = NULL;
				}soap_revert(soap);
				if (soap_in_string(soap, "ns7:string", a->ns7__ArrayOfstring::string, "xsd:string"))
				{	a->ns7__ArrayOfstring::__sizestring++;
					a->ns7__ArrayOfstring::string = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns7__ArrayOfstring::string)
			soap_pop_block(soap, soap_blist_string1);
		if (a->ns7__ArrayOfstring::__sizestring)
			a->ns7__ArrayOfstring::string = (char **)soap_save_block(soap, soap_blist_string1, NULL, 1);
		else
		{	a->ns7__ArrayOfstring::string = NULL;
			if (soap_blist_string1)
				soap_end_block(soap, soap_blist_string1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__ArrayOfstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ArrayOfstring, 0, sizeof(ns7__ArrayOfstring), 0, soap_copy_ns7__ArrayOfstring);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns7__ArrayOfstring * SOAP_FMAC4 soap_instantiate_ns7__ArrayOfstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ArrayOfstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ArrayOfstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__ArrayOfstring;
		if (size)
			*size = sizeof(ns7__ArrayOfstring);
		((ns7__ArrayOfstring*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__ArrayOfstring[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns7__ArrayOfstring);
		for (int i = 0; i < n; i++)
			((ns7__ArrayOfstring*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ArrayOfstring*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ArrayOfstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ArrayOfstring %p -> %p\n", q, p));
	*(ns7__ArrayOfstring*)p = *(ns7__ArrayOfstring*)q;
}

void ns6__SearchPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__SearchPoint::Point = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__SearchPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Location(soap, &this->ns6__SearchPoint::Point);
	/* transient soap skipped */
}

int ns6__SearchPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__SearchPoint);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__SearchPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SearchPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SearchPoint(struct soap *soap, const char *tag, int id, const ns6__SearchPoint *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SearchPoint), "ns6:SearchPoint"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Location(soap, "ns6:Point", -1, &(a->ns6__SearchPoint::Point), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__SearchPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SearchPoint(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SearchPoint * SOAP_FMAC4 soap_get_ns6__SearchPoint(struct soap *soap, ns6__SearchPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SearchPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__SearchPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__SearchPoint(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SearchPoint * SOAP_FMAC4 soap_in_ns6__SearchPoint(struct soap *soap, const char *tag, ns6__SearchPoint *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SearchPoint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SearchPoint, sizeof(ns6__SearchPoint), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__SearchPoint)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__SearchPoint *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Point1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Point1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Location(soap, "ns6:Point", &(a->ns6__SearchPoint::Point), "ns4:Location"))
				{	soap_flag_Point1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__SearchPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SearchPoint, 0, sizeof(ns6__SearchPoint), 0, soap_copy_ns6__SearchPoint);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__SearchPoint * SOAP_FMAC4 soap_instantiate_ns6__SearchPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__SearchPoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__SearchPoint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__SearchPoint;
		if (size)
			*size = sizeof(ns6__SearchPoint);
		((ns6__SearchPoint*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__SearchPoint[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__SearchPoint);
		for (int i = 0; i < n; i++)
			((ns6__SearchPoint*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__SearchPoint*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__SearchPoint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__SearchPoint %p -> %p\n", q, p));
	*(ns6__SearchPoint*)p = *(ns6__SearchPoint*)q;
}

void ns6__PersonSearchResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__PersonSearchResult::Address = NULL;
	soap_default_string(soap, &this->ns6__PersonSearchResult::PhoneNumber);
	this->ns6__SearchResultBase::Distance = NULL;
	soap_default_string(soap, &this->ns6__SearchResultBase::Id);
	this->ns6__SearchResultBase::LocationData = NULL;
	soap_default_string(soap, &this->ns6__SearchResultBase::Name);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__PersonSearchResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Address(soap, &this->ns6__PersonSearchResult::Address);
	soap_serialize_string(soap, &this->ns6__PersonSearchResult::PhoneNumber);
	soap_serialize_PointerTodouble(soap, &this->ns6__SearchResultBase::Distance);
	soap_serialize_string(soap, &this->ns6__SearchResultBase::Id);
	soap_serialize_PointerTons6__LocationData(soap, &this->ns6__SearchResultBase::LocationData);
	soap_serialize_string(soap, &this->ns6__SearchResultBase::Name);
	/* transient soap skipped */
}

int ns6__PersonSearchResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__PersonSearchResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__PersonSearchResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__PersonSearchResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__PersonSearchResult(struct soap *soap, const char *tag, int id, const ns6__PersonSearchResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__PersonSearchResult), "ns6:PersonSearchResult"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTodouble(soap, "ns6:Distance", -1, &(a->ns6__SearchResultBase::Distance), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Id", -1, &(a->ns6__SearchResultBase::Id), ""))
		return soap->error;
	if (soap_out_PointerTons6__LocationData(soap, "ns6:LocationData", -1, &(a->ns6__SearchResultBase::LocationData), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Name", -1, &(a->ns6__SearchResultBase::Name), ""))
		return soap->error;
	if (soap_out_PointerTons4__Address(soap, "ns6:Address", -1, &(a->ns6__PersonSearchResult::Address), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:PhoneNumber", -1, &(a->ns6__PersonSearchResult::PhoneNumber), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__PersonSearchResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__PersonSearchResult(soap, this, tag, type);
}

SOAP_FMAC3 ns6__PersonSearchResult * SOAP_FMAC4 soap_get_ns6__PersonSearchResult(struct soap *soap, ns6__PersonSearchResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__PersonSearchResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__PersonSearchResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__PersonSearchResult(soap, tag, this, type);
}

SOAP_FMAC3 ns6__PersonSearchResult * SOAP_FMAC4 soap_in_ns6__PersonSearchResult(struct soap *soap, const char *tag, ns6__PersonSearchResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__PersonSearchResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__PersonSearchResult, sizeof(ns6__PersonSearchResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__PersonSearchResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__PersonSearchResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Distance2 = 1;
	size_t soap_flag_Id2 = 1;
	size_t soap_flag_LocationData2 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_PhoneNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Distance2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns6:Distance", &(a->ns6__SearchResultBase::Distance), "xsd:double"))
				{	soap_flag_Distance2--;
					continue;
				}
			if (soap_flag_Id2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Id", &(a->ns6__SearchResultBase::Id), "xsd:string"))
				{	soap_flag_Id2--;
					continue;
				}
			if (soap_flag_LocationData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__LocationData(soap, "ns6:LocationData", &(a->ns6__SearchResultBase::LocationData), "ns6:LocationData"))
				{	soap_flag_LocationData2--;
					continue;
				}
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Name", &(a->ns6__SearchResultBase::Name), "xsd:string"))
				{	soap_flag_Name2--;
					continue;
				}
			if (soap_flag_Address1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Address(soap, "ns6:Address", &(a->ns6__PersonSearchResult::Address), "ns4:Address"))
				{	soap_flag_Address1--;
					continue;
				}
			if (soap_flag_PhoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:PhoneNumber", &(a->ns6__PersonSearchResult::PhoneNumber), "xsd:string"))
				{	soap_flag_PhoneNumber1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__PersonSearchResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__PersonSearchResult, 0, sizeof(ns6__PersonSearchResult), 0, soap_copy_ns6__PersonSearchResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__PersonSearchResult * SOAP_FMAC4 soap_instantiate_ns6__PersonSearchResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__PersonSearchResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__PersonSearchResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__PersonSearchResult;
		if (size)
			*size = sizeof(ns6__PersonSearchResult);
		((ns6__PersonSearchResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__PersonSearchResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__PersonSearchResult);
		for (int i = 0; i < n; i++)
			((ns6__PersonSearchResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__PersonSearchResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__PersonSearchResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__PersonSearchResult %p -> %p\n", q, p));
	*(ns6__PersonSearchResult*)p = *(ns6__PersonSearchResult*)q;
}

void ns6__ArrayOfNeighborhood::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ArrayOfNeighborhood::__sizeNeighborhood = 0;
	this->ns6__ArrayOfNeighborhood::Neighborhood = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__ArrayOfNeighborhood::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns6__ArrayOfNeighborhood::Neighborhood)
	{	int i;
		for (i = 0; i < this->ns6__ArrayOfNeighborhood::__sizeNeighborhood; i++)
		{
			soap_serialize_PointerTons6__Neighborhood(soap, this->ns6__ArrayOfNeighborhood::Neighborhood + i);
		}
	}
	/* transient soap skipped */
}

int ns6__ArrayOfNeighborhood::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ArrayOfNeighborhood);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__ArrayOfNeighborhood::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ArrayOfNeighborhood(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ArrayOfNeighborhood(struct soap *soap, const char *tag, int id, const ns6__ArrayOfNeighborhood *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ArrayOfNeighborhood), "ns6:ArrayOfNeighborhood"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns6__ArrayOfNeighborhood::Neighborhood)
	{	int i;
		for (i = 0; i < a->ns6__ArrayOfNeighborhood::__sizeNeighborhood; i++)
			if (soap_out_PointerTons6__Neighborhood(soap, "ns6:Neighborhood", -1, a->ns6__ArrayOfNeighborhood::Neighborhood + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__ArrayOfNeighborhood::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ArrayOfNeighborhood(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ArrayOfNeighborhood * SOAP_FMAC4 soap_get_ns6__ArrayOfNeighborhood(struct soap *soap, ns6__ArrayOfNeighborhood *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ArrayOfNeighborhood(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__ArrayOfNeighborhood::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ArrayOfNeighborhood(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ArrayOfNeighborhood * SOAP_FMAC4 soap_in_ns6__ArrayOfNeighborhood(struct soap *soap, const char *tag, ns6__ArrayOfNeighborhood *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ArrayOfNeighborhood *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ArrayOfNeighborhood, sizeof(ns6__ArrayOfNeighborhood), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ArrayOfNeighborhood)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ArrayOfNeighborhood *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_Neighborhood1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Neighborhood", 1, NULL))
			{	if (a->ns6__ArrayOfNeighborhood::Neighborhood == NULL)
				{	if (soap_blist_Neighborhood1 == NULL)
						soap_blist_Neighborhood1 = soap_new_block(soap);
					a->ns6__ArrayOfNeighborhood::Neighborhood = (ns6__Neighborhood **)soap_push_block(soap, soap_blist_Neighborhood1, sizeof(ns6__Neighborhood *));
					if (a->ns6__ArrayOfNeighborhood::Neighborhood == NULL)
						return NULL;
					*a->ns6__ArrayOfNeighborhood::Neighborhood = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons6__Neighborhood(soap, "ns6:Neighborhood", a->ns6__ArrayOfNeighborhood::Neighborhood, "ns6:Neighborhood"))
				{	a->ns6__ArrayOfNeighborhood::__sizeNeighborhood++;
					a->ns6__ArrayOfNeighborhood::Neighborhood = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__ArrayOfNeighborhood::Neighborhood)
			soap_pop_block(soap, soap_blist_Neighborhood1);
		if (a->ns6__ArrayOfNeighborhood::__sizeNeighborhood)
			a->ns6__ArrayOfNeighborhood::Neighborhood = (ns6__Neighborhood **)soap_save_block(soap, soap_blist_Neighborhood1, NULL, 1);
		else
		{	a->ns6__ArrayOfNeighborhood::Neighborhood = NULL;
			if (soap_blist_Neighborhood1)
				soap_end_block(soap, soap_blist_Neighborhood1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ArrayOfNeighborhood *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ArrayOfNeighborhood, 0, sizeof(ns6__ArrayOfNeighborhood), 0, soap_copy_ns6__ArrayOfNeighborhood);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__ArrayOfNeighborhood * SOAP_FMAC4 soap_instantiate_ns6__ArrayOfNeighborhood(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ArrayOfNeighborhood(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ArrayOfNeighborhood, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__ArrayOfNeighborhood;
		if (size)
			*size = sizeof(ns6__ArrayOfNeighborhood);
		((ns6__ArrayOfNeighborhood*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__ArrayOfNeighborhood[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__ArrayOfNeighborhood);
		for (int i = 0; i < n; i++)
			((ns6__ArrayOfNeighborhood*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ArrayOfNeighborhood*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ArrayOfNeighborhood(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ArrayOfNeighborhood %p -> %p\n", q, p));
	*(ns6__ArrayOfNeighborhood*)p = *(ns6__ArrayOfNeighborhood*)q;
}

void ns6__CategorySpecificPropertySet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns6__CategorySpecificPropertySet::CategoryName);
	this->ns6__CategorySpecificPropertySet::Properties = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__CategorySpecificPropertySet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns6__CategorySpecificPropertySet::CategoryName);
	soap_serialize_PointerTons7__ArrayOfKeyValueOfstringanyType(soap, &this->ns6__CategorySpecificPropertySet::Properties);
	/* transient soap skipped */
}

int ns6__CategorySpecificPropertySet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__CategorySpecificPropertySet);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__CategorySpecificPropertySet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CategorySpecificPropertySet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__CategorySpecificPropertySet(struct soap *soap, const char *tag, int id, const ns6__CategorySpecificPropertySet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CategorySpecificPropertySet), "ns6:CategorySpecificPropertySet"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns6:CategoryName", -1, &(a->ns6__CategorySpecificPropertySet::CategoryName), ""))
		return soap->error;
	if (soap_out_PointerTons7__ArrayOfKeyValueOfstringanyType(soap, "ns6:Properties", -1, &(a->ns6__CategorySpecificPropertySet::Properties), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__CategorySpecificPropertySet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CategorySpecificPropertySet(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CategorySpecificPropertySet * SOAP_FMAC4 soap_get_ns6__CategorySpecificPropertySet(struct soap *soap, ns6__CategorySpecificPropertySet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__CategorySpecificPropertySet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__CategorySpecificPropertySet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__CategorySpecificPropertySet(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CategorySpecificPropertySet * SOAP_FMAC4 soap_in_ns6__CategorySpecificPropertySet(struct soap *soap, const char *tag, ns6__CategorySpecificPropertySet *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CategorySpecificPropertySet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CategorySpecificPropertySet, sizeof(ns6__CategorySpecificPropertySet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__CategorySpecificPropertySet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__CategorySpecificPropertySet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_CategoryName1 = 1;
	size_t soap_flag_Properties1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_CategoryName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:CategoryName", &(a->ns6__CategorySpecificPropertySet::CategoryName), "xsd:string"))
				{	soap_flag_CategoryName1--;
					continue;
				}
			if (soap_flag_Properties1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ArrayOfKeyValueOfstringanyType(soap, "ns6:Properties", &(a->ns6__CategorySpecificPropertySet::Properties), "ns7:ArrayOfKeyValueOfstringanyType"))
				{	soap_flag_Properties1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__CategorySpecificPropertySet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CategorySpecificPropertySet, 0, sizeof(ns6__CategorySpecificPropertySet), 0, soap_copy_ns6__CategorySpecificPropertySet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__CategorySpecificPropertySet * SOAP_FMAC4 soap_instantiate_ns6__CategorySpecificPropertySet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__CategorySpecificPropertySet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__CategorySpecificPropertySet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__CategorySpecificPropertySet;
		if (size)
			*size = sizeof(ns6__CategorySpecificPropertySet);
		((ns6__CategorySpecificPropertySet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__CategorySpecificPropertySet[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__CategorySpecificPropertySet);
		for (int i = 0; i < n; i++)
			((ns6__CategorySpecificPropertySet*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__CategorySpecificPropertySet*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__CategorySpecificPropertySet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__CategorySpecificPropertySet %p -> %p\n", q, p));
	*(ns6__CategorySpecificPropertySet*)p = *(ns6__CategorySpecificPropertySet*)q;
}

void ns6__ArrayOfCategory::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ArrayOfCategory::__sizeCategory = 0;
	this->ns6__ArrayOfCategory::Category = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__ArrayOfCategory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns6__ArrayOfCategory::Category)
	{	int i;
		for (i = 0; i < this->ns6__ArrayOfCategory::__sizeCategory; i++)
		{
			soap_serialize_PointerTons6__Category(soap, this->ns6__ArrayOfCategory::Category + i);
		}
	}
	/* transient soap skipped */
}

int ns6__ArrayOfCategory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ArrayOfCategory);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__ArrayOfCategory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ArrayOfCategory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ArrayOfCategory(struct soap *soap, const char *tag, int id, const ns6__ArrayOfCategory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ArrayOfCategory), "ns6:ArrayOfCategory"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns6__ArrayOfCategory::Category)
	{	int i;
		for (i = 0; i < a->ns6__ArrayOfCategory::__sizeCategory; i++)
			if (soap_out_PointerTons6__Category(soap, "ns6:Category", -1, a->ns6__ArrayOfCategory::Category + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__ArrayOfCategory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ArrayOfCategory(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ArrayOfCategory * SOAP_FMAC4 soap_get_ns6__ArrayOfCategory(struct soap *soap, ns6__ArrayOfCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ArrayOfCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__ArrayOfCategory::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ArrayOfCategory(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ArrayOfCategory * SOAP_FMAC4 soap_in_ns6__ArrayOfCategory(struct soap *soap, const char *tag, ns6__ArrayOfCategory *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ArrayOfCategory *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ArrayOfCategory, sizeof(ns6__ArrayOfCategory), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ArrayOfCategory)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ArrayOfCategory *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_Category1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Category", 1, NULL))
			{	if (a->ns6__ArrayOfCategory::Category == NULL)
				{	if (soap_blist_Category1 == NULL)
						soap_blist_Category1 = soap_new_block(soap);
					a->ns6__ArrayOfCategory::Category = (ns6__Category **)soap_push_block(soap, soap_blist_Category1, sizeof(ns6__Category *));
					if (a->ns6__ArrayOfCategory::Category == NULL)
						return NULL;
					*a->ns6__ArrayOfCategory::Category = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons6__Category(soap, "ns6:Category", a->ns6__ArrayOfCategory::Category, "ns6:Category"))
				{	a->ns6__ArrayOfCategory::__sizeCategory++;
					a->ns6__ArrayOfCategory::Category = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__ArrayOfCategory::Category)
			soap_pop_block(soap, soap_blist_Category1);
		if (a->ns6__ArrayOfCategory::__sizeCategory)
			a->ns6__ArrayOfCategory::Category = (ns6__Category **)soap_save_block(soap, soap_blist_Category1, NULL, 1);
		else
		{	a->ns6__ArrayOfCategory::Category = NULL;
			if (soap_blist_Category1)
				soap_end_block(soap, soap_blist_Category1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ArrayOfCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ArrayOfCategory, 0, sizeof(ns6__ArrayOfCategory), 0, soap_copy_ns6__ArrayOfCategory);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__ArrayOfCategory * SOAP_FMAC4 soap_instantiate_ns6__ArrayOfCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ArrayOfCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ArrayOfCategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__ArrayOfCategory;
		if (size)
			*size = sizeof(ns6__ArrayOfCategory);
		((ns6__ArrayOfCategory*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__ArrayOfCategory[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__ArrayOfCategory);
		for (int i = 0; i < n; i++)
			((ns6__ArrayOfCategory*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ArrayOfCategory*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ArrayOfCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ArrayOfCategory %p -> %p\n", q, p));
	*(ns6__ArrayOfCategory*)p = *(ns6__ArrayOfCategory*)q;
}

void ns6__BusinessSearchResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__BusinessSearchResult::AdditionalProperties = NULL;
	this->ns6__BusinessSearchResult::Address = NULL;
	this->ns6__BusinessSearchResult::Categories = NULL;
	this->ns6__BusinessSearchResult::CategorySpecificProperties = NULL;
	this->ns6__BusinessSearchResult::Neighborhoods = NULL;
	soap_default_string(soap, &this->ns6__BusinessSearchResult::PhoneNumber);
	this->ns6__BusinessSearchResult::RatingCount = NULL;
	this->ns6__BusinessSearchResult::ReviewCount = NULL;
	this->ns6__BusinessSearchResult::UserRating = NULL;
	soap_default_xsd__anyURI(soap, &this->ns6__BusinessSearchResult::Website);
	this->ns6__SearchResultBase::Distance = NULL;
	soap_default_string(soap, &this->ns6__SearchResultBase::Id);
	this->ns6__SearchResultBase::LocationData = NULL;
	soap_default_string(soap, &this->ns6__SearchResultBase::Name);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__BusinessSearchResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons7__ArrayOfKeyValueOfstringanyType(soap, &this->ns6__BusinessSearchResult::AdditionalProperties);
	soap_serialize_PointerTons4__Address(soap, &this->ns6__BusinessSearchResult::Address);
	soap_serialize_PointerTons6__ArrayOfCategory(soap, &this->ns6__BusinessSearchResult::Categories);
	soap_serialize_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, &this->ns6__BusinessSearchResult::CategorySpecificProperties);
	soap_serialize_PointerTons6__ArrayOfNeighborhood(soap, &this->ns6__BusinessSearchResult::Neighborhoods);
	soap_serialize_string(soap, &this->ns6__BusinessSearchResult::PhoneNumber);
	soap_serialize_PointerToint(soap, &this->ns6__BusinessSearchResult::RatingCount);
	soap_serialize_PointerToint(soap, &this->ns6__BusinessSearchResult::ReviewCount);
	soap_serialize_PointerTodouble(soap, &this->ns6__BusinessSearchResult::UserRating);
	soap_serialize_xsd__anyURI(soap, &this->ns6__BusinessSearchResult::Website);
	soap_serialize_PointerTodouble(soap, &this->ns6__SearchResultBase::Distance);
	soap_serialize_string(soap, &this->ns6__SearchResultBase::Id);
	soap_serialize_PointerTons6__LocationData(soap, &this->ns6__SearchResultBase::LocationData);
	soap_serialize_string(soap, &this->ns6__SearchResultBase::Name);
	/* transient soap skipped */
}

int ns6__BusinessSearchResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__BusinessSearchResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__BusinessSearchResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__BusinessSearchResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__BusinessSearchResult(struct soap *soap, const char *tag, int id, const ns6__BusinessSearchResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__BusinessSearchResult), "ns6:BusinessSearchResult"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTodouble(soap, "ns6:Distance", -1, &(a->ns6__SearchResultBase::Distance), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Id", -1, &(a->ns6__SearchResultBase::Id), ""))
		return soap->error;
	if (soap_out_PointerTons6__LocationData(soap, "ns6:LocationData", -1, &(a->ns6__SearchResultBase::LocationData), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Name", -1, &(a->ns6__SearchResultBase::Name), ""))
		return soap->error;
	if (soap_out_PointerTons7__ArrayOfKeyValueOfstringanyType(soap, "ns6:AdditionalProperties", -1, &(a->ns6__BusinessSearchResult::AdditionalProperties), ""))
		return soap->error;
	if (soap_out_PointerTons4__Address(soap, "ns6:Address", -1, &(a->ns6__BusinessSearchResult::Address), ""))
		return soap->error;
	if (soap_out_PointerTons6__ArrayOfCategory(soap, "ns6:Categories", -1, &(a->ns6__BusinessSearchResult::Categories), ""))
		return soap->error;
	if (soap_out_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, "ns6:CategorySpecificProperties", -1, &(a->ns6__BusinessSearchResult::CategorySpecificProperties), ""))
		return soap->error;
	if (soap_out_PointerTons6__ArrayOfNeighborhood(soap, "ns6:Neighborhoods", -1, &(a->ns6__BusinessSearchResult::Neighborhoods), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:PhoneNumber", -1, &(a->ns6__BusinessSearchResult::PhoneNumber), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns6:RatingCount", -1, &(a->ns6__BusinessSearchResult::RatingCount), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns6:ReviewCount", -1, &(a->ns6__BusinessSearchResult::ReviewCount), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns6:UserRating", -1, &(a->ns6__BusinessSearchResult::UserRating), ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "ns6:Website", -1, &(a->ns6__BusinessSearchResult::Website), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__BusinessSearchResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__BusinessSearchResult(soap, this, tag, type);
}

SOAP_FMAC3 ns6__BusinessSearchResult * SOAP_FMAC4 soap_get_ns6__BusinessSearchResult(struct soap *soap, ns6__BusinessSearchResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__BusinessSearchResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__BusinessSearchResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__BusinessSearchResult(soap, tag, this, type);
}

SOAP_FMAC3 ns6__BusinessSearchResult * SOAP_FMAC4 soap_in_ns6__BusinessSearchResult(struct soap *soap, const char *tag, ns6__BusinessSearchResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__BusinessSearchResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__BusinessSearchResult, sizeof(ns6__BusinessSearchResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__BusinessSearchResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__BusinessSearchResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Distance2 = 1;
	size_t soap_flag_Id2 = 1;
	size_t soap_flag_LocationData2 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_AdditionalProperties1 = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_Categories1 = 1;
	size_t soap_flag_CategorySpecificProperties1 = 1;
	size_t soap_flag_Neighborhoods1 = 1;
	size_t soap_flag_PhoneNumber1 = 1;
	size_t soap_flag_RatingCount1 = 1;
	size_t soap_flag_ReviewCount1 = 1;
	size_t soap_flag_UserRating1 = 1;
	size_t soap_flag_Website1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Distance2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns6:Distance", &(a->ns6__SearchResultBase::Distance), "xsd:double"))
				{	soap_flag_Distance2--;
					continue;
				}
			if (soap_flag_Id2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Id", &(a->ns6__SearchResultBase::Id), "xsd:string"))
				{	soap_flag_Id2--;
					continue;
				}
			if (soap_flag_LocationData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__LocationData(soap, "ns6:LocationData", &(a->ns6__SearchResultBase::LocationData), "ns6:LocationData"))
				{	soap_flag_LocationData2--;
					continue;
				}
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Name", &(a->ns6__SearchResultBase::Name), "xsd:string"))
				{	soap_flag_Name2--;
					continue;
				}
			if (soap_flag_AdditionalProperties1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ArrayOfKeyValueOfstringanyType(soap, "ns6:AdditionalProperties", &(a->ns6__BusinessSearchResult::AdditionalProperties), "ns7:ArrayOfKeyValueOfstringanyType"))
				{	soap_flag_AdditionalProperties1--;
					continue;
				}
			if (soap_flag_Address1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Address(soap, "ns6:Address", &(a->ns6__BusinessSearchResult::Address), "ns4:Address"))
				{	soap_flag_Address1--;
					continue;
				}
			if (soap_flag_Categories1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ArrayOfCategory(soap, "ns6:Categories", &(a->ns6__BusinessSearchResult::Categories), "ns6:ArrayOfCategory"))
				{	soap_flag_Categories1--;
					continue;
				}
			if (soap_flag_CategorySpecificProperties1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, "ns6:CategorySpecificProperties", &(a->ns6__BusinessSearchResult::CategorySpecificProperties), "ns7:ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_P9s"))
				{	soap_flag_CategorySpecificProperties1--;
					continue;
				}
			if (soap_flag_Neighborhoods1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ArrayOfNeighborhood(soap, "ns6:Neighborhoods", &(a->ns6__BusinessSearchResult::Neighborhoods), "ns6:ArrayOfNeighborhood"))
				{	soap_flag_Neighborhoods1--;
					continue;
				}
			if (soap_flag_PhoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:PhoneNumber", &(a->ns6__BusinessSearchResult::PhoneNumber), "xsd:string"))
				{	soap_flag_PhoneNumber1--;
					continue;
				}
			if (soap_flag_RatingCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns6:RatingCount", &(a->ns6__BusinessSearchResult::RatingCount), "xsd:int"))
				{	soap_flag_RatingCount1--;
					continue;
				}
			if (soap_flag_ReviewCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns6:ReviewCount", &(a->ns6__BusinessSearchResult::ReviewCount), "xsd:int"))
				{	soap_flag_ReviewCount1--;
					continue;
				}
			if (soap_flag_UserRating1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns6:UserRating", &(a->ns6__BusinessSearchResult::UserRating), "xsd:double"))
				{	soap_flag_UserRating1--;
					continue;
				}
			if (soap_flag_Website1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns6:Website", &(a->ns6__BusinessSearchResult::Website), "xsd:anyURI"))
				{	soap_flag_Website1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__BusinessSearchResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__BusinessSearchResult, 0, sizeof(ns6__BusinessSearchResult), 0, soap_copy_ns6__BusinessSearchResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__BusinessSearchResult * SOAP_FMAC4 soap_instantiate_ns6__BusinessSearchResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__BusinessSearchResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__BusinessSearchResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__BusinessSearchResult;
		if (size)
			*size = sizeof(ns6__BusinessSearchResult);
		((ns6__BusinessSearchResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__BusinessSearchResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__BusinessSearchResult);
		for (int i = 0; i < n; i++)
			((ns6__BusinessSearchResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__BusinessSearchResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__BusinessSearchResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__BusinessSearchResult %p -> %p\n", q, p));
	*(ns6__BusinessSearchResult*)p = *(ns6__BusinessSearchResult*)q;
}

void ns6__CommunityContentSearchResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__CommunityContentSearchResult::AdditionalProperties = NULL;
	soap_default_string(soap, &this->ns6__CommunityContentSearchResult::Description);
	this->ns6__SearchResultBase::Distance = NULL;
	soap_default_string(soap, &this->ns6__SearchResultBase::Id);
	this->ns6__SearchResultBase::LocationData = NULL;
	soap_default_string(soap, &this->ns6__SearchResultBase::Name);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__CommunityContentSearchResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons7__ArrayOfKeyValueOfstringanyType(soap, &this->ns6__CommunityContentSearchResult::AdditionalProperties);
	soap_serialize_string(soap, &this->ns6__CommunityContentSearchResult::Description);
	soap_serialize_PointerTodouble(soap, &this->ns6__SearchResultBase::Distance);
	soap_serialize_string(soap, &this->ns6__SearchResultBase::Id);
	soap_serialize_PointerTons6__LocationData(soap, &this->ns6__SearchResultBase::LocationData);
	soap_serialize_string(soap, &this->ns6__SearchResultBase::Name);
	/* transient soap skipped */
}

int ns6__CommunityContentSearchResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__CommunityContentSearchResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__CommunityContentSearchResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CommunityContentSearchResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__CommunityContentSearchResult(struct soap *soap, const char *tag, int id, const ns6__CommunityContentSearchResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CommunityContentSearchResult), "ns6:CommunityContentSearchResult"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTodouble(soap, "ns6:Distance", -1, &(a->ns6__SearchResultBase::Distance), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Id", -1, &(a->ns6__SearchResultBase::Id), ""))
		return soap->error;
	if (soap_out_PointerTons6__LocationData(soap, "ns6:LocationData", -1, &(a->ns6__SearchResultBase::LocationData), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Name", -1, &(a->ns6__SearchResultBase::Name), ""))
		return soap->error;
	if (soap_out_PointerTons7__ArrayOfKeyValueOfstringanyType(soap, "ns6:AdditionalProperties", -1, &(a->ns6__CommunityContentSearchResult::AdditionalProperties), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Description", -1, &(a->ns6__CommunityContentSearchResult::Description), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__CommunityContentSearchResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CommunityContentSearchResult(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CommunityContentSearchResult * SOAP_FMAC4 soap_get_ns6__CommunityContentSearchResult(struct soap *soap, ns6__CommunityContentSearchResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__CommunityContentSearchResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__CommunityContentSearchResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__CommunityContentSearchResult(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CommunityContentSearchResult * SOAP_FMAC4 soap_in_ns6__CommunityContentSearchResult(struct soap *soap, const char *tag, ns6__CommunityContentSearchResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CommunityContentSearchResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CommunityContentSearchResult, sizeof(ns6__CommunityContentSearchResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__CommunityContentSearchResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__CommunityContentSearchResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Distance2 = 1;
	size_t soap_flag_Id2 = 1;
	size_t soap_flag_LocationData2 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_AdditionalProperties1 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Distance2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns6:Distance", &(a->ns6__SearchResultBase::Distance), "xsd:double"))
				{	soap_flag_Distance2--;
					continue;
				}
			if (soap_flag_Id2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Id", &(a->ns6__SearchResultBase::Id), "xsd:string"))
				{	soap_flag_Id2--;
					continue;
				}
			if (soap_flag_LocationData2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__LocationData(soap, "ns6:LocationData", &(a->ns6__SearchResultBase::LocationData), "ns6:LocationData"))
				{	soap_flag_LocationData2--;
					continue;
				}
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Name", &(a->ns6__SearchResultBase::Name), "xsd:string"))
				{	soap_flag_Name2--;
					continue;
				}
			if (soap_flag_AdditionalProperties1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ArrayOfKeyValueOfstringanyType(soap, "ns6:AdditionalProperties", &(a->ns6__CommunityContentSearchResult::AdditionalProperties), "ns7:ArrayOfKeyValueOfstringanyType"))
				{	soap_flag_AdditionalProperties1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Description", &(a->ns6__CommunityContentSearchResult::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__CommunityContentSearchResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CommunityContentSearchResult, 0, sizeof(ns6__CommunityContentSearchResult), 0, soap_copy_ns6__CommunityContentSearchResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__CommunityContentSearchResult * SOAP_FMAC4 soap_instantiate_ns6__CommunityContentSearchResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__CommunityContentSearchResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__CommunityContentSearchResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__CommunityContentSearchResult;
		if (size)
			*size = sizeof(ns6__CommunityContentSearchResult);
		((ns6__CommunityContentSearchResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__CommunityContentSearchResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__CommunityContentSearchResult);
		for (int i = 0; i < n; i++)
			((ns6__CommunityContentSearchResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__CommunityContentSearchResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__CommunityContentSearchResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__CommunityContentSearchResult %p -> %p\n", q, p));
	*(ns6__CommunityContentSearchResult*)p = *(ns6__CommunityContentSearchResult*)q;
}

void ns6__LocationData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__LocationData::Confidence = NULL;
	this->ns6__LocationData::Locations = NULL;
	this->ns6__LocationData::MatchCodes = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__LocationData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Confidence(soap, &this->ns6__LocationData::Confidence);
	soap_serialize_PointerTons4__ArrayOfGeocodeLocation(soap, &this->ns6__LocationData::Locations);
	soap_serialize_PointerTons7__ArrayOfstring(soap, &this->ns6__LocationData::MatchCodes);
	/* transient soap skipped */
}

int ns6__LocationData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__LocationData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__LocationData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__LocationData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__LocationData(struct soap *soap, const char *tag, int id, const ns6__LocationData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__LocationData), "ns6:LocationData"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Confidence(soap, "ns6:Confidence", -1, &(a->ns6__LocationData::Confidence), ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfGeocodeLocation(soap, "ns6:Locations", -1, &(a->ns6__LocationData::Locations), ""))
		return soap->error;
	if (soap_out_PointerTons7__ArrayOfstring(soap, "ns6:MatchCodes", -1, &(a->ns6__LocationData::MatchCodes), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__LocationData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__LocationData(soap, this, tag, type);
}

SOAP_FMAC3 ns6__LocationData * SOAP_FMAC4 soap_get_ns6__LocationData(struct soap *soap, ns6__LocationData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__LocationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__LocationData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__LocationData(soap, tag, this, type);
}

SOAP_FMAC3 ns6__LocationData * SOAP_FMAC4 soap_in_ns6__LocationData(struct soap *soap, const char *tag, ns6__LocationData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__LocationData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__LocationData, sizeof(ns6__LocationData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__LocationData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__LocationData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Confidence1 = 1;
	size_t soap_flag_Locations1 = 1;
	size_t soap_flag_MatchCodes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Confidence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Confidence(soap, "ns6:Confidence", &(a->ns6__LocationData::Confidence), "ns4:Confidence"))
				{	soap_flag_Confidence1--;
					continue;
				}
			if (soap_flag_Locations1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfGeocodeLocation(soap, "ns6:Locations", &(a->ns6__LocationData::Locations), "ns4:ArrayOfGeocodeLocation"))
				{	soap_flag_Locations1--;
					continue;
				}
			if (soap_flag_MatchCodes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ArrayOfstring(soap, "ns6:MatchCodes", &(a->ns6__LocationData::MatchCodes), "ns7:ArrayOfstring"))
				{	soap_flag_MatchCodes1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__LocationData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__LocationData, 0, sizeof(ns6__LocationData), 0, soap_copy_ns6__LocationData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__LocationData * SOAP_FMAC4 soap_instantiate_ns6__LocationData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__LocationData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__LocationData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__LocationData;
		if (size)
			*size = sizeof(ns6__LocationData);
		((ns6__LocationData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__LocationData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__LocationData);
		for (int i = 0; i < n; i++)
			((ns6__LocationData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__LocationData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__LocationData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__LocationData %p -> %p\n", q, p));
	*(ns6__LocationData*)p = *(ns6__LocationData*)q;
}

void ns6__SearchResultBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__SearchResultBase::Distance = NULL;
	soap_default_string(soap, &this->ns6__SearchResultBase::Id);
	this->ns6__SearchResultBase::LocationData = NULL;
	soap_default_string(soap, &this->ns6__SearchResultBase::Name);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__SearchResultBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTodouble(soap, &this->ns6__SearchResultBase::Distance);
	soap_serialize_string(soap, &this->ns6__SearchResultBase::Id);
	soap_serialize_PointerTons6__LocationData(soap, &this->ns6__SearchResultBase::LocationData);
	soap_serialize_string(soap, &this->ns6__SearchResultBase::Name);
	/* transient soap skipped */
}

int ns6__SearchResultBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__SearchResultBase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__SearchResultBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SearchResultBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SearchResultBase(struct soap *soap, const char *tag, int id, const ns6__SearchResultBase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SearchResultBase), "ns6:SearchResultBase"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTodouble(soap, "ns6:Distance", -1, &(a->ns6__SearchResultBase::Distance), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Id", -1, &(a->ns6__SearchResultBase::Id), ""))
		return soap->error;
	if (soap_out_PointerTons6__LocationData(soap, "ns6:LocationData", -1, &(a->ns6__SearchResultBase::LocationData), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Name", -1, &(a->ns6__SearchResultBase::Name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__SearchResultBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SearchResultBase(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SearchResultBase * SOAP_FMAC4 soap_get_ns6__SearchResultBase(struct soap *soap, ns6__SearchResultBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SearchResultBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__SearchResultBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__SearchResultBase(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SearchResultBase * SOAP_FMAC4 soap_in_ns6__SearchResultBase(struct soap *soap, const char *tag, ns6__SearchResultBase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SearchResultBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SearchResultBase, sizeof(ns6__SearchResultBase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__SearchResultBase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__SearchResultBase *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Distance1 = 1;
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_LocationData1 = 1;
	size_t soap_flag_Name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Distance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns6:Distance", &(a->ns6__SearchResultBase::Distance), "xsd:double"))
				{	soap_flag_Distance1--;
					continue;
				}
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Id", &(a->ns6__SearchResultBase::Id), "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_LocationData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__LocationData(soap, "ns6:LocationData", &(a->ns6__SearchResultBase::LocationData), "ns6:LocationData"))
				{	soap_flag_LocationData1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Name", &(a->ns6__SearchResultBase::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__SearchResultBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SearchResultBase, 0, sizeof(ns6__SearchResultBase), 0, soap_copy_ns6__SearchResultBase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__SearchResultBase * SOAP_FMAC4 soap_instantiate_ns6__SearchResultBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__SearchResultBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__SearchResultBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns6:CommunityContentSearchResult"))
	{	cp->type = SOAP_TYPE_ns6__CommunityContentSearchResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__CommunityContentSearchResult;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__CommunityContentSearchResult);
			((ns6__CommunityContentSearchResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__CommunityContentSearchResult[n];
			if (size)
				*size = n * sizeof(ns6__CommunityContentSearchResult);
			for (int i = 0; i < n; i++)
				((ns6__CommunityContentSearchResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__CommunityContentSearchResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:BusinessSearchResult"))
	{	cp->type = SOAP_TYPE_ns6__BusinessSearchResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__BusinessSearchResult;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__BusinessSearchResult);
			((ns6__BusinessSearchResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__BusinessSearchResult[n];
			if (size)
				*size = n * sizeof(ns6__BusinessSearchResult);
			for (int i = 0; i < n; i++)
				((ns6__BusinessSearchResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__BusinessSearchResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:PersonSearchResult"))
	{	cp->type = SOAP_TYPE_ns6__PersonSearchResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__PersonSearchResult;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__PersonSearchResult);
			((ns6__PersonSearchResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__PersonSearchResult[n];
			if (size)
				*size = n * sizeof(ns6__PersonSearchResult);
			for (int i = 0; i < n; i++)
				((ns6__PersonSearchResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__PersonSearchResult*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns6__SearchResultBase;
		if (size)
			*size = sizeof(ns6__SearchResultBase);
		((ns6__SearchResultBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__SearchResultBase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__SearchResultBase);
		for (int i = 0; i < n; i++)
			((ns6__SearchResultBase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__SearchResultBase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__SearchResultBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__SearchResultBase %p -> %p\n", q, p));
	*(ns6__SearchResultBase*)p = *(ns6__SearchResultBase*)q;
}

void ns6__ArrayOfSearchResultBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ArrayOfSearchResultBase::__sizeSearchResultBase = 0;
	this->ns6__ArrayOfSearchResultBase::SearchResultBase = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__ArrayOfSearchResultBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns6__ArrayOfSearchResultBase::SearchResultBase)
	{	int i;
		for (i = 0; i < this->ns6__ArrayOfSearchResultBase::__sizeSearchResultBase; i++)
		{
			soap_serialize_PointerTons6__SearchResultBase(soap, this->ns6__ArrayOfSearchResultBase::SearchResultBase + i);
		}
	}
	/* transient soap skipped */
}

int ns6__ArrayOfSearchResultBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ArrayOfSearchResultBase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__ArrayOfSearchResultBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ArrayOfSearchResultBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ArrayOfSearchResultBase(struct soap *soap, const char *tag, int id, const ns6__ArrayOfSearchResultBase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ArrayOfSearchResultBase), "ns6:ArrayOfSearchResultBase"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns6__ArrayOfSearchResultBase::SearchResultBase)
	{	int i;
		for (i = 0; i < a->ns6__ArrayOfSearchResultBase::__sizeSearchResultBase; i++)
			if (soap_out_PointerTons6__SearchResultBase(soap, "ns6:SearchResultBase", -1, a->ns6__ArrayOfSearchResultBase::SearchResultBase + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__ArrayOfSearchResultBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ArrayOfSearchResultBase(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ArrayOfSearchResultBase * SOAP_FMAC4 soap_get_ns6__ArrayOfSearchResultBase(struct soap *soap, ns6__ArrayOfSearchResultBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ArrayOfSearchResultBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__ArrayOfSearchResultBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ArrayOfSearchResultBase(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ArrayOfSearchResultBase * SOAP_FMAC4 soap_in_ns6__ArrayOfSearchResultBase(struct soap *soap, const char *tag, ns6__ArrayOfSearchResultBase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ArrayOfSearchResultBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ArrayOfSearchResultBase, sizeof(ns6__ArrayOfSearchResultBase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ArrayOfSearchResultBase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ArrayOfSearchResultBase *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_SearchResultBase1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:SearchResultBase", 1, NULL))
			{	if (a->ns6__ArrayOfSearchResultBase::SearchResultBase == NULL)
				{	if (soap_blist_SearchResultBase1 == NULL)
						soap_blist_SearchResultBase1 = soap_new_block(soap);
					a->ns6__ArrayOfSearchResultBase::SearchResultBase = (ns6__SearchResultBase **)soap_push_block(soap, soap_blist_SearchResultBase1, sizeof(ns6__SearchResultBase *));
					if (a->ns6__ArrayOfSearchResultBase::SearchResultBase == NULL)
						return NULL;
					*a->ns6__ArrayOfSearchResultBase::SearchResultBase = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons6__SearchResultBase(soap, "ns6:SearchResultBase", a->ns6__ArrayOfSearchResultBase::SearchResultBase, "ns6:SearchResultBase"))
				{	a->ns6__ArrayOfSearchResultBase::__sizeSearchResultBase++;
					a->ns6__ArrayOfSearchResultBase::SearchResultBase = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__ArrayOfSearchResultBase::SearchResultBase)
			soap_pop_block(soap, soap_blist_SearchResultBase1);
		if (a->ns6__ArrayOfSearchResultBase::__sizeSearchResultBase)
			a->ns6__ArrayOfSearchResultBase::SearchResultBase = (ns6__SearchResultBase **)soap_save_block(soap, soap_blist_SearchResultBase1, NULL, 1);
		else
		{	a->ns6__ArrayOfSearchResultBase::SearchResultBase = NULL;
			if (soap_blist_SearchResultBase1)
				soap_end_block(soap, soap_blist_SearchResultBase1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ArrayOfSearchResultBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ArrayOfSearchResultBase, 0, sizeof(ns6__ArrayOfSearchResultBase), 0, soap_copy_ns6__ArrayOfSearchResultBase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__ArrayOfSearchResultBase * SOAP_FMAC4 soap_instantiate_ns6__ArrayOfSearchResultBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ArrayOfSearchResultBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ArrayOfSearchResultBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__ArrayOfSearchResultBase;
		if (size)
			*size = sizeof(ns6__ArrayOfSearchResultBase);
		((ns6__ArrayOfSearchResultBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__ArrayOfSearchResultBase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__ArrayOfSearchResultBase);
		for (int i = 0; i < n; i++)
			((ns6__ArrayOfSearchResultBase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ArrayOfSearchResultBase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ArrayOfSearchResultBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ArrayOfSearchResultBase %p -> %p\n", q, p));
	*(ns6__ArrayOfSearchResultBase*)p = *(ns6__ArrayOfSearchResultBase*)q;
}

void ns6__Parse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__Parse::Address = NULL;
	soap_default_string(soap, &this->ns6__Parse::Keyword);
	soap_default_string(soap, &this->ns6__Parse::Landmark);
	soap_default_string(soap, &this->ns6__Parse::LocationSeparator);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__Parse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Address(soap, &this->ns6__Parse::Address);
	soap_serialize_string(soap, &this->ns6__Parse::Keyword);
	soap_serialize_string(soap, &this->ns6__Parse::Landmark);
	soap_serialize_string(soap, &this->ns6__Parse::LocationSeparator);
	/* transient soap skipped */
}

int ns6__Parse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Parse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__Parse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Parse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__Parse(struct soap *soap, const char *tag, int id, const ns6__Parse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Parse), "ns6:Parse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Address(soap, "ns6:Address", -1, &(a->ns6__Parse::Address), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Keyword", -1, &(a->ns6__Parse::Keyword), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Landmark", -1, &(a->ns6__Parse::Landmark), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:LocationSeparator", -1, &(a->ns6__Parse::LocationSeparator), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__Parse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Parse(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Parse * SOAP_FMAC4 soap_get_ns6__Parse(struct soap *soap, ns6__Parse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__Parse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__Parse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__Parse(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Parse * SOAP_FMAC4 soap_in_ns6__Parse(struct soap *soap, const char *tag, ns6__Parse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Parse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Parse, sizeof(ns6__Parse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__Parse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Parse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_Keyword1 = 1;
	size_t soap_flag_Landmark1 = 1;
	size_t soap_flag_LocationSeparator1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Address1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Address(soap, "ns6:Address", &(a->ns6__Parse::Address), "ns4:Address"))
				{	soap_flag_Address1--;
					continue;
				}
			if (soap_flag_Keyword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Keyword", &(a->ns6__Parse::Keyword), "xsd:string"))
				{	soap_flag_Keyword1--;
					continue;
				}
			if (soap_flag_Landmark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Landmark", &(a->ns6__Parse::Landmark), "xsd:string"))
				{	soap_flag_Landmark1--;
					continue;
				}
			if (soap_flag_LocationSeparator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:LocationSeparator", &(a->ns6__Parse::LocationSeparator), "xsd:string"))
				{	soap_flag_LocationSeparator1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__Parse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Parse, 0, sizeof(ns6__Parse), 0, soap_copy_ns6__Parse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__Parse * SOAP_FMAC4 soap_instantiate_ns6__Parse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Parse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Parse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__Parse;
		if (size)
			*size = sizeof(ns6__Parse);
		((ns6__Parse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__Parse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__Parse);
		for (int i = 0; i < n; i++)
			((ns6__Parse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Parse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Parse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Parse %p -> %p\n", q, p));
	*(ns6__Parse*)p = *(ns6__Parse*)q;
}

void ns6__CategoryCount::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__CategoryCount::Category = NULL;
	this->ns6__CategoryCount::Count = NULL;
	this->ns6__CategoryCount::CountByNeighborhood = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__CategoryCount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__Category(soap, &this->ns6__CategoryCount::Category);
	soap_serialize_PointerToint(soap, &this->ns6__CategoryCount::Count);
	soap_serialize_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, &this->ns6__CategoryCount::CountByNeighborhood);
	/* transient soap skipped */
}

int ns6__CategoryCount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__CategoryCount);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__CategoryCount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CategoryCount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__CategoryCount(struct soap *soap, const char *tag, int id, const ns6__CategoryCount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CategoryCount), "ns6:CategoryCount"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons6__Category(soap, "ns6:Category", -1, &(a->ns6__CategoryCount::Category), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns6:Count", -1, &(a->ns6__CategoryCount::Count), ""))
		return soap->error;
	if (soap_out_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, "ns6:CountByNeighborhood", -1, &(a->ns6__CategoryCount::CountByNeighborhood), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__CategoryCount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CategoryCount(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CategoryCount * SOAP_FMAC4 soap_get_ns6__CategoryCount(struct soap *soap, ns6__CategoryCount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__CategoryCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__CategoryCount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__CategoryCount(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CategoryCount * SOAP_FMAC4 soap_in_ns6__CategoryCount(struct soap *soap, const char *tag, ns6__CategoryCount *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CategoryCount *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CategoryCount, sizeof(ns6__CategoryCount), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__CategoryCount)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__CategoryCount *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Category1 = 1;
	size_t soap_flag_Count1 = 1;
	size_t soap_flag_CountByNeighborhood1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Category1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Category(soap, "ns6:Category", &(a->ns6__CategoryCount::Category), "ns6:Category"))
				{	soap_flag_Category1--;
					continue;
				}
			if (soap_flag_Count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns6:Count", &(a->ns6__CategoryCount::Count), "xsd:int"))
				{	soap_flag_Count1--;
					continue;
				}
			if (soap_flag_CountByNeighborhood1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, "ns6:CountByNeighborhood", &(a->ns6__CategoryCount::CountByNeighborhood), "ns7:ArrayOfKeyValueOfNeighborhoodintkC8b0tr6"))
				{	soap_flag_CountByNeighborhood1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__CategoryCount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CategoryCount, 0, sizeof(ns6__CategoryCount), 0, soap_copy_ns6__CategoryCount);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__CategoryCount * SOAP_FMAC4 soap_instantiate_ns6__CategoryCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__CategoryCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__CategoryCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__CategoryCount;
		if (size)
			*size = sizeof(ns6__CategoryCount);
		((ns6__CategoryCount*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__CategoryCount[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__CategoryCount);
		for (int i = 0; i < n; i++)
			((ns6__CategoryCount*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__CategoryCount*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__CategoryCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__CategoryCount %p -> %p\n", q, p));
	*(ns6__CategoryCount*)p = *(ns6__CategoryCount*)q;
}

void ns6__ArrayOfCategoryCount::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ArrayOfCategoryCount::__sizeCategoryCount = 0;
	this->ns6__ArrayOfCategoryCount::CategoryCount = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__ArrayOfCategoryCount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns6__ArrayOfCategoryCount::CategoryCount)
	{	int i;
		for (i = 0; i < this->ns6__ArrayOfCategoryCount::__sizeCategoryCount; i++)
		{
			soap_serialize_PointerTons6__CategoryCount(soap, this->ns6__ArrayOfCategoryCount::CategoryCount + i);
		}
	}
	/* transient soap skipped */
}

int ns6__ArrayOfCategoryCount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ArrayOfCategoryCount);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__ArrayOfCategoryCount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ArrayOfCategoryCount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ArrayOfCategoryCount(struct soap *soap, const char *tag, int id, const ns6__ArrayOfCategoryCount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ArrayOfCategoryCount), "ns6:ArrayOfCategoryCount"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns6__ArrayOfCategoryCount::CategoryCount)
	{	int i;
		for (i = 0; i < a->ns6__ArrayOfCategoryCount::__sizeCategoryCount; i++)
			if (soap_out_PointerTons6__CategoryCount(soap, "ns6:CategoryCount", -1, a->ns6__ArrayOfCategoryCount::CategoryCount + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__ArrayOfCategoryCount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ArrayOfCategoryCount(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ArrayOfCategoryCount * SOAP_FMAC4 soap_get_ns6__ArrayOfCategoryCount(struct soap *soap, ns6__ArrayOfCategoryCount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ArrayOfCategoryCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__ArrayOfCategoryCount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ArrayOfCategoryCount(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ArrayOfCategoryCount * SOAP_FMAC4 soap_in_ns6__ArrayOfCategoryCount(struct soap *soap, const char *tag, ns6__ArrayOfCategoryCount *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ArrayOfCategoryCount *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ArrayOfCategoryCount, sizeof(ns6__ArrayOfCategoryCount), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ArrayOfCategoryCount)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ArrayOfCategoryCount *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_CategoryCount1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:CategoryCount", 1, NULL))
			{	if (a->ns6__ArrayOfCategoryCount::CategoryCount == NULL)
				{	if (soap_blist_CategoryCount1 == NULL)
						soap_blist_CategoryCount1 = soap_new_block(soap);
					a->ns6__ArrayOfCategoryCount::CategoryCount = (ns6__CategoryCount **)soap_push_block(soap, soap_blist_CategoryCount1, sizeof(ns6__CategoryCount *));
					if (a->ns6__ArrayOfCategoryCount::CategoryCount == NULL)
						return NULL;
					*a->ns6__ArrayOfCategoryCount::CategoryCount = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons6__CategoryCount(soap, "ns6:CategoryCount", a->ns6__ArrayOfCategoryCount::CategoryCount, "ns6:CategoryCount"))
				{	a->ns6__ArrayOfCategoryCount::__sizeCategoryCount++;
					a->ns6__ArrayOfCategoryCount::CategoryCount = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__ArrayOfCategoryCount::CategoryCount)
			soap_pop_block(soap, soap_blist_CategoryCount1);
		if (a->ns6__ArrayOfCategoryCount::__sizeCategoryCount)
			a->ns6__ArrayOfCategoryCount::CategoryCount = (ns6__CategoryCount **)soap_save_block(soap, soap_blist_CategoryCount1, NULL, 1);
		else
		{	a->ns6__ArrayOfCategoryCount::CategoryCount = NULL;
			if (soap_blist_CategoryCount1)
				soap_end_block(soap, soap_blist_CategoryCount1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ArrayOfCategoryCount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ArrayOfCategoryCount, 0, sizeof(ns6__ArrayOfCategoryCount), 0, soap_copy_ns6__ArrayOfCategoryCount);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__ArrayOfCategoryCount * SOAP_FMAC4 soap_instantiate_ns6__ArrayOfCategoryCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ArrayOfCategoryCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ArrayOfCategoryCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__ArrayOfCategoryCount;
		if (size)
			*size = sizeof(ns6__ArrayOfCategoryCount);
		((ns6__ArrayOfCategoryCount*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__ArrayOfCategoryCount[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__ArrayOfCategoryCount);
		for (int i = 0; i < n; i++)
			((ns6__ArrayOfCategoryCount*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ArrayOfCategoryCount*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ArrayOfCategoryCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ArrayOfCategoryCount %p -> %p\n", q, p));
	*(ns6__ArrayOfCategoryCount*)p = *(ns6__ArrayOfCategoryCount*)q;
}

void ns6__FilterValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__FilterValue::Id = NULL;
	soap_default_string(soap, &this->ns6__FilterValue::Name);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__FilterValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns6__FilterValue::Id);
	soap_serialize_string(soap, &this->ns6__FilterValue::Name);
	/* transient soap skipped */
}

int ns6__FilterValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__FilterValue);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__FilterValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__FilterValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__FilterValue(struct soap *soap, const char *tag, int id, const ns6__FilterValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__FilterValue), "ns6:FilterValue"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToint(soap, "ns6:Id", -1, &(a->ns6__FilterValue::Id), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Name", -1, &(a->ns6__FilterValue::Name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__FilterValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__FilterValue(soap, this, tag, type);
}

SOAP_FMAC3 ns6__FilterValue * SOAP_FMAC4 soap_get_ns6__FilterValue(struct soap *soap, ns6__FilterValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__FilterValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__FilterValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__FilterValue(soap, tag, this, type);
}

SOAP_FMAC3 ns6__FilterValue * SOAP_FMAC4 soap_in_ns6__FilterValue(struct soap *soap, const char *tag, ns6__FilterValue *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__FilterValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__FilterValue, sizeof(ns6__FilterValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__FilterValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__FilterValue *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns6:Id", &(a->ns6__FilterValue::Id), "xsd:int"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Name", &(a->ns6__FilterValue::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__FilterValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__FilterValue, 0, sizeof(ns6__FilterValue), 0, soap_copy_ns6__FilterValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__FilterValue * SOAP_FMAC4 soap_instantiate_ns6__FilterValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__FilterValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__FilterValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__FilterValue;
		if (size)
			*size = sizeof(ns6__FilterValue);
		((ns6__FilterValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__FilterValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__FilterValue);
		for (int i = 0; i < n; i++)
			((ns6__FilterValue*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__FilterValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__FilterValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__FilterValue %p -> %p\n", q, p));
	*(ns6__FilterValue*)p = *(ns6__FilterValue*)q;
}

void ns6__Category::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__Category::Id = NULL;
	soap_default_string(soap, &this->ns6__Category::Name);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__Category::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns6__Category::Id);
	soap_serialize_string(soap, &this->ns6__Category::Name);
	/* transient soap skipped */
}

int ns6__Category::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Category);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__Category::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Category(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__Category(struct soap *soap, const char *tag, int id, const ns6__Category *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Category), "ns6:Category"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToint(soap, "ns6:Id", -1, &(a->ns6__Category::Id), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Name", -1, &(a->ns6__Category::Name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__Category::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Category(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Category * SOAP_FMAC4 soap_get_ns6__Category(struct soap *soap, ns6__Category *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__Category(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__Category::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__Category(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Category * SOAP_FMAC4 soap_in_ns6__Category(struct soap *soap, const char *tag, ns6__Category *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Category *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Category, sizeof(ns6__Category), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__Category)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Category *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns6:Id", &(a->ns6__Category::Id), "xsd:int"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Name", &(a->ns6__Category::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__Category *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Category, 0, sizeof(ns6__Category), 0, soap_copy_ns6__Category);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__Category * SOAP_FMAC4 soap_instantiate_ns6__Category(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Category(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Category, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__Category;
		if (size)
			*size = sizeof(ns6__Category);
		((ns6__Category*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__Category[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__Category);
		for (int i = 0; i < n; i++)
			((ns6__Category*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Category*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Category(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Category %p -> %p\n", q, p));
	*(ns6__Category*)p = *(ns6__Category*)q;
}

void ns6__Neighborhood::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns6__Neighborhood::City);
	this->ns6__Neighborhood::Id = NULL;
	soap_default_string(soap, &this->ns6__Neighborhood::Name);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__Neighborhood::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns6__Neighborhood::City);
	soap_serialize_PointerToint(soap, &this->ns6__Neighborhood::Id);
	soap_serialize_string(soap, &this->ns6__Neighborhood::Name);
	/* transient soap skipped */
}

int ns6__Neighborhood::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Neighborhood);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__Neighborhood::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Neighborhood(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__Neighborhood(struct soap *soap, const char *tag, int id, const ns6__Neighborhood *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Neighborhood), "ns6:Neighborhood"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns6:City", -1, &(a->ns6__Neighborhood::City), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns6:Id", -1, &(a->ns6__Neighborhood::Id), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Name", -1, &(a->ns6__Neighborhood::Name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__Neighborhood::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Neighborhood(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Neighborhood * SOAP_FMAC4 soap_get_ns6__Neighborhood(struct soap *soap, ns6__Neighborhood *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__Neighborhood(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__Neighborhood::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__Neighborhood(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Neighborhood * SOAP_FMAC4 soap_in_ns6__Neighborhood(struct soap *soap, const char *tag, ns6__Neighborhood *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Neighborhood *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Neighborhood, sizeof(ns6__Neighborhood), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__Neighborhood)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Neighborhood *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_City1 = 1;
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_City1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:City", &(a->ns6__Neighborhood::City), "xsd:string"))
				{	soap_flag_City1--;
					continue;
				}
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns6:Id", &(a->ns6__Neighborhood::Id), "xsd:int"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Name", &(a->ns6__Neighborhood::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__Neighborhood *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Neighborhood, 0, sizeof(ns6__Neighborhood), 0, soap_copy_ns6__Neighborhood);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__Neighborhood * SOAP_FMAC4 soap_instantiate_ns6__Neighborhood(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Neighborhood(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Neighborhood, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__Neighborhood;
		if (size)
			*size = sizeof(ns6__Neighborhood);
		((ns6__Neighborhood*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__Neighborhood[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__Neighborhood);
		for (int i = 0; i < n; i++)
			((ns6__Neighborhood*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Neighborhood*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Neighborhood(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Neighborhood %p -> %p\n", q, p));
	*(ns6__Neighborhood*)p = *(ns6__Neighborhood*)q;
}

void ns6__ValueListFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ValueListFilter::Values = NULL;
	this->ns6__AvailableFilter::PropertyId = NULL;
	soap_default_string(soap, &this->ns6__AvailableFilter::PropertyName);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__ValueListFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons7__ArrayOfanyType(soap, &this->ns6__ValueListFilter::Values);
	soap_serialize_PointerToint(soap, &this->ns6__AvailableFilter::PropertyId);
	soap_serialize_string(soap, &this->ns6__AvailableFilter::PropertyName);
	/* transient soap skipped */
}

int ns6__ValueListFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ValueListFilter);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__ValueListFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ValueListFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ValueListFilter(struct soap *soap, const char *tag, int id, const ns6__ValueListFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ValueListFilter), "ns6:ValueListFilter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToint(soap, "ns6:PropertyId", -1, &(a->ns6__AvailableFilter::PropertyId), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:PropertyName", -1, &(a->ns6__AvailableFilter::PropertyName), ""))
		return soap->error;
	if (soap_out_PointerTons7__ArrayOfanyType(soap, "ns6:Values", -1, &(a->ns6__ValueListFilter::Values), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__ValueListFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ValueListFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ValueListFilter * SOAP_FMAC4 soap_get_ns6__ValueListFilter(struct soap *soap, ns6__ValueListFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ValueListFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__ValueListFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ValueListFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ValueListFilter * SOAP_FMAC4 soap_in_ns6__ValueListFilter(struct soap *soap, const char *tag, ns6__ValueListFilter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ValueListFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ValueListFilter, sizeof(ns6__ValueListFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ValueListFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ValueListFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_PropertyId2 = 1;
	size_t soap_flag_PropertyName2 = 1;
	size_t soap_flag_Values1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_PropertyId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns6:PropertyId", &(a->ns6__AvailableFilter::PropertyId), "xsd:int"))
				{	soap_flag_PropertyId2--;
					continue;
				}
			if (soap_flag_PropertyName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:PropertyName", &(a->ns6__AvailableFilter::PropertyName), "xsd:string"))
				{	soap_flag_PropertyName2--;
					continue;
				}
			if (soap_flag_Values1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ArrayOfanyType(soap, "ns6:Values", &(a->ns6__ValueListFilter::Values), "ns7:ArrayOfanyType"))
				{	soap_flag_Values1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ValueListFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ValueListFilter, 0, sizeof(ns6__ValueListFilter), 0, soap_copy_ns6__ValueListFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__ValueListFilter * SOAP_FMAC4 soap_instantiate_ns6__ValueListFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ValueListFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ValueListFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__ValueListFilter;
		if (size)
			*size = sizeof(ns6__ValueListFilter);
		((ns6__ValueListFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__ValueListFilter[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__ValueListFilter);
		for (int i = 0; i < n; i++)
			((ns6__ValueListFilter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ValueListFilter*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ValueListFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ValueListFilter %p -> %p\n", q, p));
	*(ns6__ValueListFilter*)p = *(ns6__ValueListFilter*)q;
}

void ns6__RangeFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__RangeFilter::MaximumValue = NULL;
	this->ns6__RangeFilter::MinimumValue = NULL;
	this->ns6__AvailableFilter::PropertyId = NULL;
	soap_default_string(soap, &this->ns6__AvailableFilter::PropertyName);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__RangeFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &this->ns6__RangeFilter::MaximumValue);
	soap_serialize_PointerToxsd__anyType(soap, &this->ns6__RangeFilter::MinimumValue);
	soap_serialize_PointerToint(soap, &this->ns6__AvailableFilter::PropertyId);
	soap_serialize_string(soap, &this->ns6__AvailableFilter::PropertyName);
	/* transient soap skipped */
}

int ns6__RangeFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__RangeFilter);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__RangeFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RangeFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__RangeFilter(struct soap *soap, const char *tag, int id, const ns6__RangeFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RangeFilter), "ns6:RangeFilter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToint(soap, "ns6:PropertyId", -1, &(a->ns6__AvailableFilter::PropertyId), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:PropertyName", -1, &(a->ns6__AvailableFilter::PropertyName), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "ns6:MaximumValue", -1, &(a->ns6__RangeFilter::MaximumValue), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "ns6:MinimumValue", -1, &(a->ns6__RangeFilter::MinimumValue), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__RangeFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RangeFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RangeFilter * SOAP_FMAC4 soap_get_ns6__RangeFilter(struct soap *soap, ns6__RangeFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__RangeFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__RangeFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__RangeFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RangeFilter * SOAP_FMAC4 soap_in_ns6__RangeFilter(struct soap *soap, const char *tag, ns6__RangeFilter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__RangeFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RangeFilter, sizeof(ns6__RangeFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__RangeFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__RangeFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_PropertyId2 = 1;
	size_t soap_flag_PropertyName2 = 1;
	size_t soap_flag_MaximumValue1 = 1;
	size_t soap_flag_MinimumValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_PropertyId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns6:PropertyId", &(a->ns6__AvailableFilter::PropertyId), "xsd:int"))
				{	soap_flag_PropertyId2--;
					continue;
				}
			if (soap_flag_PropertyName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:PropertyName", &(a->ns6__AvailableFilter::PropertyName), "xsd:string"))
				{	soap_flag_PropertyName2--;
					continue;
				}
			if (soap_flag_MaximumValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "ns6:MaximumValue", &(a->ns6__RangeFilter::MaximumValue), "xsd:anyType"))
				{	soap_flag_MaximumValue1--;
					continue;
				}
			if (soap_flag_MinimumValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "ns6:MinimumValue", &(a->ns6__RangeFilter::MinimumValue), "xsd:anyType"))
				{	soap_flag_MinimumValue1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__RangeFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RangeFilter, 0, sizeof(ns6__RangeFilter), 0, soap_copy_ns6__RangeFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__RangeFilter * SOAP_FMAC4 soap_instantiate_ns6__RangeFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RangeFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__RangeFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__RangeFilter;
		if (size)
			*size = sizeof(ns6__RangeFilter);
		((ns6__RangeFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__RangeFilter[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__RangeFilter);
		for (int i = 0; i < n; i++)
			((ns6__RangeFilter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__RangeFilter*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__RangeFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__RangeFilter %p -> %p\n", q, p));
	*(ns6__RangeFilter*)p = *(ns6__RangeFilter*)q;
}

void ns6__AvailableFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__AvailableFilter::PropertyId = NULL;
	soap_default_string(soap, &this->ns6__AvailableFilter::PropertyName);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__AvailableFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns6__AvailableFilter::PropertyId);
	soap_serialize_string(soap, &this->ns6__AvailableFilter::PropertyName);
	/* transient soap skipped */
}

int ns6__AvailableFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__AvailableFilter);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__AvailableFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__AvailableFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__AvailableFilter(struct soap *soap, const char *tag, int id, const ns6__AvailableFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__AvailableFilter), "ns6:AvailableFilter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToint(soap, "ns6:PropertyId", -1, &(a->ns6__AvailableFilter::PropertyId), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:PropertyName", -1, &(a->ns6__AvailableFilter::PropertyName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__AvailableFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__AvailableFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns6__AvailableFilter * SOAP_FMAC4 soap_get_ns6__AvailableFilter(struct soap *soap, ns6__AvailableFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__AvailableFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__AvailableFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__AvailableFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns6__AvailableFilter * SOAP_FMAC4 soap_in_ns6__AvailableFilter(struct soap *soap, const char *tag, ns6__AvailableFilter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__AvailableFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__AvailableFilter, sizeof(ns6__AvailableFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__AvailableFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__AvailableFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_PropertyId1 = 1;
	size_t soap_flag_PropertyName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_PropertyId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns6:PropertyId", &(a->ns6__AvailableFilter::PropertyId), "xsd:int"))
				{	soap_flag_PropertyId1--;
					continue;
				}
			if (soap_flag_PropertyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:PropertyName", &(a->ns6__AvailableFilter::PropertyName), "xsd:string"))
				{	soap_flag_PropertyName1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__AvailableFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__AvailableFilter, 0, sizeof(ns6__AvailableFilter), 0, soap_copy_ns6__AvailableFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__AvailableFilter * SOAP_FMAC4 soap_instantiate_ns6__AvailableFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__AvailableFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__AvailableFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns6:RangeFilter"))
	{	cp->type = SOAP_TYPE_ns6__RangeFilter;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__RangeFilter;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__RangeFilter);
			((ns6__RangeFilter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__RangeFilter[n];
			if (size)
				*size = n * sizeof(ns6__RangeFilter);
			for (int i = 0; i < n; i++)
				((ns6__RangeFilter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__RangeFilter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:ValueListFilter"))
	{	cp->type = SOAP_TYPE_ns6__ValueListFilter;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__ValueListFilter;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__ValueListFilter);
			((ns6__ValueListFilter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__ValueListFilter[n];
			if (size)
				*size = n * sizeof(ns6__ValueListFilter);
			for (int i = 0; i < n; i++)
				((ns6__ValueListFilter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ValueListFilter*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns6__AvailableFilter;
		if (size)
			*size = sizeof(ns6__AvailableFilter);
		((ns6__AvailableFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__AvailableFilter[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__AvailableFilter);
		for (int i = 0; i < n; i++)
			((ns6__AvailableFilter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__AvailableFilter*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__AvailableFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__AvailableFilter %p -> %p\n", q, p));
	*(ns6__AvailableFilter*)p = *(ns6__AvailableFilter*)q;
}

void ns6__ArrayOfAvailableFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ArrayOfAvailableFilter::__sizeAvailableFilter = 0;
	this->ns6__ArrayOfAvailableFilter::AvailableFilter = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__ArrayOfAvailableFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns6__ArrayOfAvailableFilter::AvailableFilter)
	{	int i;
		for (i = 0; i < this->ns6__ArrayOfAvailableFilter::__sizeAvailableFilter; i++)
		{
			soap_serialize_PointerTons6__AvailableFilter(soap, this->ns6__ArrayOfAvailableFilter::AvailableFilter + i);
		}
	}
	/* transient soap skipped */
}

int ns6__ArrayOfAvailableFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ArrayOfAvailableFilter);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__ArrayOfAvailableFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ArrayOfAvailableFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ArrayOfAvailableFilter(struct soap *soap, const char *tag, int id, const ns6__ArrayOfAvailableFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ArrayOfAvailableFilter), "ns6:ArrayOfAvailableFilter"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns6__ArrayOfAvailableFilter::AvailableFilter)
	{	int i;
		for (i = 0; i < a->ns6__ArrayOfAvailableFilter::__sizeAvailableFilter; i++)
			if (soap_out_PointerTons6__AvailableFilter(soap, "ns6:AvailableFilter", -1, a->ns6__ArrayOfAvailableFilter::AvailableFilter + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__ArrayOfAvailableFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ArrayOfAvailableFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ArrayOfAvailableFilter * SOAP_FMAC4 soap_get_ns6__ArrayOfAvailableFilter(struct soap *soap, ns6__ArrayOfAvailableFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ArrayOfAvailableFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__ArrayOfAvailableFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ArrayOfAvailableFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ArrayOfAvailableFilter * SOAP_FMAC4 soap_in_ns6__ArrayOfAvailableFilter(struct soap *soap, const char *tag, ns6__ArrayOfAvailableFilter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ArrayOfAvailableFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ArrayOfAvailableFilter, sizeof(ns6__ArrayOfAvailableFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ArrayOfAvailableFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ArrayOfAvailableFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_AvailableFilter1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:AvailableFilter", 1, NULL))
			{	if (a->ns6__ArrayOfAvailableFilter::AvailableFilter == NULL)
				{	if (soap_blist_AvailableFilter1 == NULL)
						soap_blist_AvailableFilter1 = soap_new_block(soap);
					a->ns6__ArrayOfAvailableFilter::AvailableFilter = (ns6__AvailableFilter **)soap_push_block(soap, soap_blist_AvailableFilter1, sizeof(ns6__AvailableFilter *));
					if (a->ns6__ArrayOfAvailableFilter::AvailableFilter == NULL)
						return NULL;
					*a->ns6__ArrayOfAvailableFilter::AvailableFilter = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons6__AvailableFilter(soap, "ns6:AvailableFilter", a->ns6__ArrayOfAvailableFilter::AvailableFilter, "ns6:AvailableFilter"))
				{	a->ns6__ArrayOfAvailableFilter::__sizeAvailableFilter++;
					a->ns6__ArrayOfAvailableFilter::AvailableFilter = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__ArrayOfAvailableFilter::AvailableFilter)
			soap_pop_block(soap, soap_blist_AvailableFilter1);
		if (a->ns6__ArrayOfAvailableFilter::__sizeAvailableFilter)
			a->ns6__ArrayOfAvailableFilter::AvailableFilter = (ns6__AvailableFilter **)soap_save_block(soap, soap_blist_AvailableFilter1, NULL, 1);
		else
		{	a->ns6__ArrayOfAvailableFilter::AvailableFilter = NULL;
			if (soap_blist_AvailableFilter1)
				soap_end_block(soap, soap_blist_AvailableFilter1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ArrayOfAvailableFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ArrayOfAvailableFilter, 0, sizeof(ns6__ArrayOfAvailableFilter), 0, soap_copy_ns6__ArrayOfAvailableFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__ArrayOfAvailableFilter * SOAP_FMAC4 soap_instantiate_ns6__ArrayOfAvailableFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ArrayOfAvailableFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ArrayOfAvailableFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__ArrayOfAvailableFilter;
		if (size)
			*size = sizeof(ns6__ArrayOfAvailableFilter);
		((ns6__ArrayOfAvailableFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__ArrayOfAvailableFilter[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__ArrayOfAvailableFilter);
		for (int i = 0; i < n; i++)
			((ns6__ArrayOfAvailableFilter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ArrayOfAvailableFilter*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ArrayOfAvailableFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ArrayOfAvailableFilter %p -> %p\n", q, p));
	*(ns6__ArrayOfAvailableFilter*)p = *(ns6__ArrayOfAvailableFilter*)q;
}

void ns6__SearchRegion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__SearchRegion::BoundingArea = NULL;
	this->ns6__SearchRegion::GeocodeLocation = NULL;
	soap_default_string(soap, &this->ns6__SearchRegion::Source);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__SearchRegion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ShapeBase(soap, &this->ns6__SearchRegion::BoundingArea);
	soap_serialize_PointerTons4__GeocodeResult(soap, &this->ns6__SearchRegion::GeocodeLocation);
	soap_serialize_string(soap, &this->ns6__SearchRegion::Source);
	/* transient soap skipped */
}

int ns6__SearchRegion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__SearchRegion);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__SearchRegion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SearchRegion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SearchRegion(struct soap *soap, const char *tag, int id, const ns6__SearchRegion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SearchRegion), "ns6:SearchRegion"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__ShapeBase(soap, "ns6:BoundingArea", -1, &(a->ns6__SearchRegion::BoundingArea), ""))
		return soap->error;
	if (soap_out_PointerTons4__GeocodeResult(soap, "ns6:GeocodeLocation", -1, &(a->ns6__SearchRegion::GeocodeLocation), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Source", -1, &(a->ns6__SearchRegion::Source), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__SearchRegion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SearchRegion(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SearchRegion * SOAP_FMAC4 soap_get_ns6__SearchRegion(struct soap *soap, ns6__SearchRegion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SearchRegion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__SearchRegion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__SearchRegion(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SearchRegion * SOAP_FMAC4 soap_in_ns6__SearchRegion(struct soap *soap, const char *tag, ns6__SearchRegion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SearchRegion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SearchRegion, sizeof(ns6__SearchRegion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__SearchRegion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__SearchRegion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_BoundingArea1 = 1;
	size_t soap_flag_GeocodeLocation1 = 1;
	size_t soap_flag_Source1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_BoundingArea1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ShapeBase(soap, "ns6:BoundingArea", &(a->ns6__SearchRegion::BoundingArea), "ns4:ShapeBase"))
				{	soap_flag_BoundingArea1--;
					continue;
				}
			if (soap_flag_GeocodeLocation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GeocodeResult(soap, "ns6:GeocodeLocation", &(a->ns6__SearchRegion::GeocodeLocation), "ns4:GeocodeResult"))
				{	soap_flag_GeocodeLocation1--;
					continue;
				}
			if (soap_flag_Source1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Source", &(a->ns6__SearchRegion::Source), "xsd:string"))
				{	soap_flag_Source1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__SearchRegion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SearchRegion, 0, sizeof(ns6__SearchRegion), 0, soap_copy_ns6__SearchRegion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__SearchRegion * SOAP_FMAC4 soap_instantiate_ns6__SearchRegion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__SearchRegion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__SearchRegion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__SearchRegion;
		if (size)
			*size = sizeof(ns6__SearchRegion);
		((ns6__SearchRegion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__SearchRegion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__SearchRegion);
		for (int i = 0; i < n; i++)
			((ns6__SearchRegion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__SearchRegion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__SearchRegion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__SearchRegion %p -> %p\n", q, p));
	*(ns6__SearchRegion*)p = *(ns6__SearchRegion*)q;
}

void ns6__ArrayOfSearchRegion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ArrayOfSearchRegion::__sizeSearchRegion = 0;
	this->ns6__ArrayOfSearchRegion::SearchRegion = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__ArrayOfSearchRegion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns6__ArrayOfSearchRegion::SearchRegion)
	{	int i;
		for (i = 0; i < this->ns6__ArrayOfSearchRegion::__sizeSearchRegion; i++)
		{
			soap_serialize_PointerTons6__SearchRegion(soap, this->ns6__ArrayOfSearchRegion::SearchRegion + i);
		}
	}
	/* transient soap skipped */
}

int ns6__ArrayOfSearchRegion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ArrayOfSearchRegion);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__ArrayOfSearchRegion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ArrayOfSearchRegion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ArrayOfSearchRegion(struct soap *soap, const char *tag, int id, const ns6__ArrayOfSearchRegion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ArrayOfSearchRegion), "ns6:ArrayOfSearchRegion"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns6__ArrayOfSearchRegion::SearchRegion)
	{	int i;
		for (i = 0; i < a->ns6__ArrayOfSearchRegion::__sizeSearchRegion; i++)
			if (soap_out_PointerTons6__SearchRegion(soap, "ns6:SearchRegion", -1, a->ns6__ArrayOfSearchRegion::SearchRegion + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__ArrayOfSearchRegion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ArrayOfSearchRegion(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ArrayOfSearchRegion * SOAP_FMAC4 soap_get_ns6__ArrayOfSearchRegion(struct soap *soap, ns6__ArrayOfSearchRegion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ArrayOfSearchRegion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__ArrayOfSearchRegion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ArrayOfSearchRegion(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ArrayOfSearchRegion * SOAP_FMAC4 soap_in_ns6__ArrayOfSearchRegion(struct soap *soap, const char *tag, ns6__ArrayOfSearchRegion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ArrayOfSearchRegion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ArrayOfSearchRegion, sizeof(ns6__ArrayOfSearchRegion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ArrayOfSearchRegion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ArrayOfSearchRegion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_SearchRegion1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:SearchRegion", 1, NULL))
			{	if (a->ns6__ArrayOfSearchRegion::SearchRegion == NULL)
				{	if (soap_blist_SearchRegion1 == NULL)
						soap_blist_SearchRegion1 = soap_new_block(soap);
					a->ns6__ArrayOfSearchRegion::SearchRegion = (ns6__SearchRegion **)soap_push_block(soap, soap_blist_SearchRegion1, sizeof(ns6__SearchRegion *));
					if (a->ns6__ArrayOfSearchRegion::SearchRegion == NULL)
						return NULL;
					*a->ns6__ArrayOfSearchRegion::SearchRegion = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons6__SearchRegion(soap, "ns6:SearchRegion", a->ns6__ArrayOfSearchRegion::SearchRegion, "ns6:SearchRegion"))
				{	a->ns6__ArrayOfSearchRegion::__sizeSearchRegion++;
					a->ns6__ArrayOfSearchRegion::SearchRegion = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__ArrayOfSearchRegion::SearchRegion)
			soap_pop_block(soap, soap_blist_SearchRegion1);
		if (a->ns6__ArrayOfSearchRegion::__sizeSearchRegion)
			a->ns6__ArrayOfSearchRegion::SearchRegion = (ns6__SearchRegion **)soap_save_block(soap, soap_blist_SearchRegion1, NULL, 1);
		else
		{	a->ns6__ArrayOfSearchRegion::SearchRegion = NULL;
			if (soap_blist_SearchRegion1)
				soap_end_block(soap, soap_blist_SearchRegion1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ArrayOfSearchRegion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ArrayOfSearchRegion, 0, sizeof(ns6__ArrayOfSearchRegion), 0, soap_copy_ns6__ArrayOfSearchRegion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__ArrayOfSearchRegion * SOAP_FMAC4 soap_instantiate_ns6__ArrayOfSearchRegion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ArrayOfSearchRegion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ArrayOfSearchRegion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__ArrayOfSearchRegion;
		if (size)
			*size = sizeof(ns6__ArrayOfSearchRegion);
		((ns6__ArrayOfSearchRegion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__ArrayOfSearchRegion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__ArrayOfSearchRegion);
		for (int i = 0; i < n; i++)
			((ns6__ArrayOfSearchRegion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ArrayOfSearchRegion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ArrayOfSearchRegion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ArrayOfSearchRegion %p -> %p\n", q, p));
	*(ns6__ArrayOfSearchRegion*)p = *(ns6__ArrayOfSearchRegion*)q;
}

void ns6__SearchResultSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__SearchResultSet::AlternateSearchRegions = NULL;
	this->ns6__SearchResultSet::AvailableFilters = NULL;
	this->ns6__SearchResultSet::CategoryCounts = NULL;
	this->ns6__SearchResultSet::EstimatedMatches = NULL;
	soap_default_string(soap, &this->ns6__SearchResultSet::ListingType);
	this->ns6__SearchResultSet::Parse = NULL;
	this->ns6__SearchResultSet::QueryCorrected = NULL;
	this->ns6__SearchResultSet::Results = NULL;
	this->ns6__SearchResultSet::SearchRegion = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__SearchResultSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__ArrayOfSearchRegion(soap, &this->ns6__SearchResultSet::AlternateSearchRegions);
	soap_serialize_PointerTons6__ArrayOfAvailableFilter(soap, &this->ns6__SearchResultSet::AvailableFilters);
	soap_serialize_PointerTons6__ArrayOfCategoryCount(soap, &this->ns6__SearchResultSet::CategoryCounts);
	soap_serialize_PointerToint(soap, &this->ns6__SearchResultSet::EstimatedMatches);
	soap_serialize_string(soap, &this->ns6__SearchResultSet::ListingType);
	soap_serialize_PointerTons6__Parse(soap, &this->ns6__SearchResultSet::Parse);
	soap_serialize_PointerTobool(soap, &this->ns6__SearchResultSet::QueryCorrected);
	soap_serialize_PointerTons6__ArrayOfSearchResultBase(soap, &this->ns6__SearchResultSet::Results);
	soap_serialize_PointerTons6__SearchRegion(soap, &this->ns6__SearchResultSet::SearchRegion);
	/* transient soap skipped */
}

int ns6__SearchResultSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__SearchResultSet);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__SearchResultSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SearchResultSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SearchResultSet(struct soap *soap, const char *tag, int id, const ns6__SearchResultSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SearchResultSet), "ns6:SearchResultSet"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons6__ArrayOfSearchRegion(soap, "ns6:AlternateSearchRegions", -1, &(a->ns6__SearchResultSet::AlternateSearchRegions), ""))
		return soap->error;
	if (soap_out_PointerTons6__ArrayOfAvailableFilter(soap, "ns6:AvailableFilters", -1, &(a->ns6__SearchResultSet::AvailableFilters), ""))
		return soap->error;
	if (soap_out_PointerTons6__ArrayOfCategoryCount(soap, "ns6:CategoryCounts", -1, &(a->ns6__SearchResultSet::CategoryCounts), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns6:EstimatedMatches", -1, &(a->ns6__SearchResultSet::EstimatedMatches), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:ListingType", -1, &(a->ns6__SearchResultSet::ListingType), ""))
		return soap->error;
	if (soap_out_PointerTons6__Parse(soap, "ns6:Parse", -1, &(a->ns6__SearchResultSet::Parse), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns6:QueryCorrected", -1, &(a->ns6__SearchResultSet::QueryCorrected), ""))
		return soap->error;
	if (soap_out_PointerTons6__ArrayOfSearchResultBase(soap, "ns6:Results", -1, &(a->ns6__SearchResultSet::Results), ""))
		return soap->error;
	if (soap_out_PointerTons6__SearchRegion(soap, "ns6:SearchRegion", -1, &(a->ns6__SearchResultSet::SearchRegion), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__SearchResultSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SearchResultSet(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SearchResultSet * SOAP_FMAC4 soap_get_ns6__SearchResultSet(struct soap *soap, ns6__SearchResultSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SearchResultSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__SearchResultSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__SearchResultSet(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SearchResultSet * SOAP_FMAC4 soap_in_ns6__SearchResultSet(struct soap *soap, const char *tag, ns6__SearchResultSet *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SearchResultSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SearchResultSet, sizeof(ns6__SearchResultSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__SearchResultSet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__SearchResultSet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AlternateSearchRegions1 = 1;
	size_t soap_flag_AvailableFilters1 = 1;
	size_t soap_flag_CategoryCounts1 = 1;
	size_t soap_flag_EstimatedMatches1 = 1;
	size_t soap_flag_ListingType1 = 1;
	size_t soap_flag_Parse1 = 1;
	size_t soap_flag_QueryCorrected1 = 1;
	size_t soap_flag_Results1 = 1;
	size_t soap_flag_SearchRegion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_AlternateSearchRegions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ArrayOfSearchRegion(soap, "ns6:AlternateSearchRegions", &(a->ns6__SearchResultSet::AlternateSearchRegions), "ns6:ArrayOfSearchRegion"))
				{	soap_flag_AlternateSearchRegions1--;
					continue;
				}
			if (soap_flag_AvailableFilters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ArrayOfAvailableFilter(soap, "ns6:AvailableFilters", &(a->ns6__SearchResultSet::AvailableFilters), "ns6:ArrayOfAvailableFilter"))
				{	soap_flag_AvailableFilters1--;
					continue;
				}
			if (soap_flag_CategoryCounts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ArrayOfCategoryCount(soap, "ns6:CategoryCounts", &(a->ns6__SearchResultSet::CategoryCounts), "ns6:ArrayOfCategoryCount"))
				{	soap_flag_CategoryCounts1--;
					continue;
				}
			if (soap_flag_EstimatedMatches1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns6:EstimatedMatches", &(a->ns6__SearchResultSet::EstimatedMatches), "xsd:int"))
				{	soap_flag_EstimatedMatches1--;
					continue;
				}
			if (soap_flag_ListingType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:ListingType", &(a->ns6__SearchResultSet::ListingType), "xsd:string"))
				{	soap_flag_ListingType1--;
					continue;
				}
			if (soap_flag_Parse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Parse(soap, "ns6:Parse", &(a->ns6__SearchResultSet::Parse), "ns6:Parse"))
				{	soap_flag_Parse1--;
					continue;
				}
			if (soap_flag_QueryCorrected1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns6:QueryCorrected", &(a->ns6__SearchResultSet::QueryCorrected), "xsd:boolean"))
				{	soap_flag_QueryCorrected1--;
					continue;
				}
			if (soap_flag_Results1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ArrayOfSearchResultBase(soap, "ns6:Results", &(a->ns6__SearchResultSet::Results), "ns6:ArrayOfSearchResultBase"))
				{	soap_flag_Results1--;
					continue;
				}
			if (soap_flag_SearchRegion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__SearchRegion(soap, "ns6:SearchRegion", &(a->ns6__SearchResultSet::SearchRegion), "ns6:SearchRegion"))
				{	soap_flag_SearchRegion1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__SearchResultSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SearchResultSet, 0, sizeof(ns6__SearchResultSet), 0, soap_copy_ns6__SearchResultSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__SearchResultSet * SOAP_FMAC4 soap_instantiate_ns6__SearchResultSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__SearchResultSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__SearchResultSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__SearchResultSet;
		if (size)
			*size = sizeof(ns6__SearchResultSet);
		((ns6__SearchResultSet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__SearchResultSet[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__SearchResultSet);
		for (int i = 0; i < n; i++)
			((ns6__SearchResultSet*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__SearchResultSet*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__SearchResultSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__SearchResultSet %p -> %p\n", q, p));
	*(ns6__SearchResultSet*)p = *(ns6__SearchResultSet*)q;
}

void ns6__ArrayOfSearchResultSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ArrayOfSearchResultSet::__sizeSearchResultSet = 0;
	this->ns6__ArrayOfSearchResultSet::SearchResultSet = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__ArrayOfSearchResultSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns6__ArrayOfSearchResultSet::SearchResultSet)
	{	int i;
		for (i = 0; i < this->ns6__ArrayOfSearchResultSet::__sizeSearchResultSet; i++)
		{
			soap_serialize_PointerTons6__SearchResultSet(soap, this->ns6__ArrayOfSearchResultSet::SearchResultSet + i);
		}
	}
	/* transient soap skipped */
}

int ns6__ArrayOfSearchResultSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ArrayOfSearchResultSet);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__ArrayOfSearchResultSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ArrayOfSearchResultSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ArrayOfSearchResultSet(struct soap *soap, const char *tag, int id, const ns6__ArrayOfSearchResultSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ArrayOfSearchResultSet), "ns6:ArrayOfSearchResultSet"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns6__ArrayOfSearchResultSet::SearchResultSet)
	{	int i;
		for (i = 0; i < a->ns6__ArrayOfSearchResultSet::__sizeSearchResultSet; i++)
			if (soap_out_PointerTons6__SearchResultSet(soap, "ns6:SearchResultSet", -1, a->ns6__ArrayOfSearchResultSet::SearchResultSet + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__ArrayOfSearchResultSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ArrayOfSearchResultSet(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ArrayOfSearchResultSet * SOAP_FMAC4 soap_get_ns6__ArrayOfSearchResultSet(struct soap *soap, ns6__ArrayOfSearchResultSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ArrayOfSearchResultSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__ArrayOfSearchResultSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ArrayOfSearchResultSet(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ArrayOfSearchResultSet * SOAP_FMAC4 soap_in_ns6__ArrayOfSearchResultSet(struct soap *soap, const char *tag, ns6__ArrayOfSearchResultSet *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ArrayOfSearchResultSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ArrayOfSearchResultSet, sizeof(ns6__ArrayOfSearchResultSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ArrayOfSearchResultSet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ArrayOfSearchResultSet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_SearchResultSet1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:SearchResultSet", 1, NULL))
			{	if (a->ns6__ArrayOfSearchResultSet::SearchResultSet == NULL)
				{	if (soap_blist_SearchResultSet1 == NULL)
						soap_blist_SearchResultSet1 = soap_new_block(soap);
					a->ns6__ArrayOfSearchResultSet::SearchResultSet = (ns6__SearchResultSet **)soap_push_block(soap, soap_blist_SearchResultSet1, sizeof(ns6__SearchResultSet *));
					if (a->ns6__ArrayOfSearchResultSet::SearchResultSet == NULL)
						return NULL;
					*a->ns6__ArrayOfSearchResultSet::SearchResultSet = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons6__SearchResultSet(soap, "ns6:SearchResultSet", a->ns6__ArrayOfSearchResultSet::SearchResultSet, "ns6:SearchResultSet"))
				{	a->ns6__ArrayOfSearchResultSet::__sizeSearchResultSet++;
					a->ns6__ArrayOfSearchResultSet::SearchResultSet = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__ArrayOfSearchResultSet::SearchResultSet)
			soap_pop_block(soap, soap_blist_SearchResultSet1);
		if (a->ns6__ArrayOfSearchResultSet::__sizeSearchResultSet)
			a->ns6__ArrayOfSearchResultSet::SearchResultSet = (ns6__SearchResultSet **)soap_save_block(soap, soap_blist_SearchResultSet1, NULL, 1);
		else
		{	a->ns6__ArrayOfSearchResultSet::SearchResultSet = NULL;
			if (soap_blist_SearchResultSet1)
				soap_end_block(soap, soap_blist_SearchResultSet1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ArrayOfSearchResultSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ArrayOfSearchResultSet, 0, sizeof(ns6__ArrayOfSearchResultSet), 0, soap_copy_ns6__ArrayOfSearchResultSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__ArrayOfSearchResultSet * SOAP_FMAC4 soap_instantiate_ns6__ArrayOfSearchResultSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ArrayOfSearchResultSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ArrayOfSearchResultSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__ArrayOfSearchResultSet;
		if (size)
			*size = sizeof(ns6__ArrayOfSearchResultSet);
		((ns6__ArrayOfSearchResultSet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__ArrayOfSearchResultSet[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__ArrayOfSearchResultSet);
		for (int i = 0; i < n; i++)
			((ns6__ArrayOfSearchResultSet*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ArrayOfSearchResultSet*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ArrayOfSearchResultSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ArrayOfSearchResultSet %p -> %p\n", q, p));
	*(ns6__ArrayOfSearchResultSet*)p = *(ns6__ArrayOfSearchResultSet*)q;
}

void ns6__QuerySuggestion::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns6__QuerySuggestion::Query);
	this->ns6__QuerySuggestion::StructuredQuery = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__QuerySuggestion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns6__QuerySuggestion::Query);
	soap_serialize_PointerTons6__StructuredSearchQuery(soap, &this->ns6__QuerySuggestion::StructuredQuery);
	/* transient soap skipped */
}

int ns6__QuerySuggestion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__QuerySuggestion);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__QuerySuggestion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__QuerySuggestion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__QuerySuggestion(struct soap *soap, const char *tag, int id, const ns6__QuerySuggestion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__QuerySuggestion), "ns6:QuerySuggestion"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns6:Query", -1, &(a->ns6__QuerySuggestion::Query), ""))
		return soap->error;
	if (soap_out_PointerTons6__StructuredSearchQuery(soap, "ns6:StructuredQuery", -1, &(a->ns6__QuerySuggestion::StructuredQuery), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__QuerySuggestion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__QuerySuggestion(soap, this, tag, type);
}

SOAP_FMAC3 ns6__QuerySuggestion * SOAP_FMAC4 soap_get_ns6__QuerySuggestion(struct soap *soap, ns6__QuerySuggestion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__QuerySuggestion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__QuerySuggestion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__QuerySuggestion(soap, tag, this, type);
}

SOAP_FMAC3 ns6__QuerySuggestion * SOAP_FMAC4 soap_in_ns6__QuerySuggestion(struct soap *soap, const char *tag, ns6__QuerySuggestion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__QuerySuggestion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__QuerySuggestion, sizeof(ns6__QuerySuggestion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__QuerySuggestion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__QuerySuggestion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Query1 = 1;
	size_t soap_flag_StructuredQuery1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Query1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Query", &(a->ns6__QuerySuggestion::Query), "xsd:string"))
				{	soap_flag_Query1--;
					continue;
				}
			if (soap_flag_StructuredQuery1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__StructuredSearchQuery(soap, "ns6:StructuredQuery", &(a->ns6__QuerySuggestion::StructuredQuery), "ns6:StructuredSearchQuery"))
				{	soap_flag_StructuredQuery1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__QuerySuggestion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__QuerySuggestion, 0, sizeof(ns6__QuerySuggestion), 0, soap_copy_ns6__QuerySuggestion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__QuerySuggestion * SOAP_FMAC4 soap_instantiate_ns6__QuerySuggestion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__QuerySuggestion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__QuerySuggestion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__QuerySuggestion;
		if (size)
			*size = sizeof(ns6__QuerySuggestion);
		((ns6__QuerySuggestion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__QuerySuggestion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__QuerySuggestion);
		for (int i = 0; i < n; i++)
			((ns6__QuerySuggestion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__QuerySuggestion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__QuerySuggestion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__QuerySuggestion %p -> %p\n", q, p));
	*(ns6__QuerySuggestion*)p = *(ns6__QuerySuggestion*)q;
}

void ns6__SearchResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__SearchResponse::QuerySuggestion = NULL;
	this->ns6__SearchResponse::ResultSets = NULL;
	this->ns4__ResponseBase::ResponseSummary = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__SearchResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__QuerySuggestion(soap, &this->ns6__SearchResponse::QuerySuggestion);
	soap_serialize_PointerTons6__ArrayOfSearchResultSet(soap, &this->ns6__SearchResponse::ResultSets);
	soap_serialize_PointerTons4__ResponseSummary(soap, &this->ns4__ResponseBase::ResponseSummary);
	/* transient soap skipped */
}

int ns6__SearchResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__SearchResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__SearchResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SearchResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SearchResponse(struct soap *soap, const char *tag, int id, const ns6__SearchResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SearchResponse), "ns6:SearchResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__ResponseSummary(soap, "ns4:ResponseSummary", -1, &(a->ns4__ResponseBase::ResponseSummary), ""))
		return soap->error;
	if (soap_out_PointerTons6__QuerySuggestion(soap, "ns6:QuerySuggestion", -1, &(a->ns6__SearchResponse::QuerySuggestion), ""))
		return soap->error;
	if (soap_out_PointerTons6__ArrayOfSearchResultSet(soap, "ns6:ResultSets", -1, &(a->ns6__SearchResponse::ResultSets), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__SearchResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SearchResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SearchResponse * SOAP_FMAC4 soap_get_ns6__SearchResponse(struct soap *soap, ns6__SearchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SearchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__SearchResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__SearchResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SearchResponse * SOAP_FMAC4 soap_in_ns6__SearchResponse(struct soap *soap, const char *tag, ns6__SearchResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SearchResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SearchResponse, sizeof(ns6__SearchResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__SearchResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__SearchResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_ResponseSummary2 = 1;
	size_t soap_flag_QuerySuggestion1 = 1;
	size_t soap_flag_ResultSets1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ResponseSummary2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ResponseSummary(soap, "ns4:ResponseSummary", &(a->ns4__ResponseBase::ResponseSummary), "ns4:ResponseSummary"))
				{	soap_flag_ResponseSummary2--;
					continue;
				}
			if (soap_flag_QuerySuggestion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__QuerySuggestion(soap, "ns6:QuerySuggestion", &(a->ns6__SearchResponse::QuerySuggestion), "ns6:QuerySuggestion"))
				{	soap_flag_QuerySuggestion1--;
					continue;
				}
			if (soap_flag_ResultSets1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ArrayOfSearchResultSet(soap, "ns6:ResultSets", &(a->ns6__SearchResponse::ResultSets), "ns6:ArrayOfSearchResultSet"))
				{	soap_flag_ResultSets1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__SearchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SearchResponse, 0, sizeof(ns6__SearchResponse), 0, soap_copy_ns6__SearchResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__SearchResponse * SOAP_FMAC4 soap_instantiate_ns6__SearchResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__SearchResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__SearchResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__SearchResponse;
		if (size)
			*size = sizeof(ns6__SearchResponse);
		((ns6__SearchResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__SearchResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__SearchResponse);
		for (int i = 0; i < n; i++)
			((ns6__SearchResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__SearchResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__SearchResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__SearchResponse %p -> %p\n", q, p));
	*(ns6__SearchResponse*)p = *(ns6__SearchResponse*)q;
}

void ns6__StructuredSearchQuery::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns6__StructuredSearchQuery::Keyword);
	soap_default_string(soap, &this->ns6__StructuredSearchQuery::Location);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__StructuredSearchQuery::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns6__StructuredSearchQuery::Keyword);
	soap_serialize_string(soap, &this->ns6__StructuredSearchQuery::Location);
	/* transient soap skipped */
}

int ns6__StructuredSearchQuery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__StructuredSearchQuery);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__StructuredSearchQuery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__StructuredSearchQuery(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__StructuredSearchQuery(struct soap *soap, const char *tag, int id, const ns6__StructuredSearchQuery *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__StructuredSearchQuery), "ns6:StructuredSearchQuery"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns6:Keyword", -1, &(a->ns6__StructuredSearchQuery::Keyword), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Location", -1, &(a->ns6__StructuredSearchQuery::Location), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__StructuredSearchQuery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__StructuredSearchQuery(soap, this, tag, type);
}

SOAP_FMAC3 ns6__StructuredSearchQuery * SOAP_FMAC4 soap_get_ns6__StructuredSearchQuery(struct soap *soap, ns6__StructuredSearchQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__StructuredSearchQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__StructuredSearchQuery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__StructuredSearchQuery(soap, tag, this, type);
}

SOAP_FMAC3 ns6__StructuredSearchQuery * SOAP_FMAC4 soap_in_ns6__StructuredSearchQuery(struct soap *soap, const char *tag, ns6__StructuredSearchQuery *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__StructuredSearchQuery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__StructuredSearchQuery, sizeof(ns6__StructuredSearchQuery), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__StructuredSearchQuery)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__StructuredSearchQuery *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Keyword1 = 1;
	size_t soap_flag_Location1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Keyword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Keyword", &(a->ns6__StructuredSearchQuery::Keyword), "xsd:string"))
				{	soap_flag_Keyword1--;
					continue;
				}
			if (soap_flag_Location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Location", &(a->ns6__StructuredSearchQuery::Location), "xsd:string"))
				{	soap_flag_Location1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__StructuredSearchQuery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__StructuredSearchQuery, 0, sizeof(ns6__StructuredSearchQuery), 0, soap_copy_ns6__StructuredSearchQuery);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__StructuredSearchQuery * SOAP_FMAC4 soap_instantiate_ns6__StructuredSearchQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__StructuredSearchQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__StructuredSearchQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__StructuredSearchQuery;
		if (size)
			*size = sizeof(ns6__StructuredSearchQuery);
		((ns6__StructuredSearchQuery*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__StructuredSearchQuery[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__StructuredSearchQuery);
		for (int i = 0; i < n; i++)
			((ns6__StructuredSearchQuery*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__StructuredSearchQuery*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__StructuredSearchQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__StructuredSearchQuery %p -> %p\n", q, p));
	*(ns6__StructuredSearchQuery*)p = *(ns6__StructuredSearchQuery*)q;
}

void ns6__SearchOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__SearchOptions::AutocorrectQuery = NULL;
	this->ns6__SearchOptions::Count = NULL;
	this->ns6__SearchOptions::Filters = NULL;
	this->ns6__SearchOptions::ListingType = NULL;
	this->ns6__SearchOptions::ParseOnly = NULL;
	this->ns6__SearchOptions::SortOrder = NULL;
	this->ns6__SearchOptions::StartingIndex = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__SearchOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &this->ns6__SearchOptions::AutocorrectQuery);
	soap_serialize_PointerToint(soap, &this->ns6__SearchOptions::Count);
	soap_serialize_PointerTons4__FilterExpressionBase(soap, &this->ns6__SearchOptions::Filters);
	soap_serialize_PointerTons6__ListingType(soap, &this->ns6__SearchOptions::ListingType);
	soap_serialize_PointerTobool(soap, &this->ns6__SearchOptions::ParseOnly);
	soap_serialize_PointerTons6__SortOrder(soap, &this->ns6__SearchOptions::SortOrder);
	soap_serialize_PointerToint(soap, &this->ns6__SearchOptions::StartingIndex);
	/* transient soap skipped */
}

int ns6__SearchOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__SearchOptions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__SearchOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SearchOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SearchOptions(struct soap *soap, const char *tag, int id, const ns6__SearchOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SearchOptions), "ns6:SearchOptions"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTobool(soap, "ns6:AutocorrectQuery", -1, &(a->ns6__SearchOptions::AutocorrectQuery), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns6:Count", -1, &(a->ns6__SearchOptions::Count), ""))
		return soap->error;
	if (soap_out_PointerTons4__FilterExpressionBase(soap, "ns6:Filters", -1, &(a->ns6__SearchOptions::Filters), ""))
		return soap->error;
	if (soap_out_PointerTons6__ListingType(soap, "ns6:ListingType", -1, &(a->ns6__SearchOptions::ListingType), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns6:ParseOnly", -1, &(a->ns6__SearchOptions::ParseOnly), ""))
		return soap->error;
	if (soap_out_PointerTons6__SortOrder(soap, "ns6:SortOrder", -1, &(a->ns6__SearchOptions::SortOrder), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns6:StartingIndex", -1, &(a->ns6__SearchOptions::StartingIndex), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__SearchOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SearchOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SearchOptions * SOAP_FMAC4 soap_get_ns6__SearchOptions(struct soap *soap, ns6__SearchOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SearchOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__SearchOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__SearchOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SearchOptions * SOAP_FMAC4 soap_in_ns6__SearchOptions(struct soap *soap, const char *tag, ns6__SearchOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SearchOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SearchOptions, sizeof(ns6__SearchOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__SearchOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__SearchOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AutocorrectQuery1 = 1;
	size_t soap_flag_Count1 = 1;
	size_t soap_flag_Filters1 = 1;
	size_t soap_flag_ListingType1 = 1;
	size_t soap_flag_ParseOnly1 = 1;
	size_t soap_flag_SortOrder1 = 1;
	size_t soap_flag_StartingIndex1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_AutocorrectQuery1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns6:AutocorrectQuery", &(a->ns6__SearchOptions::AutocorrectQuery), "xsd:boolean"))
				{	soap_flag_AutocorrectQuery1--;
					continue;
				}
			if (soap_flag_Count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns6:Count", &(a->ns6__SearchOptions::Count), "xsd:int"))
				{	soap_flag_Count1--;
					continue;
				}
			if (soap_flag_Filters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FilterExpressionBase(soap, "ns6:Filters", &(a->ns6__SearchOptions::Filters), "ns4:FilterExpressionBase"))
				{	soap_flag_Filters1--;
					continue;
				}
			if (soap_flag_ListingType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ListingType(soap, "ns6:ListingType", &(a->ns6__SearchOptions::ListingType), "ns6:ListingType"))
				{	soap_flag_ListingType1--;
					continue;
				}
			if (soap_flag_ParseOnly1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns6:ParseOnly", &(a->ns6__SearchOptions::ParseOnly), "xsd:boolean"))
				{	soap_flag_ParseOnly1--;
					continue;
				}
			if (soap_flag_SortOrder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__SortOrder(soap, "ns6:SortOrder", &(a->ns6__SearchOptions::SortOrder), "ns6:SortOrder"))
				{	soap_flag_SortOrder1--;
					continue;
				}
			if (soap_flag_StartingIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns6:StartingIndex", &(a->ns6__SearchOptions::StartingIndex), "xsd:int"))
				{	soap_flag_StartingIndex1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__SearchOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SearchOptions, 0, sizeof(ns6__SearchOptions), 0, soap_copy_ns6__SearchOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__SearchOptions * SOAP_FMAC4 soap_instantiate_ns6__SearchOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__SearchOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__SearchOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__SearchOptions;
		if (size)
			*size = sizeof(ns6__SearchOptions);
		((ns6__SearchOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__SearchOptions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__SearchOptions);
		for (int i = 0; i < n; i++)
			((ns6__SearchOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__SearchOptions*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__SearchOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__SearchOptions %p -> %p\n", q, p));
	*(ns6__SearchOptions*)p = *(ns6__SearchOptions*)q;
}

void ns6__SearchRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns6__SearchRequest::Query);
	this->ns6__SearchRequest::SearchOptions = NULL;
	this->ns6__SearchRequest::StructuredQuery = NULL;
	this->ns4__RequestBase::Credentials = NULL;
	soap_default_string(soap, &this->ns4__RequestBase::Culture);
	this->ns4__RequestBase::ExecutionOptions = NULL;
	this->ns4__RequestBase::UserProfile = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns6__SearchRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns6__SearchRequest::Query);
	soap_serialize_PointerTons6__SearchOptions(soap, &this->ns6__SearchRequest::SearchOptions);
	soap_serialize_PointerTons6__StructuredSearchQuery(soap, &this->ns6__SearchRequest::StructuredQuery);
	soap_serialize_PointerTons4__Credentials(soap, &this->ns4__RequestBase::Credentials);
	soap_serialize_string(soap, &this->ns4__RequestBase::Culture);
	soap_serialize_PointerTons4__ExecutionOptions(soap, &this->ns4__RequestBase::ExecutionOptions);
	soap_serialize_PointerTons4__UserProfile(soap, &this->ns4__RequestBase::UserProfile);
	/* transient soap skipped */
}

int ns6__SearchRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__SearchRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__SearchRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SearchRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SearchRequest(struct soap *soap, const char *tag, int id, const ns6__SearchRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SearchRequest), "ns6:SearchRequest"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Credentials(soap, "ns4:Credentials", -1, &(a->ns4__RequestBase::Credentials), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Culture", -1, &(a->ns4__RequestBase::Culture), ""))
		return soap->error;
	if (soap_out_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", -1, &(a->ns4__RequestBase::ExecutionOptions), ""))
		return soap->error;
	if (soap_out_PointerTons4__UserProfile(soap, "ns4:UserProfile", -1, &(a->ns4__RequestBase::UserProfile), ""))
		return soap->error;
	if (soap_out_string(soap, "ns6:Query", -1, &(a->ns6__SearchRequest::Query), ""))
		return soap->error;
	if (soap_out_PointerTons6__SearchOptions(soap, "ns6:SearchOptions", -1, &(a->ns6__SearchRequest::SearchOptions), ""))
		return soap->error;
	if (soap_out_PointerTons6__StructuredSearchQuery(soap, "ns6:StructuredQuery", -1, &(a->ns6__SearchRequest::StructuredQuery), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__SearchRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SearchRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SearchRequest * SOAP_FMAC4 soap_get_ns6__SearchRequest(struct soap *soap, ns6__SearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__SearchRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__SearchRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SearchRequest * SOAP_FMAC4 soap_in_ns6__SearchRequest(struct soap *soap, const char *tag, ns6__SearchRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SearchRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SearchRequest, sizeof(ns6__SearchRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__SearchRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__SearchRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Credentials2 = 1;
	size_t soap_flag_Culture2 = 1;
	size_t soap_flag_ExecutionOptions2 = 1;
	size_t soap_flag_UserProfile2 = 1;
	size_t soap_flag_Query1 = 1;
	size_t soap_flag_SearchOptions1 = 1;
	size_t soap_flag_StructuredQuery1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Credentials2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Credentials(soap, "ns4:Credentials", &(a->ns4__RequestBase::Credentials), "ns4:Credentials"))
				{	soap_flag_Credentials2--;
					continue;
				}
			if (soap_flag_Culture2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Culture", &(a->ns4__RequestBase::Culture), "xsd:string"))
				{	soap_flag_Culture2--;
					continue;
				}
			if (soap_flag_ExecutionOptions2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", &(a->ns4__RequestBase::ExecutionOptions), "ns4:ExecutionOptions"))
				{	soap_flag_ExecutionOptions2--;
					continue;
				}
			if (soap_flag_UserProfile2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserProfile(soap, "ns4:UserProfile", &(a->ns4__RequestBase::UserProfile), "ns4:UserProfile"))
				{	soap_flag_UserProfile2--;
					continue;
				}
			if (soap_flag_Query1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Query", &(a->ns6__SearchRequest::Query), "xsd:string"))
				{	soap_flag_Query1--;
					continue;
				}
			if (soap_flag_SearchOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__SearchOptions(soap, "ns6:SearchOptions", &(a->ns6__SearchRequest::SearchOptions), "ns6:SearchOptions"))
				{	soap_flag_SearchOptions1--;
					continue;
				}
			if (soap_flag_StructuredQuery1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__StructuredSearchQuery(soap, "ns6:StructuredQuery", &(a->ns6__SearchRequest::StructuredQuery), "ns6:StructuredSearchQuery"))
				{	soap_flag_StructuredQuery1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__SearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SearchRequest, 0, sizeof(ns6__SearchRequest), 0, soap_copy_ns6__SearchRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__SearchRequest * SOAP_FMAC4 soap_instantiate_ns6__SearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__SearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__SearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__SearchRequest;
		if (size)
			*size = sizeof(ns6__SearchRequest);
		((ns6__SearchRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__SearchRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__SearchRequest);
		for (int i = 0; i < n; i++)
			((ns6__SearchRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__SearchRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__SearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__SearchRequest %p -> %p\n", q, p));
	*(ns6__SearchRequest*)p = *(ns6__SearchRequest*)q;
}

void ns4__Pushpin::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns4__Pushpin::IconStyle);
	soap_default_string(soap, &this->ns4__Pushpin::Label);
	this->ns4__Pushpin::Location = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__Pushpin::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns4__Pushpin::IconStyle);
	soap_serialize_string(soap, &this->ns4__Pushpin::Label);
	soap_serialize_PointerTons4__Location(soap, &this->ns4__Pushpin::Location);
	/* transient soap skipped */
}

int ns4__Pushpin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Pushpin);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__Pushpin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Pushpin(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Pushpin(struct soap *soap, const char *tag, int id, const ns4__Pushpin *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Pushpin), "ns4:Pushpin"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns4:IconStyle", -1, &(a->ns4__Pushpin::IconStyle), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Label", -1, &(a->ns4__Pushpin::Label), ""))
		return soap->error;
	if (soap_out_PointerTons4__Location(soap, "ns4:Location", -1, &(a->ns4__Pushpin::Location), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__Pushpin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Pushpin(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Pushpin * SOAP_FMAC4 soap_get_ns4__Pushpin(struct soap *soap, ns4__Pushpin *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Pushpin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__Pushpin::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Pushpin(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Pushpin * SOAP_FMAC4 soap_in_ns4__Pushpin(struct soap *soap, const char *tag, ns4__Pushpin *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Pushpin *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Pushpin, sizeof(ns4__Pushpin), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Pushpin)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Pushpin *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_IconStyle1 = 1;
	size_t soap_flag_Label1 = 1;
	size_t soap_flag_Location1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_IconStyle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:IconStyle", &(a->ns4__Pushpin::IconStyle), "xsd:string"))
				{	soap_flag_IconStyle1--;
					continue;
				}
			if (soap_flag_Label1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Label", &(a->ns4__Pushpin::Label), "xsd:string"))
				{	soap_flag_Label1--;
					continue;
				}
			if (soap_flag_Location1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Location(soap, "ns4:Location", &(a->ns4__Pushpin::Location), "ns4:Location"))
				{	soap_flag_Location1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Pushpin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Pushpin, 0, sizeof(ns4__Pushpin), 0, soap_copy_ns4__Pushpin);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__Pushpin * SOAP_FMAC4 soap_instantiate_ns4__Pushpin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Pushpin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Pushpin, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__Pushpin;
		if (size)
			*size = sizeof(ns4__Pushpin);
		((ns4__Pushpin*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__Pushpin[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__Pushpin);
		for (int i = 0; i < n; i++)
			((ns4__Pushpin*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__Pushpin*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Pushpin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Pushpin %p -> %p\n", q, p));
	*(ns4__Pushpin*)p = *(ns4__Pushpin*)q;
}

void ns4__ArrayOfPushpin::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__ArrayOfPushpin::__sizePushpin = 0;
	this->ns4__ArrayOfPushpin::Pushpin = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__ArrayOfPushpin::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns4__ArrayOfPushpin::Pushpin)
	{	int i;
		for (i = 0; i < this->ns4__ArrayOfPushpin::__sizePushpin; i++)
		{
			soap_serialize_PointerTons4__Pushpin(soap, this->ns4__ArrayOfPushpin::Pushpin + i);
		}
	}
	/* transient soap skipped */
}

int ns4__ArrayOfPushpin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfPushpin);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfPushpin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfPushpin(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfPushpin(struct soap *soap, const char *tag, int id, const ns4__ArrayOfPushpin *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfPushpin), "ns4:ArrayOfPushpin"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns4__ArrayOfPushpin::Pushpin)
	{	int i;
		for (i = 0; i < a->ns4__ArrayOfPushpin::__sizePushpin; i++)
			if (soap_out_PointerTons4__Pushpin(soap, "ns4:Pushpin", -1, a->ns4__ArrayOfPushpin::Pushpin + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns4__ArrayOfPushpin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfPushpin(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfPushpin * SOAP_FMAC4 soap_get_ns4__ArrayOfPushpin(struct soap *soap, ns4__ArrayOfPushpin *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfPushpin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__ArrayOfPushpin::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfPushpin(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfPushpin * SOAP_FMAC4 soap_in_ns4__ArrayOfPushpin(struct soap *soap, const char *tag, ns4__ArrayOfPushpin *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfPushpin *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfPushpin, sizeof(ns4__ArrayOfPushpin), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfPushpin)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfPushpin *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_Pushpin1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:Pushpin", 1, NULL))
			{	if (a->ns4__ArrayOfPushpin::Pushpin == NULL)
				{	if (soap_blist_Pushpin1 == NULL)
						soap_blist_Pushpin1 = soap_new_block(soap);
					a->ns4__ArrayOfPushpin::Pushpin = (ns4__Pushpin **)soap_push_block(soap, soap_blist_Pushpin1, sizeof(ns4__Pushpin *));
					if (a->ns4__ArrayOfPushpin::Pushpin == NULL)
						return NULL;
					*a->ns4__ArrayOfPushpin::Pushpin = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons4__Pushpin(soap, "ns4:Pushpin", a->ns4__ArrayOfPushpin::Pushpin, "ns4:Pushpin"))
				{	a->ns4__ArrayOfPushpin::__sizePushpin++;
					a->ns4__ArrayOfPushpin::Pushpin = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns4__ArrayOfPushpin::Pushpin)
			soap_pop_block(soap, soap_blist_Pushpin1);
		if (a->ns4__ArrayOfPushpin::__sizePushpin)
			a->ns4__ArrayOfPushpin::Pushpin = (ns4__Pushpin **)soap_save_block(soap, soap_blist_Pushpin1, NULL, 1);
		else
		{	a->ns4__ArrayOfPushpin::Pushpin = NULL;
			if (soap_blist_Pushpin1)
				soap_end_block(soap, soap_blist_Pushpin1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfPushpin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfPushpin, 0, sizeof(ns4__ArrayOfPushpin), 0, soap_copy_ns4__ArrayOfPushpin);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__ArrayOfPushpin * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfPushpin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfPushpin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfPushpin, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfPushpin;
		if (size)
			*size = sizeof(ns4__ArrayOfPushpin);
		((ns4__ArrayOfPushpin*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfPushpin[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__ArrayOfPushpin);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfPushpin*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfPushpin*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfPushpin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfPushpin %p -> %p\n", q, p));
	*(ns4__ArrayOfPushpin*)p = *(ns4__ArrayOfPushpin*)q;
}

void ns4__RangeOfdateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__RangeOfdateTime::From = NULL;
	this->ns4__RangeOfdateTime::To = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__RangeOfdateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns4__RangeOfdateTime::From);
	soap_serialize_PointerTotime(soap, &this->ns4__RangeOfdateTime::To);
	/* transient soap skipped */
}

int ns4__RangeOfdateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__RangeOfdateTime);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__RangeOfdateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RangeOfdateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RangeOfdateTime(struct soap *soap, const char *tag, int id, const ns4__RangeOfdateTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__RangeOfdateTime), "ns4:RangeOfdateTime"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "ns4:From", -1, &(a->ns4__RangeOfdateTime::From), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns4:To", -1, &(a->ns4__RangeOfdateTime::To), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__RangeOfdateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RangeOfdateTime(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RangeOfdateTime * SOAP_FMAC4 soap_get_ns4__RangeOfdateTime(struct soap *soap, ns4__RangeOfdateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RangeOfdateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__RangeOfdateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RangeOfdateTime(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RangeOfdateTime * SOAP_FMAC4 soap_in_ns4__RangeOfdateTime(struct soap *soap, const char *tag, ns4__RangeOfdateTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RangeOfdateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__RangeOfdateTime, sizeof(ns4__RangeOfdateTime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__RangeOfdateTime)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RangeOfdateTime *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_From1 = 1;
	size_t soap_flag_To1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_From1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns4:From", &(a->ns4__RangeOfdateTime::From), "xsd:dateTime"))
				{	soap_flag_From1--;
					continue;
				}
			if (soap_flag_To1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns4:To", &(a->ns4__RangeOfdateTime::To), "xsd:dateTime"))
				{	soap_flag_To1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RangeOfdateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__RangeOfdateTime, 0, sizeof(ns4__RangeOfdateTime), 0, soap_copy_ns4__RangeOfdateTime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__RangeOfdateTime * SOAP_FMAC4 soap_instantiate_ns4__RangeOfdateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RangeOfdateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__RangeOfdateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__RangeOfdateTime;
		if (size)
			*size = sizeof(ns4__RangeOfdateTime);
		((ns4__RangeOfdateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__RangeOfdateTime[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__RangeOfdateTime);
		for (int i = 0; i < n; i++)
			((ns4__RangeOfdateTime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__RangeOfdateTime*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RangeOfdateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RangeOfdateTime %p -> %p\n", q, p));
	*(ns4__RangeOfdateTime*)p = *(ns4__RangeOfdateTime*)q;
}

void ns4__RangeOfint::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__RangeOfint::From = NULL;
	this->ns4__RangeOfint::To = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__RangeOfint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns4__RangeOfint::From);
	soap_serialize_PointerToint(soap, &this->ns4__RangeOfint::To);
	/* transient soap skipped */
}

int ns4__RangeOfint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__RangeOfint);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__RangeOfint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RangeOfint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RangeOfint(struct soap *soap, const char *tag, int id, const ns4__RangeOfint *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__RangeOfint), "ns4:RangeOfint"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToint(soap, "ns4:From", -1, &(a->ns4__RangeOfint::From), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:To", -1, &(a->ns4__RangeOfint::To), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__RangeOfint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RangeOfint(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RangeOfint * SOAP_FMAC4 soap_get_ns4__RangeOfint(struct soap *soap, ns4__RangeOfint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RangeOfint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__RangeOfint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RangeOfint(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RangeOfint * SOAP_FMAC4 soap_in_ns4__RangeOfint(struct soap *soap, const char *tag, ns4__RangeOfint *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RangeOfint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__RangeOfint, sizeof(ns4__RangeOfint), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__RangeOfint)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RangeOfint *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_From1 = 1;
	size_t soap_flag_To1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_From1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:From", &(a->ns4__RangeOfint::From), "xsd:int"))
				{	soap_flag_From1--;
					continue;
				}
			if (soap_flag_To1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:To", &(a->ns4__RangeOfint::To), "xsd:int"))
				{	soap_flag_To1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RangeOfint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__RangeOfint, 0, sizeof(ns4__RangeOfint), 0, soap_copy_ns4__RangeOfint);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__RangeOfint * SOAP_FMAC4 soap_instantiate_ns4__RangeOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RangeOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__RangeOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__RangeOfint;
		if (size)
			*size = sizeof(ns4__RangeOfint);
		((ns4__RangeOfint*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__RangeOfint[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__RangeOfint);
		for (int i = 0; i < n; i++)
			((ns4__RangeOfint*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__RangeOfint*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RangeOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RangeOfint %p -> %p\n", q, p));
	*(ns4__RangeOfint*)p = *(ns4__RangeOfint*)q;
}

void ns4__ArrayOfGeocodeResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__ArrayOfGeocodeResult::__sizeGeocodeResult = 0;
	this->ns4__ArrayOfGeocodeResult::GeocodeResult = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__ArrayOfGeocodeResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns4__ArrayOfGeocodeResult::GeocodeResult)
	{	int i;
		for (i = 0; i < this->ns4__ArrayOfGeocodeResult::__sizeGeocodeResult; i++)
		{
			soap_serialize_PointerTons4__GeocodeResult(soap, this->ns4__ArrayOfGeocodeResult::GeocodeResult + i);
		}
	}
	/* transient soap skipped */
}

int ns4__ArrayOfGeocodeResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfGeocodeResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfGeocodeResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfGeocodeResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfGeocodeResult(struct soap *soap, const char *tag, int id, const ns4__ArrayOfGeocodeResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfGeocodeResult), "ns4:ArrayOfGeocodeResult"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns4__ArrayOfGeocodeResult::GeocodeResult)
	{	int i;
		for (i = 0; i < a->ns4__ArrayOfGeocodeResult::__sizeGeocodeResult; i++)
			if (soap_out_PointerTons4__GeocodeResult(soap, "ns4:GeocodeResult", -1, a->ns4__ArrayOfGeocodeResult::GeocodeResult + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns4__ArrayOfGeocodeResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfGeocodeResult(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfGeocodeResult * SOAP_FMAC4 soap_get_ns4__ArrayOfGeocodeResult(struct soap *soap, ns4__ArrayOfGeocodeResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfGeocodeResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__ArrayOfGeocodeResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfGeocodeResult(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfGeocodeResult * SOAP_FMAC4 soap_in_ns4__ArrayOfGeocodeResult(struct soap *soap, const char *tag, ns4__ArrayOfGeocodeResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfGeocodeResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfGeocodeResult, sizeof(ns4__ArrayOfGeocodeResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfGeocodeResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfGeocodeResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_GeocodeResult1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:GeocodeResult", 1, NULL))
			{	if (a->ns4__ArrayOfGeocodeResult::GeocodeResult == NULL)
				{	if (soap_blist_GeocodeResult1 == NULL)
						soap_blist_GeocodeResult1 = soap_new_block(soap);
					a->ns4__ArrayOfGeocodeResult::GeocodeResult = (ns4__GeocodeResult **)soap_push_block(soap, soap_blist_GeocodeResult1, sizeof(ns4__GeocodeResult *));
					if (a->ns4__ArrayOfGeocodeResult::GeocodeResult == NULL)
						return NULL;
					*a->ns4__ArrayOfGeocodeResult::GeocodeResult = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons4__GeocodeResult(soap, "ns4:GeocodeResult", a->ns4__ArrayOfGeocodeResult::GeocodeResult, "ns4:GeocodeResult"))
				{	a->ns4__ArrayOfGeocodeResult::__sizeGeocodeResult++;
					a->ns4__ArrayOfGeocodeResult::GeocodeResult = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns4__ArrayOfGeocodeResult::GeocodeResult)
			soap_pop_block(soap, soap_blist_GeocodeResult1);
		if (a->ns4__ArrayOfGeocodeResult::__sizeGeocodeResult)
			a->ns4__ArrayOfGeocodeResult::GeocodeResult = (ns4__GeocodeResult **)soap_save_block(soap, soap_blist_GeocodeResult1, NULL, 1);
		else
		{	a->ns4__ArrayOfGeocodeResult::GeocodeResult = NULL;
			if (soap_blist_GeocodeResult1)
				soap_end_block(soap, soap_blist_GeocodeResult1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfGeocodeResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfGeocodeResult, 0, sizeof(ns4__ArrayOfGeocodeResult), 0, soap_copy_ns4__ArrayOfGeocodeResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__ArrayOfGeocodeResult * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfGeocodeResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfGeocodeResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfGeocodeResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfGeocodeResult;
		if (size)
			*size = sizeof(ns4__ArrayOfGeocodeResult);
		((ns4__ArrayOfGeocodeResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfGeocodeResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__ArrayOfGeocodeResult);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfGeocodeResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfGeocodeResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfGeocodeResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfGeocodeResult %p -> %p\n", q, p));
	*(ns4__ArrayOfGeocodeResult*)p = *(ns4__ArrayOfGeocodeResult*)q;
}

void ns4__ArrayOfGeocodeLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__ArrayOfGeocodeLocation::__sizeGeocodeLocation = 0;
	this->ns4__ArrayOfGeocodeLocation::GeocodeLocation = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__ArrayOfGeocodeLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns4__ArrayOfGeocodeLocation::GeocodeLocation)
	{	int i;
		for (i = 0; i < this->ns4__ArrayOfGeocodeLocation::__sizeGeocodeLocation; i++)
		{
			soap_serialize_PointerTons4__GeocodeLocation(soap, this->ns4__ArrayOfGeocodeLocation::GeocodeLocation + i);
		}
	}
	/* transient soap skipped */
}

int ns4__ArrayOfGeocodeLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfGeocodeLocation);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfGeocodeLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfGeocodeLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfGeocodeLocation(struct soap *soap, const char *tag, int id, const ns4__ArrayOfGeocodeLocation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfGeocodeLocation), "ns4:ArrayOfGeocodeLocation"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns4__ArrayOfGeocodeLocation::GeocodeLocation)
	{	int i;
		for (i = 0; i < a->ns4__ArrayOfGeocodeLocation::__sizeGeocodeLocation; i++)
			if (soap_out_PointerTons4__GeocodeLocation(soap, "ns4:GeocodeLocation", -1, a->ns4__ArrayOfGeocodeLocation::GeocodeLocation + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns4__ArrayOfGeocodeLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfGeocodeLocation(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfGeocodeLocation * SOAP_FMAC4 soap_get_ns4__ArrayOfGeocodeLocation(struct soap *soap, ns4__ArrayOfGeocodeLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfGeocodeLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__ArrayOfGeocodeLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfGeocodeLocation(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfGeocodeLocation * SOAP_FMAC4 soap_in_ns4__ArrayOfGeocodeLocation(struct soap *soap, const char *tag, ns4__ArrayOfGeocodeLocation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfGeocodeLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfGeocodeLocation, sizeof(ns4__ArrayOfGeocodeLocation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfGeocodeLocation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfGeocodeLocation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_GeocodeLocation1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:GeocodeLocation", 1, NULL))
			{	if (a->ns4__ArrayOfGeocodeLocation::GeocodeLocation == NULL)
				{	if (soap_blist_GeocodeLocation1 == NULL)
						soap_blist_GeocodeLocation1 = soap_new_block(soap);
					a->ns4__ArrayOfGeocodeLocation::GeocodeLocation = (ns4__GeocodeLocation **)soap_push_block(soap, soap_blist_GeocodeLocation1, sizeof(ns4__GeocodeLocation *));
					if (a->ns4__ArrayOfGeocodeLocation::GeocodeLocation == NULL)
						return NULL;
					*a->ns4__ArrayOfGeocodeLocation::GeocodeLocation = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons4__GeocodeLocation(soap, "ns4:GeocodeLocation", a->ns4__ArrayOfGeocodeLocation::GeocodeLocation, "ns4:GeocodeLocation"))
				{	a->ns4__ArrayOfGeocodeLocation::__sizeGeocodeLocation++;
					a->ns4__ArrayOfGeocodeLocation::GeocodeLocation = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns4__ArrayOfGeocodeLocation::GeocodeLocation)
			soap_pop_block(soap, soap_blist_GeocodeLocation1);
		if (a->ns4__ArrayOfGeocodeLocation::__sizeGeocodeLocation)
			a->ns4__ArrayOfGeocodeLocation::GeocodeLocation = (ns4__GeocodeLocation **)soap_save_block(soap, soap_blist_GeocodeLocation1, NULL, 1);
		else
		{	a->ns4__ArrayOfGeocodeLocation::GeocodeLocation = NULL;
			if (soap_blist_GeocodeLocation1)
				soap_end_block(soap, soap_blist_GeocodeLocation1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfGeocodeLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfGeocodeLocation, 0, sizeof(ns4__ArrayOfGeocodeLocation), 0, soap_copy_ns4__ArrayOfGeocodeLocation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__ArrayOfGeocodeLocation * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfGeocodeLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfGeocodeLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfGeocodeLocation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfGeocodeLocation;
		if (size)
			*size = sizeof(ns4__ArrayOfGeocodeLocation);
		((ns4__ArrayOfGeocodeLocation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfGeocodeLocation[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__ArrayOfGeocodeLocation);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfGeocodeLocation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfGeocodeLocation*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfGeocodeLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfGeocodeLocation %p -> %p\n", q, p));
	*(ns4__ArrayOfGeocodeLocation*)p = *(ns4__ArrayOfGeocodeLocation*)q;
}

void ns4__Address::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns4__Address::AddressLine);
	soap_default_string(soap, &this->ns4__Address::AdminDistrict);
	soap_default_string(soap, &this->ns4__Address::CountryRegion);
	soap_default_string(soap, &this->ns4__Address::District);
	soap_default_string(soap, &this->ns4__Address::FormattedAddress);
	soap_default_string(soap, &this->ns4__Address::Locality);
	soap_default_string(soap, &this->ns4__Address::PostalCode);
	soap_default_string(soap, &this->ns4__Address::PostalTown);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__Address::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns4__Address::AddressLine);
	soap_serialize_string(soap, &this->ns4__Address::AdminDistrict);
	soap_serialize_string(soap, &this->ns4__Address::CountryRegion);
	soap_serialize_string(soap, &this->ns4__Address::District);
	soap_serialize_string(soap, &this->ns4__Address::FormattedAddress);
	soap_serialize_string(soap, &this->ns4__Address::Locality);
	soap_serialize_string(soap, &this->ns4__Address::PostalCode);
	soap_serialize_string(soap, &this->ns4__Address::PostalTown);
	/* transient soap skipped */
}

int ns4__Address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Address);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__Address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Address(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Address(struct soap *soap, const char *tag, int id, const ns4__Address *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Address), "ns4:Address"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns4:AddressLine", -1, &(a->ns4__Address::AddressLine), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:AdminDistrict", -1, &(a->ns4__Address::AdminDistrict), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CountryRegion", -1, &(a->ns4__Address::CountryRegion), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:District", -1, &(a->ns4__Address::District), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:FormattedAddress", -1, &(a->ns4__Address::FormattedAddress), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Locality", -1, &(a->ns4__Address::Locality), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PostalCode", -1, &(a->ns4__Address::PostalCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PostalTown", -1, &(a->ns4__Address::PostalTown), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__Address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Address(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Address * SOAP_FMAC4 soap_get_ns4__Address(struct soap *soap, ns4__Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__Address::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Address(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Address * SOAP_FMAC4 soap_in_ns4__Address(struct soap *soap, const char *tag, ns4__Address *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Address *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Address, sizeof(ns4__Address), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Address)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Address *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AddressLine1 = 1;
	size_t soap_flag_AdminDistrict1 = 1;
	size_t soap_flag_CountryRegion1 = 1;
	size_t soap_flag_District1 = 1;
	size_t soap_flag_FormattedAddress1 = 1;
	size_t soap_flag_Locality1 = 1;
	size_t soap_flag_PostalCode1 = 1;
	size_t soap_flag_PostalTown1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_AddressLine1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AddressLine", &(a->ns4__Address::AddressLine), "xsd:string"))
				{	soap_flag_AddressLine1--;
					continue;
				}
			if (soap_flag_AdminDistrict1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AdminDistrict", &(a->ns4__Address::AdminDistrict), "xsd:string"))
				{	soap_flag_AdminDistrict1--;
					continue;
				}
			if (soap_flag_CountryRegion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CountryRegion", &(a->ns4__Address::CountryRegion), "xsd:string"))
				{	soap_flag_CountryRegion1--;
					continue;
				}
			if (soap_flag_District1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:District", &(a->ns4__Address::District), "xsd:string"))
				{	soap_flag_District1--;
					continue;
				}
			if (soap_flag_FormattedAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:FormattedAddress", &(a->ns4__Address::FormattedAddress), "xsd:string"))
				{	soap_flag_FormattedAddress1--;
					continue;
				}
			if (soap_flag_Locality1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Locality", &(a->ns4__Address::Locality), "xsd:string"))
				{	soap_flag_Locality1--;
					continue;
				}
			if (soap_flag_PostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PostalCode", &(a->ns4__Address::PostalCode), "xsd:string"))
				{	soap_flag_PostalCode1--;
					continue;
				}
			if (soap_flag_PostalTown1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PostalTown", &(a->ns4__Address::PostalTown), "xsd:string"))
				{	soap_flag_PostalTown1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Address, 0, sizeof(ns4__Address), 0, soap_copy_ns4__Address);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__Address * SOAP_FMAC4 soap_instantiate_ns4__Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Address(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Address, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__Address;
		if (size)
			*size = sizeof(ns4__Address);
		((ns4__Address*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__Address[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__Address);
		for (int i = 0; i < n; i++)
			((ns4__Address*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__Address*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Address(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Address %p -> %p\n", q, p));
	*(ns4__Address*)p = *(ns4__Address*)q;
}

void ns4__GeocodeResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__GeocodeResult::Address = NULL;
	this->ns4__GeocodeResult::BestView = NULL;
	this->ns4__GeocodeResult::Confidence = NULL;
	soap_default_string(soap, &this->ns4__GeocodeResult::DisplayName);
	soap_default_string(soap, &this->ns4__GeocodeResult::EntityType);
	this->ns4__GeocodeResult::Locations = NULL;
	this->ns4__GeocodeResult::MatchCodes = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__GeocodeResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Address(soap, &this->ns4__GeocodeResult::Address);
	soap_serialize_PointerTons4__Rectangle(soap, &this->ns4__GeocodeResult::BestView);
	soap_serialize_PointerTons4__Confidence(soap, &this->ns4__GeocodeResult::Confidence);
	soap_serialize_string(soap, &this->ns4__GeocodeResult::DisplayName);
	soap_serialize_string(soap, &this->ns4__GeocodeResult::EntityType);
	soap_serialize_PointerTons4__ArrayOfGeocodeLocation(soap, &this->ns4__GeocodeResult::Locations);
	soap_serialize_PointerTons7__ArrayOfstring(soap, &this->ns4__GeocodeResult::MatchCodes);
	/* transient soap skipped */
}

int ns4__GeocodeResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__GeocodeResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__GeocodeResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__GeocodeResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GeocodeResult(struct soap *soap, const char *tag, int id, const ns4__GeocodeResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GeocodeResult), "ns4:GeocodeResult"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Address(soap, "ns4:Address", -1, &(a->ns4__GeocodeResult::Address), ""))
		return soap->error;
	if (soap_out_PointerTons4__Rectangle(soap, "ns4:BestView", -1, &(a->ns4__GeocodeResult::BestView), ""))
		return soap->error;
	if (soap_out_PointerTons4__Confidence(soap, "ns4:Confidence", -1, &(a->ns4__GeocodeResult::Confidence), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:DisplayName", -1, &(a->ns4__GeocodeResult::DisplayName), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:EntityType", -1, &(a->ns4__GeocodeResult::EntityType), ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfGeocodeLocation(soap, "ns4:Locations", -1, &(a->ns4__GeocodeResult::Locations), ""))
		return soap->error;
	if (soap_out_PointerTons7__ArrayOfstring(soap, "ns4:MatchCodes", -1, &(a->ns4__GeocodeResult::MatchCodes), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__GeocodeResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__GeocodeResult(soap, this, tag, type);
}

SOAP_FMAC3 ns4__GeocodeResult * SOAP_FMAC4 soap_get_ns4__GeocodeResult(struct soap *soap, ns4__GeocodeResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GeocodeResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__GeocodeResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__GeocodeResult(soap, tag, this, type);
}

SOAP_FMAC3 ns4__GeocodeResult * SOAP_FMAC4 soap_in_ns4__GeocodeResult(struct soap *soap, const char *tag, ns4__GeocodeResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__GeocodeResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GeocodeResult, sizeof(ns4__GeocodeResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__GeocodeResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__GeocodeResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_BestView1 = 1;
	size_t soap_flag_Confidence1 = 1;
	size_t soap_flag_DisplayName1 = 1;
	size_t soap_flag_EntityType1 = 1;
	size_t soap_flag_Locations1 = 1;
	size_t soap_flag_MatchCodes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Address1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Address(soap, "ns4:Address", &(a->ns4__GeocodeResult::Address), "ns4:Address"))
				{	soap_flag_Address1--;
					continue;
				}
			if (soap_flag_BestView1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Rectangle(soap, "ns4:BestView", &(a->ns4__GeocodeResult::BestView), "ns4:Rectangle"))
				{	soap_flag_BestView1--;
					continue;
				}
			if (soap_flag_Confidence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Confidence(soap, "ns4:Confidence", &(a->ns4__GeocodeResult::Confidence), "ns4:Confidence"))
				{	soap_flag_Confidence1--;
					continue;
				}
			if (soap_flag_DisplayName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:DisplayName", &(a->ns4__GeocodeResult::DisplayName), "xsd:string"))
				{	soap_flag_DisplayName1--;
					continue;
				}
			if (soap_flag_EntityType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:EntityType", &(a->ns4__GeocodeResult::EntityType), "xsd:string"))
				{	soap_flag_EntityType1--;
					continue;
				}
			if (soap_flag_Locations1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfGeocodeLocation(soap, "ns4:Locations", &(a->ns4__GeocodeResult::Locations), "ns4:ArrayOfGeocodeLocation"))
				{	soap_flag_Locations1--;
					continue;
				}
			if (soap_flag_MatchCodes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ArrayOfstring(soap, "ns4:MatchCodes", &(a->ns4__GeocodeResult::MatchCodes), "ns7:ArrayOfstring"))
				{	soap_flag_MatchCodes1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__GeocodeResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GeocodeResult, 0, sizeof(ns4__GeocodeResult), 0, soap_copy_ns4__GeocodeResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__GeocodeResult * SOAP_FMAC4 soap_instantiate_ns4__GeocodeResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GeocodeResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__GeocodeResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__GeocodeResult;
		if (size)
			*size = sizeof(ns4__GeocodeResult);
		((ns4__GeocodeResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__GeocodeResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__GeocodeResult);
		for (int i = 0; i < n; i++)
			((ns4__GeocodeResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__GeocodeResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__GeocodeResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__GeocodeResult %p -> %p\n", q, p));
	*(ns4__GeocodeResult*)p = *(ns4__GeocodeResult*)q;
}

void ns4__ResponseSummary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__ResponseSummary::AuthenticationResultCode = NULL;
	soap_default_string(soap, &this->ns4__ResponseSummary::Copyright);
	soap_default_string(soap, &this->ns4__ResponseSummary::FaultReason);
	this->ns4__ResponseSummary::StatusCode = NULL;
	soap_default_string(soap, &this->ns4__ResponseSummary::TraceId);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__ResponseSummary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__AuthenticationResultCode(soap, &this->ns4__ResponseSummary::AuthenticationResultCode);
	soap_serialize_string(soap, &this->ns4__ResponseSummary::Copyright);
	soap_serialize_string(soap, &this->ns4__ResponseSummary::FaultReason);
	soap_serialize_PointerTons4__ResponseStatusCode(soap, &this->ns4__ResponseSummary::StatusCode);
	soap_serialize_string(soap, &this->ns4__ResponseSummary::TraceId);
	/* transient soap skipped */
}

int ns4__ResponseSummary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ResponseSummary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ResponseSummary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ResponseSummary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ResponseSummary(struct soap *soap, const char *tag, int id, const ns4__ResponseSummary *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ResponseSummary), "ns4:ResponseSummary"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__AuthenticationResultCode(soap, "ns4:AuthenticationResultCode", -1, &(a->ns4__ResponseSummary::AuthenticationResultCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Copyright", -1, &(a->ns4__ResponseSummary::Copyright), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:FaultReason", -1, &(a->ns4__ResponseSummary::FaultReason), ""))
		return soap->error;
	if (soap_out_PointerTons4__ResponseStatusCode(soap, "ns4:StatusCode", -1, &(a->ns4__ResponseSummary::StatusCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:TraceId", -1, &(a->ns4__ResponseSummary::TraceId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__ResponseSummary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ResponseSummary(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ResponseSummary * SOAP_FMAC4 soap_get_ns4__ResponseSummary(struct soap *soap, ns4__ResponseSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ResponseSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__ResponseSummary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ResponseSummary(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ResponseSummary * SOAP_FMAC4 soap_in_ns4__ResponseSummary(struct soap *soap, const char *tag, ns4__ResponseSummary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ResponseSummary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ResponseSummary, sizeof(ns4__ResponseSummary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ResponseSummary)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ResponseSummary *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AuthenticationResultCode1 = 1;
	size_t soap_flag_Copyright1 = 1;
	size_t soap_flag_FaultReason1 = 1;
	size_t soap_flag_StatusCode1 = 1;
	size_t soap_flag_TraceId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_AuthenticationResultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__AuthenticationResultCode(soap, "ns4:AuthenticationResultCode", &(a->ns4__ResponseSummary::AuthenticationResultCode), "ns4:AuthenticationResultCode"))
				{	soap_flag_AuthenticationResultCode1--;
					continue;
				}
			if (soap_flag_Copyright1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Copyright", &(a->ns4__ResponseSummary::Copyright), "xsd:string"))
				{	soap_flag_Copyright1--;
					continue;
				}
			if (soap_flag_FaultReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:FaultReason", &(a->ns4__ResponseSummary::FaultReason), "xsd:string"))
				{	soap_flag_FaultReason1--;
					continue;
				}
			if (soap_flag_StatusCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ResponseStatusCode(soap, "ns4:StatusCode", &(a->ns4__ResponseSummary::StatusCode), "ns4:ResponseStatusCode"))
				{	soap_flag_StatusCode1--;
					continue;
				}
			if (soap_flag_TraceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TraceId", &(a->ns4__ResponseSummary::TraceId), "xsd:string"))
				{	soap_flag_TraceId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ResponseSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ResponseSummary, 0, sizeof(ns4__ResponseSummary), 0, soap_copy_ns4__ResponseSummary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__ResponseSummary * SOAP_FMAC4 soap_instantiate_ns4__ResponseSummary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ResponseSummary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ResponseSummary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ResponseSummary;
		if (size)
			*size = sizeof(ns4__ResponseSummary);
		((ns4__ResponseSummary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ResponseSummary[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__ResponseSummary);
		for (int i = 0; i < n; i++)
			((ns4__ResponseSummary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ResponseSummary*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ResponseSummary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ResponseSummary %p -> %p\n", q, p));
	*(ns4__ResponseSummary*)p = *(ns4__ResponseSummary*)q;
}

void ns4__ResponseBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__ResponseBase::ResponseSummary = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__ResponseBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ResponseSummary(soap, &this->ns4__ResponseBase::ResponseSummary);
	/* transient soap skipped */
}

int ns4__ResponseBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ResponseBase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ResponseBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ResponseBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ResponseBase(struct soap *soap, const char *tag, int id, const ns4__ResponseBase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ResponseBase), "ns4:ResponseBase"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__ResponseSummary(soap, "ns4:ResponseSummary", -1, &(a->ns4__ResponseBase::ResponseSummary), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__ResponseBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ResponseBase(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ResponseBase * SOAP_FMAC4 soap_get_ns4__ResponseBase(struct soap *soap, ns4__ResponseBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ResponseBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__ResponseBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ResponseBase(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ResponseBase * SOAP_FMAC4 soap_in_ns4__ResponseBase(struct soap *soap, const char *tag, ns4__ResponseBase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ResponseBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ResponseBase, sizeof(ns4__ResponseBase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ResponseBase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ResponseBase *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ResponseSummary1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ResponseSummary1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ResponseSummary(soap, "ns4:ResponseSummary", &(a->ns4__ResponseBase::ResponseSummary), "ns4:ResponseSummary"))
				{	soap_flag_ResponseSummary1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ResponseBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ResponseBase, 0, sizeof(ns4__ResponseBase), 0, soap_copy_ns4__ResponseBase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__ResponseBase * SOAP_FMAC4 soap_instantiate_ns4__ResponseBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ResponseBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ResponseBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns6:SearchResponse"))
	{	cp->type = SOAP_TYPE_ns6__SearchResponse;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__SearchResponse;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__SearchResponse);
			((ns6__SearchResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__SearchResponse[n];
			if (size)
				*size = n * sizeof(ns6__SearchResponse);
			for (int i = 0; i < n; i++)
				((ns6__SearchResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__SearchResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns10:GeocodeResponse"))
	{	cp->type = SOAP_TYPE_ns10__GeocodeResponse;
		if (n < 0)
		{	cp->ptr = (void*)new ns10__GeocodeResponse;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns10__GeocodeResponse);
			((ns10__GeocodeResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns10__GeocodeResponse[n];
			if (size)
				*size = n * sizeof(ns10__GeocodeResponse);
			for (int i = 0; i < n; i++)
				((ns10__GeocodeResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns10__GeocodeResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:ImageryMetadataResponse"))
	{	cp->type = SOAP_TYPE_ns13__ImageryMetadataResponse;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__ImageryMetadataResponse;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__ImageryMetadataResponse);
			((ns13__ImageryMetadataResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__ImageryMetadataResponse[n];
			if (size)
				*size = n * sizeof(ns13__ImageryMetadataResponse);
			for (int i = 0; i < n; i++)
				((ns13__ImageryMetadataResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__ImageryMetadataResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:MapUriResponse"))
	{	cp->type = SOAP_TYPE_ns13__MapUriResponse;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__MapUriResponse;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__MapUriResponse);
			((ns13__MapUriResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__MapUriResponse[n];
			if (size)
				*size = n * sizeof(ns13__MapUriResponse);
			for (int i = 0; i < n; i++)
				((ns13__MapUriResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__MapUriResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:RouteResponse"))
	{	cp->type = SOAP_TYPE_ns16__RouteResponse;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__RouteResponse;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__RouteResponse);
			((ns16__RouteResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__RouteResponse[n];
			if (size)
				*size = n * sizeof(ns16__RouteResponse);
			for (int i = 0; i < n; i++)
				((ns16__RouteResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__RouteResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:MajorRoutesResponse"))
	{	cp->type = SOAP_TYPE_ns16__MajorRoutesResponse;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__MajorRoutesResponse;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__MajorRoutesResponse);
			((ns16__MajorRoutesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__MajorRoutesResponse[n];
			if (size)
				*size = n * sizeof(ns16__MajorRoutesResponse);
			for (int i = 0; i < n; i++)
				((ns16__MajorRoutesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__MajorRoutesResponse*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ResponseBase;
		if (size)
			*size = sizeof(ns4__ResponseBase);
		((ns4__ResponseBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ResponseBase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__ResponseBase);
		for (int i = 0; i < n; i++)
			((ns4__ResponseBase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ResponseBase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ResponseBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ResponseBase %p -> %p\n", q, p));
	*(ns4__ResponseBase*)p = *(ns4__ResponseBase*)q;
}

void ns4__ArrayOfFilterExpressionBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__ArrayOfFilterExpressionBase::__sizeFilterExpressionBase = 0;
	this->ns4__ArrayOfFilterExpressionBase::FilterExpressionBase = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__ArrayOfFilterExpressionBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns4__ArrayOfFilterExpressionBase::FilterExpressionBase)
	{	int i;
		for (i = 0; i < this->ns4__ArrayOfFilterExpressionBase::__sizeFilterExpressionBase; i++)
		{
			soap_serialize_PointerTons4__FilterExpressionBase(soap, this->ns4__ArrayOfFilterExpressionBase::FilterExpressionBase + i);
		}
	}
	/* transient soap skipped */
}

int ns4__ArrayOfFilterExpressionBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfFilterExpressionBase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfFilterExpressionBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfFilterExpressionBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfFilterExpressionBase(struct soap *soap, const char *tag, int id, const ns4__ArrayOfFilterExpressionBase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfFilterExpressionBase), "ns4:ArrayOfFilterExpressionBase"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns4__ArrayOfFilterExpressionBase::FilterExpressionBase)
	{	int i;
		for (i = 0; i < a->ns4__ArrayOfFilterExpressionBase::__sizeFilterExpressionBase; i++)
			if (soap_out_PointerTons4__FilterExpressionBase(soap, "ns4:FilterExpressionBase", -1, a->ns4__ArrayOfFilterExpressionBase::FilterExpressionBase + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns4__ArrayOfFilterExpressionBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfFilterExpressionBase(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfFilterExpressionBase * SOAP_FMAC4 soap_get_ns4__ArrayOfFilterExpressionBase(struct soap *soap, ns4__ArrayOfFilterExpressionBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfFilterExpressionBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__ArrayOfFilterExpressionBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfFilterExpressionBase(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfFilterExpressionBase * SOAP_FMAC4 soap_in_ns4__ArrayOfFilterExpressionBase(struct soap *soap, const char *tag, ns4__ArrayOfFilterExpressionBase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfFilterExpressionBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfFilterExpressionBase, sizeof(ns4__ArrayOfFilterExpressionBase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfFilterExpressionBase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfFilterExpressionBase *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_FilterExpressionBase1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:FilterExpressionBase", 1, NULL))
			{	if (a->ns4__ArrayOfFilterExpressionBase::FilterExpressionBase == NULL)
				{	if (soap_blist_FilterExpressionBase1 == NULL)
						soap_blist_FilterExpressionBase1 = soap_new_block(soap);
					a->ns4__ArrayOfFilterExpressionBase::FilterExpressionBase = (ns4__FilterExpressionBase **)soap_push_block(soap, soap_blist_FilterExpressionBase1, sizeof(ns4__FilterExpressionBase *));
					if (a->ns4__ArrayOfFilterExpressionBase::FilterExpressionBase == NULL)
						return NULL;
					*a->ns4__ArrayOfFilterExpressionBase::FilterExpressionBase = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons4__FilterExpressionBase(soap, "ns4:FilterExpressionBase", a->ns4__ArrayOfFilterExpressionBase::FilterExpressionBase, "ns4:FilterExpressionBase"))
				{	a->ns4__ArrayOfFilterExpressionBase::__sizeFilterExpressionBase++;
					a->ns4__ArrayOfFilterExpressionBase::FilterExpressionBase = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns4__ArrayOfFilterExpressionBase::FilterExpressionBase)
			soap_pop_block(soap, soap_blist_FilterExpressionBase1);
		if (a->ns4__ArrayOfFilterExpressionBase::__sizeFilterExpressionBase)
			a->ns4__ArrayOfFilterExpressionBase::FilterExpressionBase = (ns4__FilterExpressionBase **)soap_save_block(soap, soap_blist_FilterExpressionBase1, NULL, 1);
		else
		{	a->ns4__ArrayOfFilterExpressionBase::FilterExpressionBase = NULL;
			if (soap_blist_FilterExpressionBase1)
				soap_end_block(soap, soap_blist_FilterExpressionBase1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfFilterExpressionBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfFilterExpressionBase, 0, sizeof(ns4__ArrayOfFilterExpressionBase), 0, soap_copy_ns4__ArrayOfFilterExpressionBase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__ArrayOfFilterExpressionBase * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfFilterExpressionBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfFilterExpressionBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfFilterExpressionBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfFilterExpressionBase;
		if (size)
			*size = sizeof(ns4__ArrayOfFilterExpressionBase);
		((ns4__ArrayOfFilterExpressionBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfFilterExpressionBase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__ArrayOfFilterExpressionBase);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfFilterExpressionBase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfFilterExpressionBase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfFilterExpressionBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfFilterExpressionBase %p -> %p\n", q, p));
	*(ns4__ArrayOfFilterExpressionBase*)p = *(ns4__ArrayOfFilterExpressionBase*)q;
}

void ns4__FilterExpressionClause::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__FilterExpressionClause::Expressions = NULL;
	this->ns4__FilterExpressionClause::LogicalOperator = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__FilterExpressionClause::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfFilterExpressionBase(soap, &this->ns4__FilterExpressionClause::Expressions);
	soap_serialize_PointerTons4__LogicalOperator(soap, &this->ns4__FilterExpressionClause::LogicalOperator);
	/* transient soap skipped */
}

int ns4__FilterExpressionClause::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__FilterExpressionClause);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__FilterExpressionClause::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__FilterExpressionClause(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FilterExpressionClause(struct soap *soap, const char *tag, int id, const ns4__FilterExpressionClause *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FilterExpressionClause), "ns4:FilterExpressionClause"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__ArrayOfFilterExpressionBase(soap, "ns4:Expressions", -1, &(a->ns4__FilterExpressionClause::Expressions), ""))
		return soap->error;
	if (soap_out_PointerTons4__LogicalOperator(soap, "ns4:LogicalOperator", -1, &(a->ns4__FilterExpressionClause::LogicalOperator), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__FilterExpressionClause::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__FilterExpressionClause(soap, this, tag, type);
}

SOAP_FMAC3 ns4__FilterExpressionClause * SOAP_FMAC4 soap_get_ns4__FilterExpressionClause(struct soap *soap, ns4__FilterExpressionClause *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FilterExpressionClause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__FilterExpressionClause::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__FilterExpressionClause(soap, tag, this, type);
}

SOAP_FMAC3 ns4__FilterExpressionClause * SOAP_FMAC4 soap_in_ns4__FilterExpressionClause(struct soap *soap, const char *tag, ns4__FilterExpressionClause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__FilterExpressionClause *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FilterExpressionClause, sizeof(ns4__FilterExpressionClause), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__FilterExpressionClause)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__FilterExpressionClause *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Expressions1 = 1;
	size_t soap_flag_LogicalOperator1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Expressions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfFilterExpressionBase(soap, "ns4:Expressions", &(a->ns4__FilterExpressionClause::Expressions), "ns4:ArrayOfFilterExpressionBase"))
				{	soap_flag_Expressions1--;
					continue;
				}
			if (soap_flag_LogicalOperator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__LogicalOperator(soap, "ns4:LogicalOperator", &(a->ns4__FilterExpressionClause::LogicalOperator), "ns4:LogicalOperator"))
				{	soap_flag_LogicalOperator1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__FilterExpressionClause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FilterExpressionClause, 0, sizeof(ns4__FilterExpressionClause), 0, soap_copy_ns4__FilterExpressionClause);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__FilterExpressionClause * SOAP_FMAC4 soap_instantiate_ns4__FilterExpressionClause(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__FilterExpressionClause(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__FilterExpressionClause, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__FilterExpressionClause;
		if (size)
			*size = sizeof(ns4__FilterExpressionClause);
		((ns4__FilterExpressionClause*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__FilterExpressionClause[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__FilterExpressionClause);
		for (int i = 0; i < n; i++)
			((ns4__FilterExpressionClause*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__FilterExpressionClause*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__FilterExpressionClause(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__FilterExpressionClause %p -> %p\n", q, p));
	*(ns4__FilterExpressionClause*)p = *(ns4__FilterExpressionClause*)q;
}

void ns4__FilterExpression::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__FilterExpression::CompareOperator = NULL;
	this->ns4__FilterExpression::FilterValue = NULL;
	this->ns4__FilterExpression::PropertyId = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__FilterExpression::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__CompareOperator(soap, &this->ns4__FilterExpression::CompareOperator);
	soap_serialize_PointerToxsd__anyType(soap, &this->ns4__FilterExpression::FilterValue);
	soap_serialize_PointerToint(soap, &this->ns4__FilterExpression::PropertyId);
	/* transient soap skipped */
}

int ns4__FilterExpression::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__FilterExpression);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__FilterExpression::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__FilterExpression(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FilterExpression(struct soap *soap, const char *tag, int id, const ns4__FilterExpression *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FilterExpression), "ns4:FilterExpression"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__CompareOperator(soap, "ns4:CompareOperator", -1, &(a->ns4__FilterExpression::CompareOperator), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "ns4:FilterValue", -1, &(a->ns4__FilterExpression::FilterValue), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:PropertyId", -1, &(a->ns4__FilterExpression::PropertyId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__FilterExpression::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__FilterExpression(soap, this, tag, type);
}

SOAP_FMAC3 ns4__FilterExpression * SOAP_FMAC4 soap_get_ns4__FilterExpression(struct soap *soap, ns4__FilterExpression *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FilterExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__FilterExpression::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__FilterExpression(soap, tag, this, type);
}

SOAP_FMAC3 ns4__FilterExpression * SOAP_FMAC4 soap_in_ns4__FilterExpression(struct soap *soap, const char *tag, ns4__FilterExpression *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__FilterExpression *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FilterExpression, sizeof(ns4__FilterExpression), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__FilterExpression)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__FilterExpression *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_CompareOperator1 = 1;
	size_t soap_flag_FilterValue1 = 1;
	size_t soap_flag_PropertyId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_CompareOperator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CompareOperator(soap, "ns4:CompareOperator", &(a->ns4__FilterExpression::CompareOperator), "ns4:CompareOperator"))
				{	soap_flag_CompareOperator1--;
					continue;
				}
			if (soap_flag_FilterValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "ns4:FilterValue", &(a->ns4__FilterExpression::FilterValue), "xsd:anyType"))
				{	soap_flag_FilterValue1--;
					continue;
				}
			if (soap_flag_PropertyId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:PropertyId", &(a->ns4__FilterExpression::PropertyId), "xsd:int"))
				{	soap_flag_PropertyId1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__FilterExpression *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FilterExpression, 0, sizeof(ns4__FilterExpression), 0, soap_copy_ns4__FilterExpression);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__FilterExpression * SOAP_FMAC4 soap_instantiate_ns4__FilterExpression(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__FilterExpression(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__FilterExpression, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__FilterExpression;
		if (size)
			*size = sizeof(ns4__FilterExpression);
		((ns4__FilterExpression*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__FilterExpression[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__FilterExpression);
		for (int i = 0; i < n; i++)
			((ns4__FilterExpression*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__FilterExpression*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__FilterExpression(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__FilterExpression %p -> %p\n", q, p));
	*(ns4__FilterExpression*)p = *(ns4__FilterExpression*)q;
}

void ns4__FilterExpressionBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__FilterExpressionBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns4__FilterExpressionBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__FilterExpressionBase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__FilterExpressionBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__FilterExpressionBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FilterExpressionBase(struct soap *soap, const char *tag, int id, const ns4__FilterExpressionBase *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns4:FilterExpressionBase");
}

void *ns4__FilterExpressionBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__FilterExpressionBase(soap, this, tag, type);
}

SOAP_FMAC3 ns4__FilterExpressionBase * SOAP_FMAC4 soap_get_ns4__FilterExpressionBase(struct soap *soap, ns4__FilterExpressionBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FilterExpressionBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__FilterExpressionBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__FilterExpressionBase(soap, tag, this, type);
}

SOAP_FMAC3 ns4__FilterExpressionBase * SOAP_FMAC4 soap_in_ns4__FilterExpressionBase(struct soap *soap, const char *tag, ns4__FilterExpressionBase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__FilterExpressionBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FilterExpressionBase, sizeof(ns4__FilterExpressionBase), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__FilterExpressionBase)
			return (ns4__FilterExpressionBase *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

SOAP_FMAC3 ns4__FilterExpressionBase * SOAP_FMAC4 soap_instantiate_ns4__FilterExpressionBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__FilterExpressionBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__FilterExpressionBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns4:FilterExpression"))
	{	cp->type = SOAP_TYPE_ns4__FilterExpression;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__FilterExpression;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__FilterExpression);
			((ns4__FilterExpression*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__FilterExpression[n];
			if (size)
				*size = n * sizeof(ns4__FilterExpression);
			for (int i = 0; i < n; i++)
				((ns4__FilterExpression*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__FilterExpression*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:FilterExpressionClause"))
	{	cp->type = SOAP_TYPE_ns4__FilterExpressionClause;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__FilterExpressionClause;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__FilterExpressionClause);
			((ns4__FilterExpressionClause*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__FilterExpressionClause[n];
			if (size)
				*size = n * sizeof(ns4__FilterExpressionClause);
			for (int i = 0; i < n; i++)
				((ns4__FilterExpressionClause*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__FilterExpressionClause*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns4__FilterExpressionBase;
		if (size)
			*size = sizeof(ns4__FilterExpressionBase);
		((ns4__FilterExpressionBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__FilterExpressionBase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__FilterExpressionBase);
		for (int i = 0; i < n; i++)
			((ns4__FilterExpressionBase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__FilterExpressionBase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__FilterExpressionBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__FilterExpressionBase %p -> %p\n", q, p));
	*(ns4__FilterExpressionBase*)p = *(ns4__FilterExpressionBase*)q;
}

void ns4__SizeOfint::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__SizeOfint::Height = NULL;
	this->ns4__SizeOfint::Width = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__SizeOfint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns4__SizeOfint::Height);
	soap_serialize_PointerToint(soap, &this->ns4__SizeOfint::Width);
	/* transient soap skipped */
}

int ns4__SizeOfint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__SizeOfint);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__SizeOfint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__SizeOfint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SizeOfint(struct soap *soap, const char *tag, int id, const ns4__SizeOfint *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SizeOfint), "ns4:SizeOfint"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToint(soap, "ns4:Height", -1, &(a->ns4__SizeOfint::Height), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:Width", -1, &(a->ns4__SizeOfint::Width), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__SizeOfint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__SizeOfint(soap, this, tag, type);
}

SOAP_FMAC3 ns4__SizeOfint * SOAP_FMAC4 soap_get_ns4__SizeOfint(struct soap *soap, ns4__SizeOfint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SizeOfint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__SizeOfint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__SizeOfint(soap, tag, this, type);
}

SOAP_FMAC3 ns4__SizeOfint * SOAP_FMAC4 soap_in_ns4__SizeOfint(struct soap *soap, const char *tag, ns4__SizeOfint *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__SizeOfint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SizeOfint, sizeof(ns4__SizeOfint), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__SizeOfint)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__SizeOfint *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Height1 = 1;
	size_t soap_flag_Width1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Height1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:Height", &(a->ns4__SizeOfint::Height), "xsd:int"))
				{	soap_flag_Height1--;
					continue;
				}
			if (soap_flag_Width1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:Width", &(a->ns4__SizeOfint::Width), "xsd:int"))
				{	soap_flag_Width1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__SizeOfint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SizeOfint, 0, sizeof(ns4__SizeOfint), 0, soap_copy_ns4__SizeOfint);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__SizeOfint * SOAP_FMAC4 soap_instantiate_ns4__SizeOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__SizeOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__SizeOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__SizeOfint;
		if (size)
			*size = sizeof(ns4__SizeOfint);
		((ns4__SizeOfint*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__SizeOfint[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__SizeOfint);
		for (int i = 0; i < n; i++)
			((ns4__SizeOfint*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__SizeOfint*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__SizeOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__SizeOfint %p -> %p\n", q, p));
	*(ns4__SizeOfint*)p = *(ns4__SizeOfint*)q;
}

void ns4__ArrayOfLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__ArrayOfLocation::__sizeLocation = 0;
	this->ns4__ArrayOfLocation::Location = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__ArrayOfLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns4__ArrayOfLocation::Location)
	{	int i;
		for (i = 0; i < this->ns4__ArrayOfLocation::__sizeLocation; i++)
		{
			soap_serialize_PointerTons4__Location(soap, this->ns4__ArrayOfLocation::Location + i);
		}
	}
	/* transient soap skipped */
}

int ns4__ArrayOfLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfLocation);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ArrayOfLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfLocation(struct soap *soap, const char *tag, int id, const ns4__ArrayOfLocation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfLocation), "ns4:ArrayOfLocation"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns4__ArrayOfLocation::Location)
	{	int i;
		for (i = 0; i < a->ns4__ArrayOfLocation::__sizeLocation; i++)
			if (soap_out_PointerTons4__Location(soap, "ns4:Location", -1, a->ns4__ArrayOfLocation::Location + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns4__ArrayOfLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfLocation(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfLocation * SOAP_FMAC4 soap_get_ns4__ArrayOfLocation(struct soap *soap, ns4__ArrayOfLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__ArrayOfLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfLocation(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfLocation * SOAP_FMAC4 soap_in_ns4__ArrayOfLocation(struct soap *soap, const char *tag, ns4__ArrayOfLocation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfLocation, sizeof(ns4__ArrayOfLocation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfLocation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfLocation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_Location1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:Location", 1, NULL))
			{	if (a->ns4__ArrayOfLocation::Location == NULL)
				{	if (soap_blist_Location1 == NULL)
						soap_blist_Location1 = soap_new_block(soap);
					a->ns4__ArrayOfLocation::Location = (ns4__Location **)soap_push_block(soap, soap_blist_Location1, sizeof(ns4__Location *));
					if (a->ns4__ArrayOfLocation::Location == NULL)
						return NULL;
					*a->ns4__ArrayOfLocation::Location = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons4__Location(soap, "ns4:Location", a->ns4__ArrayOfLocation::Location, "ns4:Location"))
				{	a->ns4__ArrayOfLocation::__sizeLocation++;
					a->ns4__ArrayOfLocation::Location = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns4__ArrayOfLocation::Location)
			soap_pop_block(soap, soap_blist_Location1);
		if (a->ns4__ArrayOfLocation::__sizeLocation)
			a->ns4__ArrayOfLocation::Location = (ns4__Location **)soap_save_block(soap, soap_blist_Location1, NULL, 1);
		else
		{	a->ns4__ArrayOfLocation::Location = NULL;
			if (soap_blist_Location1)
				soap_end_block(soap, soap_blist_Location1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfLocation, 0, sizeof(ns4__ArrayOfLocation), 0, soap_copy_ns4__ArrayOfLocation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__ArrayOfLocation * SOAP_FMAC4 soap_instantiate_ns4__ArrayOfLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfLocation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ArrayOfLocation;
		if (size)
			*size = sizeof(ns4__ArrayOfLocation);
		((ns4__ArrayOfLocation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ArrayOfLocation[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__ArrayOfLocation);
		for (int i = 0; i < n; i++)
			((ns4__ArrayOfLocation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ArrayOfLocation*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfLocation %p -> %p\n", q, p));
	*(ns4__ArrayOfLocation*)p = *(ns4__ArrayOfLocation*)q;
}

void ns4__Polygon::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__Polygon::Vertices = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__Polygon::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfLocation(soap, &this->ns4__Polygon::Vertices);
	/* transient soap skipped */
}

int ns4__Polygon::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Polygon);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__Polygon::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Polygon(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Polygon(struct soap *soap, const char *tag, int id, const ns4__Polygon *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Polygon), "ns4:Polygon"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__ArrayOfLocation(soap, "ns4:Vertices", -1, &(a->ns4__Polygon::Vertices), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__Polygon::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Polygon(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Polygon * SOAP_FMAC4 soap_get_ns4__Polygon(struct soap *soap, ns4__Polygon *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__Polygon::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Polygon(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Polygon * SOAP_FMAC4 soap_in_ns4__Polygon(struct soap *soap, const char *tag, ns4__Polygon *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Polygon *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Polygon, sizeof(ns4__Polygon), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Polygon)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Polygon *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Vertices1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Vertices1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfLocation(soap, "ns4:Vertices", &(a->ns4__Polygon::Vertices), "ns4:ArrayOfLocation"))
				{	soap_flag_Vertices1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Polygon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Polygon, 0, sizeof(ns4__Polygon), 0, soap_copy_ns4__Polygon);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__Polygon * SOAP_FMAC4 soap_instantiate_ns4__Polygon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Polygon(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Polygon, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__Polygon;
		if (size)
			*size = sizeof(ns4__Polygon);
		((ns4__Polygon*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__Polygon[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__Polygon);
		for (int i = 0; i < n; i++)
			((ns4__Polygon*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__Polygon*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Polygon(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Polygon %p -> %p\n", q, p));
	*(ns4__Polygon*)p = *(ns4__Polygon*)q;
}

void ns4__Circle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__Circle::Center = NULL;
	this->ns4__Circle::DistanceUnit = NULL;
	this->ns4__Circle::Radius = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__Circle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Location(soap, &this->ns4__Circle::Center);
	soap_serialize_PointerTons4__DistanceUnit(soap, &this->ns4__Circle::DistanceUnit);
	soap_serialize_PointerTodouble(soap, &this->ns4__Circle::Radius);
	/* transient soap skipped */
}

int ns4__Circle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Circle);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__Circle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Circle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Circle(struct soap *soap, const char *tag, int id, const ns4__Circle *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Circle), "ns4:Circle"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Location(soap, "ns4:Center", -1, &(a->ns4__Circle::Center), ""))
		return soap->error;
	if (soap_out_PointerTons4__DistanceUnit(soap, "ns4:DistanceUnit", -1, &(a->ns4__Circle::DistanceUnit), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns4:Radius", -1, &(a->ns4__Circle::Radius), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__Circle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Circle(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Circle * SOAP_FMAC4 soap_get_ns4__Circle(struct soap *soap, ns4__Circle *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Circle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__Circle::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Circle(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Circle * SOAP_FMAC4 soap_in_ns4__Circle(struct soap *soap, const char *tag, ns4__Circle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Circle *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Circle, sizeof(ns4__Circle), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Circle)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Circle *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Center1 = 1;
	size_t soap_flag_DistanceUnit1 = 1;
	size_t soap_flag_Radius1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Center1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Location(soap, "ns4:Center", &(a->ns4__Circle::Center), "ns4:Location"))
				{	soap_flag_Center1--;
					continue;
				}
			if (soap_flag_DistanceUnit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DistanceUnit(soap, "ns4:DistanceUnit", &(a->ns4__Circle::DistanceUnit), "ns4:DistanceUnit"))
				{	soap_flag_DistanceUnit1--;
					continue;
				}
			if (soap_flag_Radius1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns4:Radius", &(a->ns4__Circle::Radius), "xsd:double"))
				{	soap_flag_Radius1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Circle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Circle, 0, sizeof(ns4__Circle), 0, soap_copy_ns4__Circle);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__Circle * SOAP_FMAC4 soap_instantiate_ns4__Circle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Circle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Circle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__Circle;
		if (size)
			*size = sizeof(ns4__Circle);
		((ns4__Circle*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__Circle[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__Circle);
		for (int i = 0; i < n; i++)
			((ns4__Circle*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__Circle*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Circle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Circle %p -> %p\n", q, p));
	*(ns4__Circle*)p = *(ns4__Circle*)q;
}

void ns4__Rectangle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__Rectangle::Northeast = NULL;
	this->ns4__Rectangle::Southwest = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__Rectangle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Location(soap, &this->ns4__Rectangle::Northeast);
	soap_serialize_PointerTons4__Location(soap, &this->ns4__Rectangle::Southwest);
	/* transient soap skipped */
}

int ns4__Rectangle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Rectangle);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__Rectangle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Rectangle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Rectangle(struct soap *soap, const char *tag, int id, const ns4__Rectangle *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Rectangle), "ns4:Rectangle"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Location(soap, "ns4:Northeast", -1, &(a->ns4__Rectangle::Northeast), ""))
		return soap->error;
	if (soap_out_PointerTons4__Location(soap, "ns4:Southwest", -1, &(a->ns4__Rectangle::Southwest), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__Rectangle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Rectangle(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Rectangle * SOAP_FMAC4 soap_get_ns4__Rectangle(struct soap *soap, ns4__Rectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__Rectangle::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Rectangle(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Rectangle * SOAP_FMAC4 soap_in_ns4__Rectangle(struct soap *soap, const char *tag, ns4__Rectangle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Rectangle *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Rectangle, sizeof(ns4__Rectangle), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Rectangle)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Rectangle *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Northeast1 = 1;
	size_t soap_flag_Southwest1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Northeast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Location(soap, "ns4:Northeast", &(a->ns4__Rectangle::Northeast), "ns4:Location"))
				{	soap_flag_Northeast1--;
					continue;
				}
			if (soap_flag_Southwest1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Location(soap, "ns4:Southwest", &(a->ns4__Rectangle::Southwest), "ns4:Location"))
				{	soap_flag_Southwest1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Rectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Rectangle, 0, sizeof(ns4__Rectangle), 0, soap_copy_ns4__Rectangle);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__Rectangle * SOAP_FMAC4 soap_instantiate_ns4__Rectangle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Rectangle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Rectangle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__Rectangle;
		if (size)
			*size = sizeof(ns4__Rectangle);
		((ns4__Rectangle*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__Rectangle[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__Rectangle);
		for (int i = 0; i < n; i++)
			((ns4__Rectangle*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__Rectangle*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Rectangle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Rectangle %p -> %p\n", q, p));
	*(ns4__Rectangle*)p = *(ns4__Rectangle*)q;
}

void ns4__ShapeBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__ShapeBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns4__ShapeBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ShapeBase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ShapeBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ShapeBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ShapeBase(struct soap *soap, const char *tag, int id, const ns4__ShapeBase *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns4:ShapeBase");
}

void *ns4__ShapeBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ShapeBase(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ShapeBase * SOAP_FMAC4 soap_get_ns4__ShapeBase(struct soap *soap, ns4__ShapeBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ShapeBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__ShapeBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ShapeBase(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ShapeBase * SOAP_FMAC4 soap_in_ns4__ShapeBase(struct soap *soap, const char *tag, ns4__ShapeBase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__ShapeBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ShapeBase, sizeof(ns4__ShapeBase), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ShapeBase)
			return (ns4__ShapeBase *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

SOAP_FMAC3 ns4__ShapeBase * SOAP_FMAC4 soap_instantiate_ns4__ShapeBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ShapeBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ShapeBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns4:Rectangle"))
	{	cp->type = SOAP_TYPE_ns4__Rectangle;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__Rectangle;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__Rectangle);
			((ns4__Rectangle*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__Rectangle[n];
			if (size)
				*size = n * sizeof(ns4__Rectangle);
			for (int i = 0; i < n; i++)
				((ns4__Rectangle*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__Rectangle*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:Circle"))
	{	cp->type = SOAP_TYPE_ns4__Circle;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__Circle;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__Circle);
			((ns4__Circle*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__Circle[n];
			if (size)
				*size = n * sizeof(ns4__Circle);
			for (int i = 0; i < n; i++)
				((ns4__Circle*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__Circle*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:Polygon"))
	{	cp->type = SOAP_TYPE_ns4__Polygon;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__Polygon;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__Polygon);
			((ns4__Polygon*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__Polygon[n];
			if (size)
				*size = n * sizeof(ns4__Polygon);
			for (int i = 0; i < n; i++)
				((ns4__Polygon*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__Polygon*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:SearchPoint"))
	{	cp->type = SOAP_TYPE_ns6__SearchPoint;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__SearchPoint;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__SearchPoint);
			((ns6__SearchPoint*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__SearchPoint[n];
			if (size)
				*size = n * sizeof(ns6__SearchPoint);
			for (int i = 0; i < n; i++)
				((ns6__SearchPoint*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__SearchPoint*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ShapeBase;
		if (size)
			*size = sizeof(ns4__ShapeBase);
		((ns4__ShapeBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ShapeBase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__ShapeBase);
		for (int i = 0; i < n; i++)
			((ns4__ShapeBase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ShapeBase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ShapeBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ShapeBase %p -> %p\n", q, p));
	*(ns4__ShapeBase*)p = *(ns4__ShapeBase*)q;
}

void ns4__GeocodeLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns4__GeocodeLocation::CalculationMethod);
	this->ns4__Location::Altitude = NULL;
	this->ns4__Location::Latitude = NULL;
	this->ns4__Location::Longitude = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__GeocodeLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns4__GeocodeLocation::CalculationMethod);
	soap_serialize_PointerTodouble(soap, &this->ns4__Location::Altitude);
	soap_serialize_PointerTodouble(soap, &this->ns4__Location::Latitude);
	soap_serialize_PointerTodouble(soap, &this->ns4__Location::Longitude);
	/* transient soap skipped */
}

int ns4__GeocodeLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__GeocodeLocation);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__GeocodeLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__GeocodeLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GeocodeLocation(struct soap *soap, const char *tag, int id, const ns4__GeocodeLocation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GeocodeLocation), "ns4:GeocodeLocation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTodouble(soap, "ns4:Altitude", -1, &(a->ns4__Location::Altitude), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns4:Latitude", -1, &(a->ns4__Location::Latitude), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns4:Longitude", -1, &(a->ns4__Location::Longitude), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CalculationMethod", -1, &(a->ns4__GeocodeLocation::CalculationMethod), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__GeocodeLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__GeocodeLocation(soap, this, tag, type);
}

SOAP_FMAC3 ns4__GeocodeLocation * SOAP_FMAC4 soap_get_ns4__GeocodeLocation(struct soap *soap, ns4__GeocodeLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GeocodeLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__GeocodeLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__GeocodeLocation(soap, tag, this, type);
}

SOAP_FMAC3 ns4__GeocodeLocation * SOAP_FMAC4 soap_in_ns4__GeocodeLocation(struct soap *soap, const char *tag, ns4__GeocodeLocation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__GeocodeLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GeocodeLocation, sizeof(ns4__GeocodeLocation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__GeocodeLocation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__GeocodeLocation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Altitude2 = 1;
	size_t soap_flag_Latitude2 = 1;
	size_t soap_flag_Longitude2 = 1;
	size_t soap_flag_CalculationMethod1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Altitude2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns4:Altitude", &(a->ns4__Location::Altitude), "xsd:double"))
				{	soap_flag_Altitude2--;
					continue;
				}
			if (soap_flag_Latitude2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns4:Latitude", &(a->ns4__Location::Latitude), "xsd:double"))
				{	soap_flag_Latitude2--;
					continue;
				}
			if (soap_flag_Longitude2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns4:Longitude", &(a->ns4__Location::Longitude), "xsd:double"))
				{	soap_flag_Longitude2--;
					continue;
				}
			if (soap_flag_CalculationMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CalculationMethod", &(a->ns4__GeocodeLocation::CalculationMethod), "xsd:string"))
				{	soap_flag_CalculationMethod1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__GeocodeLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GeocodeLocation, 0, sizeof(ns4__GeocodeLocation), 0, soap_copy_ns4__GeocodeLocation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__GeocodeLocation * SOAP_FMAC4 soap_instantiate_ns4__GeocodeLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__GeocodeLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__GeocodeLocation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__GeocodeLocation;
		if (size)
			*size = sizeof(ns4__GeocodeLocation);
		((ns4__GeocodeLocation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__GeocodeLocation[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__GeocodeLocation);
		for (int i = 0; i < n; i++)
			((ns4__GeocodeLocation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__GeocodeLocation*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__GeocodeLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__GeocodeLocation %p -> %p\n", q, p));
	*(ns4__GeocodeLocation*)p = *(ns4__GeocodeLocation*)q;
}

void ns4__Location::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__Location::Altitude = NULL;
	this->ns4__Location::Latitude = NULL;
	this->ns4__Location::Longitude = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__Location::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTodouble(soap, &this->ns4__Location::Altitude);
	soap_serialize_PointerTodouble(soap, &this->ns4__Location::Latitude);
	soap_serialize_PointerTodouble(soap, &this->ns4__Location::Longitude);
	/* transient soap skipped */
}

int ns4__Location::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Location);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__Location::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Location(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Location(struct soap *soap, const char *tag, int id, const ns4__Location *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Location), "ns4:Location"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTodouble(soap, "ns4:Altitude", -1, &(a->ns4__Location::Altitude), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns4:Latitude", -1, &(a->ns4__Location::Latitude), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns4:Longitude", -1, &(a->ns4__Location::Longitude), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__Location::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Location(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Location * SOAP_FMAC4 soap_get_ns4__Location(struct soap *soap, ns4__Location *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Location(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__Location::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Location(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Location * SOAP_FMAC4 soap_in_ns4__Location(struct soap *soap, const char *tag, ns4__Location *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Location *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Location, sizeof(ns4__Location), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Location)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Location *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Altitude1 = 1;
	size_t soap_flag_Latitude1 = 1;
	size_t soap_flag_Longitude1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Altitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns4:Altitude", &(a->ns4__Location::Altitude), "xsd:double"))
				{	soap_flag_Altitude1--;
					continue;
				}
			if (soap_flag_Latitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns4:Latitude", &(a->ns4__Location::Latitude), "xsd:double"))
				{	soap_flag_Latitude1--;
					continue;
				}
			if (soap_flag_Longitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns4:Longitude", &(a->ns4__Location::Longitude), "xsd:double"))
				{	soap_flag_Longitude1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Location *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Location, 0, sizeof(ns4__Location), 0, soap_copy_ns4__Location);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__Location * SOAP_FMAC4 soap_instantiate_ns4__Location(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Location(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Location, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns4:UserLocation"))
	{	cp->type = SOAP_TYPE_ns4__UserLocation;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__UserLocation;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__UserLocation);
			((ns4__UserLocation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__UserLocation[n];
			if (size)
				*size = n * sizeof(ns4__UserLocation);
			for (int i = 0; i < n; i++)
				((ns4__UserLocation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__UserLocation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:GeocodeLocation"))
	{	cp->type = SOAP_TYPE_ns4__GeocodeLocation;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__GeocodeLocation;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__GeocodeLocation);
			((ns4__GeocodeLocation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__GeocodeLocation[n];
			if (size)
				*size = n * sizeof(ns4__GeocodeLocation);
			for (int i = 0; i < n; i++)
				((ns4__GeocodeLocation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__GeocodeLocation*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns4__Location;
		if (size)
			*size = sizeof(ns4__Location);
		((ns4__Location*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__Location[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__Location);
		for (int i = 0; i < n; i++)
			((ns4__Location*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__Location*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Location(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Location %p -> %p\n", q, p));
	*(ns4__Location*)p = *(ns4__Location*)q;
}

void ns4__UserLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__UserLocation::Confidence = NULL;
	this->ns4__Location::Altitude = NULL;
	this->ns4__Location::Latitude = NULL;
	this->ns4__Location::Longitude = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__UserLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Confidence(soap, &this->ns4__UserLocation::Confidence);
	soap_serialize_PointerTodouble(soap, &this->ns4__Location::Altitude);
	soap_serialize_PointerTodouble(soap, &this->ns4__Location::Latitude);
	soap_serialize_PointerTodouble(soap, &this->ns4__Location::Longitude);
	/* transient soap skipped */
}

int ns4__UserLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__UserLocation);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__UserLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__UserLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UserLocation(struct soap *soap, const char *tag, int id, const ns4__UserLocation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UserLocation), "ns4:UserLocation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTodouble(soap, "ns4:Altitude", -1, &(a->ns4__Location::Altitude), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns4:Latitude", -1, &(a->ns4__Location::Latitude), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ns4:Longitude", -1, &(a->ns4__Location::Longitude), ""))
		return soap->error;
	if (soap_out_PointerTons4__Confidence(soap, "ns4:Confidence", -1, &(a->ns4__UserLocation::Confidence), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__UserLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__UserLocation(soap, this, tag, type);
}

SOAP_FMAC3 ns4__UserLocation * SOAP_FMAC4 soap_get_ns4__UserLocation(struct soap *soap, ns4__UserLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UserLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__UserLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__UserLocation(soap, tag, this, type);
}

SOAP_FMAC3 ns4__UserLocation * SOAP_FMAC4 soap_in_ns4__UserLocation(struct soap *soap, const char *tag, ns4__UserLocation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__UserLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UserLocation, sizeof(ns4__UserLocation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__UserLocation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__UserLocation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Altitude2 = 1;
	size_t soap_flag_Latitude2 = 1;
	size_t soap_flag_Longitude2 = 1;
	size_t soap_flag_Confidence1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Altitude2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns4:Altitude", &(a->ns4__Location::Altitude), "xsd:double"))
				{	soap_flag_Altitude2--;
					continue;
				}
			if (soap_flag_Latitude2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns4:Latitude", &(a->ns4__Location::Latitude), "xsd:double"))
				{	soap_flag_Latitude2--;
					continue;
				}
			if (soap_flag_Longitude2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns4:Longitude", &(a->ns4__Location::Longitude), "xsd:double"))
				{	soap_flag_Longitude2--;
					continue;
				}
			if (soap_flag_Confidence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Confidence(soap, "ns4:Confidence", &(a->ns4__UserLocation::Confidence), "ns4:Confidence"))
				{	soap_flag_Confidence1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__UserLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UserLocation, 0, sizeof(ns4__UserLocation), 0, soap_copy_ns4__UserLocation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__UserLocation * SOAP_FMAC4 soap_instantiate_ns4__UserLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__UserLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__UserLocation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__UserLocation;
		if (size)
			*size = sizeof(ns4__UserLocation);
		((ns4__UserLocation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__UserLocation[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__UserLocation);
		for (int i = 0; i < n; i++)
			((ns4__UserLocation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__UserLocation*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__UserLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__UserLocation %p -> %p\n", q, p));
	*(ns4__UserLocation*)p = *(ns4__UserLocation*)q;
}

void ns4__Heading::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__Heading::Orientation = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__Heading::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTodouble(soap, &this->ns4__Heading::Orientation);
	/* transient soap skipped */
}

int ns4__Heading::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Heading);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__Heading::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Heading(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Heading(struct soap *soap, const char *tag, int id, const ns4__Heading *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Heading), "ns4:Heading"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTodouble(soap, "ns4:Orientation", -1, &(a->ns4__Heading::Orientation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__Heading::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Heading(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Heading * SOAP_FMAC4 soap_get_ns4__Heading(struct soap *soap, ns4__Heading *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Heading(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__Heading::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Heading(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Heading * SOAP_FMAC4 soap_in_ns4__Heading(struct soap *soap, const char *tag, ns4__Heading *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Heading *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Heading, sizeof(ns4__Heading), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Heading)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Heading *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Orientation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Orientation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ns4:Orientation", &(a->ns4__Heading::Orientation), "xsd:double"))
				{	soap_flag_Orientation1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Heading *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Heading, 0, sizeof(ns4__Heading), 0, soap_copy_ns4__Heading);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__Heading * SOAP_FMAC4 soap_instantiate_ns4__Heading(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Heading(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Heading, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__Heading;
		if (size)
			*size = sizeof(ns4__Heading);
		((ns4__Heading*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__Heading[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__Heading);
		for (int i = 0; i < n; i++)
			((ns4__Heading*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__Heading*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Heading(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Heading %p -> %p\n", q, p));
	*(ns4__Heading*)p = *(ns4__Heading*)q;
}

void ns4__UserProfile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__UserProfile::CurrentHeading = NULL;
	this->ns4__UserProfile::CurrentLocation = NULL;
	this->ns4__UserProfile::DeviceType = NULL;
	this->ns4__UserProfile::DistanceUnit = NULL;
	soap_default_string(soap, &this->ns4__UserProfile::IPAddress);
	this->ns4__UserProfile::MapView = NULL;
	this->ns4__UserProfile::ScreenSize = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__UserProfile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Heading(soap, &this->ns4__UserProfile::CurrentHeading);
	soap_serialize_PointerTons4__UserLocation(soap, &this->ns4__UserProfile::CurrentLocation);
	soap_serialize_PointerTons4__DeviceType(soap, &this->ns4__UserProfile::DeviceType);
	soap_serialize_PointerTons4__DistanceUnit(soap, &this->ns4__UserProfile::DistanceUnit);
	soap_serialize_string(soap, &this->ns4__UserProfile::IPAddress);
	soap_serialize_PointerTons4__ShapeBase(soap, &this->ns4__UserProfile::MapView);
	soap_serialize_PointerTons4__SizeOfint(soap, &this->ns4__UserProfile::ScreenSize);
	/* transient soap skipped */
}

int ns4__UserProfile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__UserProfile);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__UserProfile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__UserProfile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UserProfile(struct soap *soap, const char *tag, int id, const ns4__UserProfile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UserProfile), "ns4:UserProfile"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Heading(soap, "ns4:CurrentHeading", -1, &(a->ns4__UserProfile::CurrentHeading), ""))
		return soap->error;
	if (soap_out_PointerTons4__UserLocation(soap, "ns4:CurrentLocation", -1, &(a->ns4__UserProfile::CurrentLocation), ""))
		return soap->error;
	if (soap_out_PointerTons4__DeviceType(soap, "ns4:DeviceType", -1, &(a->ns4__UserProfile::DeviceType), ""))
		return soap->error;
	if (soap_out_PointerTons4__DistanceUnit(soap, "ns4:DistanceUnit", -1, &(a->ns4__UserProfile::DistanceUnit), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:IPAddress", -1, &(a->ns4__UserProfile::IPAddress), ""))
		return soap->error;
	if (soap_out_PointerTons4__ShapeBase(soap, "ns4:MapView", -1, &(a->ns4__UserProfile::MapView), ""))
		return soap->error;
	if (soap_out_PointerTons4__SizeOfint(soap, "ns4:ScreenSize", -1, &(a->ns4__UserProfile::ScreenSize), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__UserProfile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__UserProfile(soap, this, tag, type);
}

SOAP_FMAC3 ns4__UserProfile * SOAP_FMAC4 soap_get_ns4__UserProfile(struct soap *soap, ns4__UserProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UserProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__UserProfile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__UserProfile(soap, tag, this, type);
}

SOAP_FMAC3 ns4__UserProfile * SOAP_FMAC4 soap_in_ns4__UserProfile(struct soap *soap, const char *tag, ns4__UserProfile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__UserProfile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UserProfile, sizeof(ns4__UserProfile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__UserProfile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__UserProfile *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_CurrentHeading1 = 1;
	size_t soap_flag_CurrentLocation1 = 1;
	size_t soap_flag_DeviceType1 = 1;
	size_t soap_flag_DistanceUnit1 = 1;
	size_t soap_flag_IPAddress1 = 1;
	size_t soap_flag_MapView1 = 1;
	size_t soap_flag_ScreenSize1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_CurrentHeading1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Heading(soap, "ns4:CurrentHeading", &(a->ns4__UserProfile::CurrentHeading), "ns4:Heading"))
				{	soap_flag_CurrentHeading1--;
					continue;
				}
			if (soap_flag_CurrentLocation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserLocation(soap, "ns4:CurrentLocation", &(a->ns4__UserProfile::CurrentLocation), "ns4:UserLocation"))
				{	soap_flag_CurrentLocation1--;
					continue;
				}
			if (soap_flag_DeviceType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DeviceType(soap, "ns4:DeviceType", &(a->ns4__UserProfile::DeviceType), "ns4:DeviceType"))
				{	soap_flag_DeviceType1--;
					continue;
				}
			if (soap_flag_DistanceUnit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DistanceUnit(soap, "ns4:DistanceUnit", &(a->ns4__UserProfile::DistanceUnit), "ns4:DistanceUnit"))
				{	soap_flag_DistanceUnit1--;
					continue;
				}
			if (soap_flag_IPAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:IPAddress", &(a->ns4__UserProfile::IPAddress), "xsd:string"))
				{	soap_flag_IPAddress1--;
					continue;
				}
			if (soap_flag_MapView1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ShapeBase(soap, "ns4:MapView", &(a->ns4__UserProfile::MapView), "ns4:ShapeBase"))
				{	soap_flag_MapView1--;
					continue;
				}
			if (soap_flag_ScreenSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SizeOfint(soap, "ns4:ScreenSize", &(a->ns4__UserProfile::ScreenSize), "ns4:SizeOfint"))
				{	soap_flag_ScreenSize1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__UserProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UserProfile, 0, sizeof(ns4__UserProfile), 0, soap_copy_ns4__UserProfile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__UserProfile * SOAP_FMAC4 soap_instantiate_ns4__UserProfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__UserProfile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__UserProfile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__UserProfile;
		if (size)
			*size = sizeof(ns4__UserProfile);
		((ns4__UserProfile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__UserProfile[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__UserProfile);
		for (int i = 0; i < n; i++)
			((ns4__UserProfile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__UserProfile*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__UserProfile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__UserProfile %p -> %p\n", q, p));
	*(ns4__UserProfile*)p = *(ns4__UserProfile*)q;
}

void ns4__ExecutionOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__ExecutionOptions::SuppressFaults = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__ExecutionOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &this->ns4__ExecutionOptions::SuppressFaults);
	/* transient soap skipped */
}

int ns4__ExecutionOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ExecutionOptions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ExecutionOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ExecutionOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ExecutionOptions(struct soap *soap, const char *tag, int id, const ns4__ExecutionOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ExecutionOptions), "ns4:ExecutionOptions"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTobool(soap, "ns4:SuppressFaults", -1, &(a->ns4__ExecutionOptions::SuppressFaults), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__ExecutionOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ExecutionOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ExecutionOptions * SOAP_FMAC4 soap_get_ns4__ExecutionOptions(struct soap *soap, ns4__ExecutionOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ExecutionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__ExecutionOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ExecutionOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ExecutionOptions * SOAP_FMAC4 soap_in_ns4__ExecutionOptions(struct soap *soap, const char *tag, ns4__ExecutionOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ExecutionOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ExecutionOptions, sizeof(ns4__ExecutionOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ExecutionOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ExecutionOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_SuppressFaults1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_SuppressFaults1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns4:SuppressFaults", &(a->ns4__ExecutionOptions::SuppressFaults), "xsd:boolean"))
				{	soap_flag_SuppressFaults1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ExecutionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ExecutionOptions, 0, sizeof(ns4__ExecutionOptions), 0, soap_copy_ns4__ExecutionOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__ExecutionOptions * SOAP_FMAC4 soap_instantiate_ns4__ExecutionOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ExecutionOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ExecutionOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ExecutionOptions;
		if (size)
			*size = sizeof(ns4__ExecutionOptions);
		((ns4__ExecutionOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__ExecutionOptions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__ExecutionOptions);
		for (int i = 0; i < n; i++)
			((ns4__ExecutionOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ExecutionOptions*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ExecutionOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ExecutionOptions %p -> %p\n", q, p));
	*(ns4__ExecutionOptions*)p = *(ns4__ExecutionOptions*)q;
}

void ns4__Credentials::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns4__Credentials::ApplicationId);
	soap_default_string(soap, &this->ns4__Credentials::Token);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__Credentials::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns4__Credentials::ApplicationId);
	soap_serialize_string(soap, &this->ns4__Credentials::Token);
	/* transient soap skipped */
}

int ns4__Credentials::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Credentials);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__Credentials::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Credentials(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Credentials(struct soap *soap, const char *tag, int id, const ns4__Credentials *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Credentials), "ns4:Credentials"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns4:ApplicationId", -1, &(a->ns4__Credentials::ApplicationId), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Token", -1, &(a->ns4__Credentials::Token), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__Credentials::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Credentials(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Credentials * SOAP_FMAC4 soap_get_ns4__Credentials(struct soap *soap, ns4__Credentials *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Credentials(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__Credentials::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__Credentials(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Credentials * SOAP_FMAC4 soap_in_ns4__Credentials(struct soap *soap, const char *tag, ns4__Credentials *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Credentials *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Credentials, sizeof(ns4__Credentials), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__Credentials)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Credentials *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ApplicationId1 = 1;
	size_t soap_flag_Token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ApplicationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ApplicationId", &(a->ns4__Credentials::ApplicationId), "xsd:string"))
				{	soap_flag_ApplicationId1--;
					continue;
				}
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Token", &(a->ns4__Credentials::Token), "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__Credentials *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Credentials, 0, sizeof(ns4__Credentials), 0, soap_copy_ns4__Credentials);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__Credentials * SOAP_FMAC4 soap_instantiate_ns4__Credentials(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Credentials(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Credentials, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__Credentials;
		if (size)
			*size = sizeof(ns4__Credentials);
		((ns4__Credentials*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__Credentials[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__Credentials);
		for (int i = 0; i < n; i++)
			((ns4__Credentials*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__Credentials*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Credentials(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Credentials %p -> %p\n", q, p));
	*(ns4__Credentials*)p = *(ns4__Credentials*)q;
}

void ns4__RequestBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__RequestBase::Credentials = NULL;
	soap_default_string(soap, &this->ns4__RequestBase::Culture);
	this->ns4__RequestBase::ExecutionOptions = NULL;
	this->ns4__RequestBase::UserProfile = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns4__RequestBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__Credentials(soap, &this->ns4__RequestBase::Credentials);
	soap_serialize_string(soap, &this->ns4__RequestBase::Culture);
	soap_serialize_PointerTons4__ExecutionOptions(soap, &this->ns4__RequestBase::ExecutionOptions);
	soap_serialize_PointerTons4__UserProfile(soap, &this->ns4__RequestBase::UserProfile);
	/* transient soap skipped */
}

int ns4__RequestBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__RequestBase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__RequestBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__RequestBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RequestBase(struct soap *soap, const char *tag, int id, const ns4__RequestBase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__RequestBase), "ns4:RequestBase"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__Credentials(soap, "ns4:Credentials", -1, &(a->ns4__RequestBase::Credentials), ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Culture", -1, &(a->ns4__RequestBase::Culture), ""))
		return soap->error;
	if (soap_out_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", -1, &(a->ns4__RequestBase::ExecutionOptions), ""))
		return soap->error;
	if (soap_out_PointerTons4__UserProfile(soap, "ns4:UserProfile", -1, &(a->ns4__RequestBase::UserProfile), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__RequestBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__RequestBase(soap, this, tag, type);
}

SOAP_FMAC3 ns4__RequestBase * SOAP_FMAC4 soap_get_ns4__RequestBase(struct soap *soap, ns4__RequestBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RequestBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__RequestBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__RequestBase(soap, tag, this, type);
}

SOAP_FMAC3 ns4__RequestBase * SOAP_FMAC4 soap_in_ns4__RequestBase(struct soap *soap, const char *tag, ns4__RequestBase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__RequestBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__RequestBase, sizeof(ns4__RequestBase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__RequestBase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__RequestBase *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Credentials1 = 1;
	size_t soap_flag_Culture1 = 1;
	size_t soap_flag_ExecutionOptions1 = 1;
	size_t soap_flag_UserProfile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Credentials1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__Credentials(soap, "ns4:Credentials", &(a->ns4__RequestBase::Credentials), "ns4:Credentials"))
				{	soap_flag_Credentials1--;
					continue;
				}
			if (soap_flag_Culture1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Culture", &(a->ns4__RequestBase::Culture), "xsd:string"))
				{	soap_flag_Culture1--;
					continue;
				}
			if (soap_flag_ExecutionOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ExecutionOptions(soap, "ns4:ExecutionOptions", &(a->ns4__RequestBase::ExecutionOptions), "ns4:ExecutionOptions"))
				{	soap_flag_ExecutionOptions1--;
					continue;
				}
			if (soap_flag_UserProfile1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserProfile(soap, "ns4:UserProfile", &(a->ns4__RequestBase::UserProfile), "ns4:UserProfile"))
				{	soap_flag_UserProfile1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__RequestBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__RequestBase, 0, sizeof(ns4__RequestBase), 0, soap_copy_ns4__RequestBase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns4__RequestBase * SOAP_FMAC4 soap_instantiate_ns4__RequestBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__RequestBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__RequestBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns6:SearchRequest"))
	{	cp->type = SOAP_TYPE_ns6__SearchRequest;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__SearchRequest;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__SearchRequest);
			((ns6__SearchRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__SearchRequest[n];
			if (size)
				*size = n * sizeof(ns6__SearchRequest);
			for (int i = 0; i < n; i++)
				((ns6__SearchRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__SearchRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns10:GeocodeRequest"))
	{	cp->type = SOAP_TYPE_ns10__GeocodeRequest;
		if (n < 0)
		{	cp->ptr = (void*)new ns10__GeocodeRequest;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns10__GeocodeRequest);
			((ns10__GeocodeRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns10__GeocodeRequest[n];
			if (size)
				*size = n * sizeof(ns10__GeocodeRequest);
			for (int i = 0; i < n; i++)
				((ns10__GeocodeRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns10__GeocodeRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns10:ReverseGeocodeRequest"))
	{	cp->type = SOAP_TYPE_ns10__ReverseGeocodeRequest;
		if (n < 0)
		{	cp->ptr = (void*)new ns10__ReverseGeocodeRequest;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns10__ReverseGeocodeRequest);
			((ns10__ReverseGeocodeRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns10__ReverseGeocodeRequest[n];
			if (size)
				*size = n * sizeof(ns10__ReverseGeocodeRequest);
			for (int i = 0; i < n; i++)
				((ns10__ReverseGeocodeRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns10__ReverseGeocodeRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:ImageryMetadataRequest"))
	{	cp->type = SOAP_TYPE_ns13__ImageryMetadataRequest;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__ImageryMetadataRequest;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__ImageryMetadataRequest);
			((ns13__ImageryMetadataRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__ImageryMetadataRequest[n];
			if (size)
				*size = n * sizeof(ns13__ImageryMetadataRequest);
			for (int i = 0; i < n; i++)
				((ns13__ImageryMetadataRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__ImageryMetadataRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:MapUriRequest"))
	{	cp->type = SOAP_TYPE_ns13__MapUriRequest;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__MapUriRequest;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__MapUriRequest);
			((ns13__MapUriRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__MapUriRequest[n];
			if (size)
				*size = n * sizeof(ns13__MapUriRequest);
			for (int i = 0; i < n; i++)
				((ns13__MapUriRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__MapUriRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:RouteRequest"))
	{	cp->type = SOAP_TYPE_ns16__RouteRequest;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__RouteRequest;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__RouteRequest);
			((ns16__RouteRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__RouteRequest[n];
			if (size)
				*size = n * sizeof(ns16__RouteRequest);
			for (int i = 0; i < n; i++)
				((ns16__RouteRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__RouteRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:MajorRoutesRequest"))
	{	cp->type = SOAP_TYPE_ns16__MajorRoutesRequest;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__MajorRoutesRequest;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__MajorRoutesRequest);
			((ns16__MajorRoutesRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__MajorRoutesRequest[n];
			if (size)
				*size = n * sizeof(ns16__MajorRoutesRequest);
			for (int i = 0; i < n; i++)
				((ns16__MajorRoutesRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__MajorRoutesRequest*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns4__RequestBase;
		if (size)
			*size = sizeof(ns4__RequestBase);
		((ns4__RequestBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__RequestBase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__RequestBase);
		for (int i = 0; i < n; i++)
			((ns4__RequestBase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__RequestBase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__RequestBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__RequestBase %p -> %p\n", q, p));
	*(ns4__RequestBase*)p = *(ns4__RequestBase*)q;
}

void _ns3__SearchResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__SearchResponse::SearchResult = NULL;
	/* transient soap skipped */
}

void _ns3__SearchResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__SearchResponse(soap, &this->_ns3__SearchResponse::SearchResult);
	/* transient soap skipped */
}

int _ns3__SearchResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__SearchResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__SearchResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__SearchResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__SearchResponse(struct soap *soap, const char *tag, int id, const _ns3__SearchResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__SearchResponse), type))
		return soap->error;
	if (a->SearchResult)
		soap_element_result(soap, "ns3:SearchResult");
	if (soap_out_PointerTons6__SearchResponse(soap, "ns3:SearchResult", -1, &(a->_ns3__SearchResponse::SearchResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__SearchResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__SearchResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__SearchResponse * SOAP_FMAC4 soap_get__ns3__SearchResponse(struct soap *soap, _ns3__SearchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__SearchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__SearchResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__SearchResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__SearchResponse * SOAP_FMAC4 soap_in__ns3__SearchResponse(struct soap *soap, const char *tag, _ns3__SearchResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__SearchResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__SearchResponse, sizeof(_ns3__SearchResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__SearchResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__SearchResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SearchResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__SearchResponse(soap, "ns3:SearchResult", &(a->_ns3__SearchResponse::SearchResult), "ns6:SearchResponse"))
				{	soap_flag_SearchResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:SearchResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__SearchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__SearchResponse, 0, sizeof(_ns3__SearchResponse), 0, soap_copy__ns3__SearchResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__SearchResponse * SOAP_FMAC4 soap_instantiate__ns3__SearchResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__SearchResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__SearchResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__SearchResponse;
		if (size)
			*size = sizeof(_ns3__SearchResponse);
		((_ns3__SearchResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__SearchResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__SearchResponse);
		for (int i = 0; i < n; i++)
			((_ns3__SearchResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__SearchResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__SearchResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__SearchResponse %p -> %p\n", q, p));
	*(_ns3__SearchResponse*)p = *(_ns3__SearchResponse*)q;
}

void _ns3__Search::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__Search::request = NULL;
	/* transient soap skipped */
}

void _ns3__Search::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__SearchRequest(soap, &this->_ns3__Search::request);
	/* transient soap skipped */
}

int _ns3__Search::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__Search);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__Search::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__Search(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__Search(struct soap *soap, const char *tag, int id, const _ns3__Search *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__Search), type))
		return soap->error;
	if (soap_out_PointerTons6__SearchRequest(soap, "ns3:request", -1, &(a->_ns3__Search::request), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__Search::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__Search(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__Search * SOAP_FMAC4 soap_get__ns3__Search(struct soap *soap, _ns3__Search *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__Search(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__Search::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__Search(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__Search * SOAP_FMAC4 soap_in__ns3__Search(struct soap *soap, const char *tag, _ns3__Search *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__Search *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__Search, sizeof(_ns3__Search), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__Search)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__Search *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_request1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__SearchRequest(soap, "ns3:request", &(a->_ns3__Search::request), "ns6:SearchRequest"))
				{	soap_flag_request1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__Search *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__Search, 0, sizeof(_ns3__Search), 0, soap_copy__ns3__Search);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__Search * SOAP_FMAC4 soap_instantiate__ns3__Search(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__Search(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__Search, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__Search;
		if (size)
			*size = sizeof(_ns3__Search);
		((_ns3__Search*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__Search[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__Search);
		for (int i = 0; i < n; i++)
			((_ns3__Search*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__Search*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__Search(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__Search %p -> %p\n", q, p));
	*(_ns3__Search*)p = *(_ns3__Search*)q;
}

void _ns1__GetClientTokenResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetClientTokenResponse::GetClientTokenResult);
	/* transient soap skipped */
}

void _ns1__GetClientTokenResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetClientTokenResponse::GetClientTokenResult);
	/* transient soap skipped */
}

int _ns1__GetClientTokenResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetClientTokenResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetClientTokenResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetClientTokenResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetClientTokenResponse(struct soap *soap, const char *tag, int id, const _ns1__GetClientTokenResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetClientTokenResponse), type))
		return soap->error;
	if (a->GetClientTokenResult)
		soap_element_result(soap, "ns1:GetClientTokenResult");
	if (soap_out_string(soap, "ns1:GetClientTokenResult", -1, &(a->_ns1__GetClientTokenResponse::GetClientTokenResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetClientTokenResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetClientTokenResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetClientTokenResponse * SOAP_FMAC4 soap_get__ns1__GetClientTokenResponse(struct soap *soap, _ns1__GetClientTokenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetClientTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetClientTokenResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetClientTokenResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetClientTokenResponse * SOAP_FMAC4 soap_in__ns1__GetClientTokenResponse(struct soap *soap, const char *tag, _ns1__GetClientTokenResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetClientTokenResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetClientTokenResponse, sizeof(_ns1__GetClientTokenResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetClientTokenResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetClientTokenResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetClientTokenResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetClientTokenResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetClientTokenResult", &(a->_ns1__GetClientTokenResponse::GetClientTokenResult), "xsd:string"))
				{	soap_flag_GetClientTokenResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetClientTokenResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetClientTokenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetClientTokenResponse, 0, sizeof(_ns1__GetClientTokenResponse), 0, soap_copy__ns1__GetClientTokenResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetClientTokenResponse * SOAP_FMAC4 soap_instantiate__ns1__GetClientTokenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetClientTokenResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetClientTokenResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetClientTokenResponse;
		if (size)
			*size = sizeof(_ns1__GetClientTokenResponse);
		((_ns1__GetClientTokenResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetClientTokenResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetClientTokenResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetClientTokenResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetClientTokenResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetClientTokenResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetClientTokenResponse %p -> %p\n", q, p));
	*(_ns1__GetClientTokenResponse*)p = *(_ns1__GetClientTokenResponse*)q;
}

void _ns1__GetClientToken::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetClientToken::specification = NULL;
	/* transient soap skipped */
}

void _ns1__GetClientToken::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TokenSpecification(soap, &this->_ns1__GetClientToken::specification);
	/* transient soap skipped */
}

int _ns1__GetClientToken::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetClientToken);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetClientToken::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetClientToken(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetClientToken(struct soap *soap, const char *tag, int id, const _ns1__GetClientToken *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetClientToken), type))
		return soap->error;
	if (soap_out_PointerTons1__TokenSpecification(soap, "ns1:specification", -1, &(a->_ns1__GetClientToken::specification), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetClientToken::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetClientToken(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetClientToken * SOAP_FMAC4 soap_get__ns1__GetClientToken(struct soap *soap, _ns1__GetClientToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetClientToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetClientToken::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetClientToken(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetClientToken * SOAP_FMAC4 soap_in__ns1__GetClientToken(struct soap *soap, const char *tag, _ns1__GetClientToken *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetClientToken *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetClientToken, sizeof(_ns1__GetClientToken), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetClientToken)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetClientToken *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_specification1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_specification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TokenSpecification(soap, "ns1:specification", &(a->_ns1__GetClientToken::specification), "ns1:TokenSpecification"))
				{	soap_flag_specification1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetClientToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetClientToken, 0, sizeof(_ns1__GetClientToken), 0, soap_copy__ns1__GetClientToken);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetClientToken * SOAP_FMAC4 soap_instantiate__ns1__GetClientToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetClientToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetClientToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetClientToken;
		if (size)
			*size = sizeof(_ns1__GetClientToken);
		((_ns1__GetClientToken*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetClientToken[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetClientToken);
		for (int i = 0; i < n; i++)
			((_ns1__GetClientToken*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetClientToken*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetClientToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetClientToken %p -> %p\n", q, p));
	*(_ns1__GetClientToken*)p = *(_ns1__GetClientToken*)q;
}

void _ns1__GetGreatCircleDistancesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetGreatCircleDistancesResponse::GetGreatCircleDistancesResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetGreatCircleDistancesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfDouble(soap, &this->_ns1__GetGreatCircleDistancesResponse::GetGreatCircleDistancesResult);
	/* transient soap skipped */
}

int _ns1__GetGreatCircleDistancesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetGreatCircleDistancesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetGreatCircleDistancesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetGreatCircleDistancesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetGreatCircleDistancesResponse(struct soap *soap, const char *tag, int id, const _ns1__GetGreatCircleDistancesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetGreatCircleDistancesResponse), type))
		return soap->error;
	if (a->GetGreatCircleDistancesResult)
		soap_element_result(soap, "ns1:GetGreatCircleDistancesResult");
	if (soap_out_PointerTons1__ArrayOfDouble(soap, "ns1:GetGreatCircleDistancesResult", -1, &(a->_ns1__GetGreatCircleDistancesResponse::GetGreatCircleDistancesResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetGreatCircleDistancesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetGreatCircleDistancesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetGreatCircleDistancesResponse * SOAP_FMAC4 soap_get__ns1__GetGreatCircleDistancesResponse(struct soap *soap, _ns1__GetGreatCircleDistancesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetGreatCircleDistancesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetGreatCircleDistancesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetGreatCircleDistancesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetGreatCircleDistancesResponse * SOAP_FMAC4 soap_in__ns1__GetGreatCircleDistancesResponse(struct soap *soap, const char *tag, _ns1__GetGreatCircleDistancesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetGreatCircleDistancesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetGreatCircleDistancesResponse, sizeof(_ns1__GetGreatCircleDistancesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetGreatCircleDistancesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetGreatCircleDistancesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetGreatCircleDistancesResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetGreatCircleDistancesResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDouble(soap, "ns1:GetGreatCircleDistancesResult", &(a->_ns1__GetGreatCircleDistancesResponse::GetGreatCircleDistancesResult), "ns1:ArrayOfDouble"))
				{	soap_flag_GetGreatCircleDistancesResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetGreatCircleDistancesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetGreatCircleDistancesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetGreatCircleDistancesResponse, 0, sizeof(_ns1__GetGreatCircleDistancesResponse), 0, soap_copy__ns1__GetGreatCircleDistancesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetGreatCircleDistancesResponse * SOAP_FMAC4 soap_instantiate__ns1__GetGreatCircleDistancesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetGreatCircleDistancesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetGreatCircleDistancesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetGreatCircleDistancesResponse;
		if (size)
			*size = sizeof(_ns1__GetGreatCircleDistancesResponse);
		((_ns1__GetGreatCircleDistancesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetGreatCircleDistancesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetGreatCircleDistancesResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetGreatCircleDistancesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetGreatCircleDistancesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetGreatCircleDistancesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetGreatCircleDistancesResponse %p -> %p\n", q, p));
	*(_ns1__GetGreatCircleDistancesResponse*)p = *(_ns1__GetGreatCircleDistancesResponse*)q;
}

void _ns1__GetGreatCircleDistances::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetGreatCircleDistances::latLongs = NULL;
	/* transient soap skipped */
}

void _ns1__GetGreatCircleDistances::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfLatLong(soap, &this->_ns1__GetGreatCircleDistances::latLongs);
	/* transient soap skipped */
}

int _ns1__GetGreatCircleDistances::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetGreatCircleDistances);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetGreatCircleDistances::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetGreatCircleDistances(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetGreatCircleDistances(struct soap *soap, const char *tag, int id, const _ns1__GetGreatCircleDistances *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetGreatCircleDistances), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfLatLong(soap, "ns1:latLongs", -1, &(a->_ns1__GetGreatCircleDistances::latLongs), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetGreatCircleDistances::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetGreatCircleDistances(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetGreatCircleDistances * SOAP_FMAC4 soap_get__ns1__GetGreatCircleDistances(struct soap *soap, _ns1__GetGreatCircleDistances *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetGreatCircleDistances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetGreatCircleDistances::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetGreatCircleDistances(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetGreatCircleDistances * SOAP_FMAC4 soap_in__ns1__GetGreatCircleDistances(struct soap *soap, const char *tag, _ns1__GetGreatCircleDistances *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetGreatCircleDistances *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetGreatCircleDistances, sizeof(_ns1__GetGreatCircleDistances), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetGreatCircleDistances)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetGreatCircleDistances *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_latLongs1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_latLongs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfLatLong(soap, "ns1:latLongs", &(a->_ns1__GetGreatCircleDistances::latLongs), "ns1:ArrayOfLatLong"))
				{	soap_flag_latLongs1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetGreatCircleDistances *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetGreatCircleDistances, 0, sizeof(_ns1__GetGreatCircleDistances), 0, soap_copy__ns1__GetGreatCircleDistances);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetGreatCircleDistances * SOAP_FMAC4 soap_instantiate__ns1__GetGreatCircleDistances(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetGreatCircleDistances(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetGreatCircleDistances, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetGreatCircleDistances;
		if (size)
			*size = sizeof(_ns1__GetGreatCircleDistances);
		((_ns1__GetGreatCircleDistances*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetGreatCircleDistances[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetGreatCircleDistances);
		for (int i = 0; i < n; i++)
			((_ns1__GetGreatCircleDistances*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetGreatCircleDistances*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetGreatCircleDistances(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetGreatCircleDistances %p -> %p\n", q, p));
	*(_ns1__GetGreatCircleDistances*)p = *(_ns1__GetGreatCircleDistances*)q;
}

void _ns1__GetDataSourceInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetDataSourceInfoResponse::GetDataSourceInfoResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetDataSourceInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfDataSource(soap, &this->_ns1__GetDataSourceInfoResponse::GetDataSourceInfoResult);
	/* transient soap skipped */
}

int _ns1__GetDataSourceInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetDataSourceInfoResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetDataSourceInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDataSourceInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDataSourceInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDataSourceInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDataSourceInfoResponse), type))
		return soap->error;
	if (a->GetDataSourceInfoResult)
		soap_element_result(soap, "ns1:GetDataSourceInfoResult");
	if (soap_out_PointerTons1__ArrayOfDataSource(soap, "ns1:GetDataSourceInfoResult", -1, &(a->_ns1__GetDataSourceInfoResponse::GetDataSourceInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDataSourceInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDataSourceInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDataSourceInfoResponse * SOAP_FMAC4 soap_get__ns1__GetDataSourceInfoResponse(struct soap *soap, _ns1__GetDataSourceInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDataSourceInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetDataSourceInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDataSourceInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDataSourceInfoResponse * SOAP_FMAC4 soap_in__ns1__GetDataSourceInfoResponse(struct soap *soap, const char *tag, _ns1__GetDataSourceInfoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDataSourceInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDataSourceInfoResponse, sizeof(_ns1__GetDataSourceInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetDataSourceInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetDataSourceInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetDataSourceInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDataSourceInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDataSource(soap, "ns1:GetDataSourceInfoResult", &(a->_ns1__GetDataSourceInfoResponse::GetDataSourceInfoResult), "ns1:ArrayOfDataSource"))
				{	soap_flag_GetDataSourceInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetDataSourceInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDataSourceInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDataSourceInfoResponse, 0, sizeof(_ns1__GetDataSourceInfoResponse), 0, soap_copy__ns1__GetDataSourceInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetDataSourceInfoResponse * SOAP_FMAC4 soap_instantiate__ns1__GetDataSourceInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDataSourceInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetDataSourceInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetDataSourceInfoResponse;
		if (size)
			*size = sizeof(_ns1__GetDataSourceInfoResponse);
		((_ns1__GetDataSourceInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetDataSourceInfoResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetDataSourceInfoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetDataSourceInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetDataSourceInfoResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetDataSourceInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetDataSourceInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetDataSourceInfoResponse*)p = *(_ns1__GetDataSourceInfoResponse*)q;
}

void _ns1__GetDataSourceInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetDataSourceInfo::dataSourceNames = NULL;
	/* transient soap skipped */
}

void _ns1__GetDataSourceInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__GetDataSourceInfo::dataSourceNames);
	/* transient soap skipped */
}

int _ns1__GetDataSourceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetDataSourceInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetDataSourceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDataSourceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDataSourceInfo(struct soap *soap, const char *tag, int id, const _ns1__GetDataSourceInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDataSourceInfo), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:dataSourceNames", -1, &(a->_ns1__GetDataSourceInfo::dataSourceNames), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDataSourceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDataSourceInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDataSourceInfo * SOAP_FMAC4 soap_get__ns1__GetDataSourceInfo(struct soap *soap, _ns1__GetDataSourceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDataSourceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetDataSourceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDataSourceInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDataSourceInfo * SOAP_FMAC4 soap_in__ns1__GetDataSourceInfo(struct soap *soap, const char *tag, _ns1__GetDataSourceInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDataSourceInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDataSourceInfo, sizeof(_ns1__GetDataSourceInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetDataSourceInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetDataSourceInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_dataSourceNames1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dataSourceNames1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:dataSourceNames", &(a->_ns1__GetDataSourceInfo::dataSourceNames), "ns1:ArrayOfString"))
				{	soap_flag_dataSourceNames1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDataSourceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDataSourceInfo, 0, sizeof(_ns1__GetDataSourceInfo), 0, soap_copy__ns1__GetDataSourceInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetDataSourceInfo * SOAP_FMAC4 soap_instantiate__ns1__GetDataSourceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDataSourceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetDataSourceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetDataSourceInfo;
		if (size)
			*size = sizeof(_ns1__GetDataSourceInfo);
		((_ns1__GetDataSourceInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetDataSourceInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetDataSourceInfo);
		for (int i = 0; i < n; i++)
			((_ns1__GetDataSourceInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetDataSourceInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetDataSourceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetDataSourceInfo %p -> %p\n", q, p));
	*(_ns1__GetDataSourceInfo*)p = *(_ns1__GetDataSourceInfo*)q;
}

void _ns1__GetEntityTypesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetEntityTypesResponse::GetEntityTypesResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetEntityTypesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfEntityType(soap, &this->_ns1__GetEntityTypesResponse::GetEntityTypesResult);
	/* transient soap skipped */
}

int _ns1__GetEntityTypesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetEntityTypesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetEntityTypesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetEntityTypesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetEntityTypesResponse(struct soap *soap, const char *tag, int id, const _ns1__GetEntityTypesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetEntityTypesResponse), type))
		return soap->error;
	if (a->GetEntityTypesResult)
		soap_element_result(soap, "ns1:GetEntityTypesResult");
	if (soap_out_PointerTons1__ArrayOfEntityType(soap, "ns1:GetEntityTypesResult", -1, &(a->_ns1__GetEntityTypesResponse::GetEntityTypesResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetEntityTypesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetEntityTypesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetEntityTypesResponse * SOAP_FMAC4 soap_get__ns1__GetEntityTypesResponse(struct soap *soap, _ns1__GetEntityTypesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetEntityTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetEntityTypesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetEntityTypesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetEntityTypesResponse * SOAP_FMAC4 soap_in__ns1__GetEntityTypesResponse(struct soap *soap, const char *tag, _ns1__GetEntityTypesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetEntityTypesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetEntityTypesResponse, sizeof(_ns1__GetEntityTypesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetEntityTypesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetEntityTypesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetEntityTypesResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetEntityTypesResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfEntityType(soap, "ns1:GetEntityTypesResult", &(a->_ns1__GetEntityTypesResponse::GetEntityTypesResult), "ns1:ArrayOfEntityType"))
				{	soap_flag_GetEntityTypesResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetEntityTypesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetEntityTypesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetEntityTypesResponse, 0, sizeof(_ns1__GetEntityTypesResponse), 0, soap_copy__ns1__GetEntityTypesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetEntityTypesResponse * SOAP_FMAC4 soap_instantiate__ns1__GetEntityTypesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetEntityTypesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetEntityTypesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetEntityTypesResponse;
		if (size)
			*size = sizeof(_ns1__GetEntityTypesResponse);
		((_ns1__GetEntityTypesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetEntityTypesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetEntityTypesResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetEntityTypesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetEntityTypesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetEntityTypesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetEntityTypesResponse %p -> %p\n", q, p));
	*(_ns1__GetEntityTypesResponse*)p = *(_ns1__GetEntityTypesResponse*)q;
}

void _ns1__GetEntityTypes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetEntityTypes::dataSourceName);
	/* transient soap skipped */
}

void _ns1__GetEntityTypes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetEntityTypes::dataSourceName);
	/* transient soap skipped */
}

int _ns1__GetEntityTypes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetEntityTypes);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetEntityTypes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetEntityTypes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetEntityTypes(struct soap *soap, const char *tag, int id, const _ns1__GetEntityTypes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetEntityTypes), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dataSourceName", -1, &(a->_ns1__GetEntityTypes::dataSourceName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetEntityTypes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetEntityTypes(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetEntityTypes * SOAP_FMAC4 soap_get__ns1__GetEntityTypes(struct soap *soap, _ns1__GetEntityTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetEntityTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetEntityTypes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetEntityTypes(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetEntityTypes * SOAP_FMAC4 soap_in__ns1__GetEntityTypes(struct soap *soap, const char *tag, _ns1__GetEntityTypes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetEntityTypes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetEntityTypes, sizeof(_ns1__GetEntityTypes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetEntityTypes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetEntityTypes *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_dataSourceName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dataSourceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:dataSourceName", &(a->_ns1__GetEntityTypes::dataSourceName), "xsd:string"))
				{	soap_flag_dataSourceName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetEntityTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetEntityTypes, 0, sizeof(_ns1__GetEntityTypes), 0, soap_copy__ns1__GetEntityTypes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetEntityTypes * SOAP_FMAC4 soap_instantiate__ns1__GetEntityTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetEntityTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetEntityTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetEntityTypes;
		if (size)
			*size = sizeof(_ns1__GetEntityTypes);
		((_ns1__GetEntityTypes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetEntityTypes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetEntityTypes);
		for (int i = 0; i < n; i++)
			((_ns1__GetEntityTypes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetEntityTypes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetEntityTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetEntityTypes %p -> %p\n", q, p));
	*(_ns1__GetEntityTypes*)p = *(_ns1__GetEntityTypes*)q;
}

void _ns1__GetCountryRegionInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetCountryRegionInfoResponse::GetCountryRegionInfoResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetCountryRegionInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfCountryRegionInfo(soap, &this->_ns1__GetCountryRegionInfoResponse::GetCountryRegionInfoResult);
	/* transient soap skipped */
}

int _ns1__GetCountryRegionInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetCountryRegionInfoResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetCountryRegionInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetCountryRegionInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetCountryRegionInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetCountryRegionInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetCountryRegionInfoResponse), type))
		return soap->error;
	if (a->GetCountryRegionInfoResult)
		soap_element_result(soap, "ns1:GetCountryRegionInfoResult");
	if (soap_out_PointerTons1__ArrayOfCountryRegionInfo(soap, "ns1:GetCountryRegionInfoResult", -1, &(a->_ns1__GetCountryRegionInfoResponse::GetCountryRegionInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetCountryRegionInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetCountryRegionInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetCountryRegionInfoResponse * SOAP_FMAC4 soap_get__ns1__GetCountryRegionInfoResponse(struct soap *soap, _ns1__GetCountryRegionInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetCountryRegionInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetCountryRegionInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetCountryRegionInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetCountryRegionInfoResponse * SOAP_FMAC4 soap_in__ns1__GetCountryRegionInfoResponse(struct soap *soap, const char *tag, _ns1__GetCountryRegionInfoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetCountryRegionInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetCountryRegionInfoResponse, sizeof(_ns1__GetCountryRegionInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetCountryRegionInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetCountryRegionInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetCountryRegionInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetCountryRegionInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfCountryRegionInfo(soap, "ns1:GetCountryRegionInfoResult", &(a->_ns1__GetCountryRegionInfoResponse::GetCountryRegionInfoResult), "ns1:ArrayOfCountryRegionInfo"))
				{	soap_flag_GetCountryRegionInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetCountryRegionInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetCountryRegionInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetCountryRegionInfoResponse, 0, sizeof(_ns1__GetCountryRegionInfoResponse), 0, soap_copy__ns1__GetCountryRegionInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetCountryRegionInfoResponse * SOAP_FMAC4 soap_instantiate__ns1__GetCountryRegionInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetCountryRegionInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetCountryRegionInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetCountryRegionInfoResponse;
		if (size)
			*size = sizeof(_ns1__GetCountryRegionInfoResponse);
		((_ns1__GetCountryRegionInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetCountryRegionInfoResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetCountryRegionInfoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetCountryRegionInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetCountryRegionInfoResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetCountryRegionInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetCountryRegionInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetCountryRegionInfoResponse*)p = *(_ns1__GetCountryRegionInfoResponse*)q;
}

void _ns1__GetCountryRegionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetCountryRegionInfo::entityIDs = NULL;
	/* transient soap skipped */
}

void _ns1__GetCountryRegionInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfInt(soap, &this->_ns1__GetCountryRegionInfo::entityIDs);
	/* transient soap skipped */
}

int _ns1__GetCountryRegionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetCountryRegionInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetCountryRegionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetCountryRegionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetCountryRegionInfo(struct soap *soap, const char *tag, int id, const _ns1__GetCountryRegionInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetCountryRegionInfo), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfInt(soap, "ns1:entityIDs", -1, &(a->_ns1__GetCountryRegionInfo::entityIDs), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetCountryRegionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetCountryRegionInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetCountryRegionInfo * SOAP_FMAC4 soap_get__ns1__GetCountryRegionInfo(struct soap *soap, _ns1__GetCountryRegionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetCountryRegionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetCountryRegionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetCountryRegionInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetCountryRegionInfo * SOAP_FMAC4 soap_in__ns1__GetCountryRegionInfo(struct soap *soap, const char *tag, _ns1__GetCountryRegionInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetCountryRegionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetCountryRegionInfo, sizeof(_ns1__GetCountryRegionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetCountryRegionInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetCountryRegionInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityIDs1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityIDs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfInt(soap, "ns1:entityIDs", &(a->_ns1__GetCountryRegionInfo::entityIDs), "ns1:ArrayOfInt"))
				{	soap_flag_entityIDs1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetCountryRegionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetCountryRegionInfo, 0, sizeof(_ns1__GetCountryRegionInfo), 0, soap_copy__ns1__GetCountryRegionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetCountryRegionInfo * SOAP_FMAC4 soap_instantiate__ns1__GetCountryRegionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetCountryRegionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetCountryRegionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetCountryRegionInfo;
		if (size)
			*size = sizeof(_ns1__GetCountryRegionInfo);
		((_ns1__GetCountryRegionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetCountryRegionInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetCountryRegionInfo);
		for (int i = 0; i < n; i++)
			((_ns1__GetCountryRegionInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetCountryRegionInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetCountryRegionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetCountryRegionInfo %p -> %p\n", q, p));
	*(_ns1__GetCountryRegionInfo*)p = *(_ns1__GetCountryRegionInfo*)q;
}

void _ns1__GetVersionInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetVersionInfoResponse::GetVersionInfoResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetVersionInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfVersionInfo(soap, &this->_ns1__GetVersionInfoResponse::GetVersionInfoResult);
	/* transient soap skipped */
}

int _ns1__GetVersionInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetVersionInfoResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetVersionInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetVersionInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetVersionInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetVersionInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetVersionInfoResponse), type))
		return soap->error;
	if (a->GetVersionInfoResult)
		soap_element_result(soap, "ns1:GetVersionInfoResult");
	if (soap_out_PointerTons1__ArrayOfVersionInfo(soap, "ns1:GetVersionInfoResult", -1, &(a->_ns1__GetVersionInfoResponse::GetVersionInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetVersionInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetVersionInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetVersionInfoResponse * SOAP_FMAC4 soap_get__ns1__GetVersionInfoResponse(struct soap *soap, _ns1__GetVersionInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetVersionInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetVersionInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetVersionInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetVersionInfoResponse * SOAP_FMAC4 soap_in__ns1__GetVersionInfoResponse(struct soap *soap, const char *tag, _ns1__GetVersionInfoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetVersionInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetVersionInfoResponse, sizeof(_ns1__GetVersionInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetVersionInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetVersionInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetVersionInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetVersionInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfVersionInfo(soap, "ns1:GetVersionInfoResult", &(a->_ns1__GetVersionInfoResponse::GetVersionInfoResult), "ns1:ArrayOfVersionInfo"))
				{	soap_flag_GetVersionInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetVersionInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetVersionInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetVersionInfoResponse, 0, sizeof(_ns1__GetVersionInfoResponse), 0, soap_copy__ns1__GetVersionInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetVersionInfoResponse * SOAP_FMAC4 soap_instantiate__ns1__GetVersionInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetVersionInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetVersionInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetVersionInfoResponse;
		if (size)
			*size = sizeof(_ns1__GetVersionInfoResponse);
		((_ns1__GetVersionInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetVersionInfoResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetVersionInfoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetVersionInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetVersionInfoResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetVersionInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetVersionInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetVersionInfoResponse*)p = *(_ns1__GetVersionInfoResponse*)q;
}

void _ns1__GetVersionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetVersionInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__GetVersionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetVersionInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetVersionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetVersionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetVersionInfo(struct soap *soap, const char *tag, int id, const _ns1__GetVersionInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetVersionInfo), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetVersionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetVersionInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetVersionInfo * SOAP_FMAC4 soap_get__ns1__GetVersionInfo(struct soap *soap, _ns1__GetVersionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetVersionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetVersionInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetVersionInfo * SOAP_FMAC4 soap_in__ns1__GetVersionInfo(struct soap *soap, const char *tag, _ns1__GetVersionInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetVersionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetVersionInfo, sizeof(_ns1__GetVersionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetVersionInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetVersionInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetVersionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetVersionInfo, 0, sizeof(_ns1__GetVersionInfo), 0, soap_copy__ns1__GetVersionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetVersionInfo * SOAP_FMAC4 soap_instantiate__ns1__GetVersionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetVersionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetVersionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetVersionInfo;
		if (size)
			*size = sizeof(_ns1__GetVersionInfo);
		((_ns1__GetVersionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetVersionInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetVersionInfo);
		for (int i = 0; i < n; i++)
			((_ns1__GetVersionInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetVersionInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetVersionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetVersionInfo %p -> %p\n", q, p));
	*(_ns1__GetVersionInfo*)p = *(_ns1__GetVersionInfo*)q;
}

void ns1__TokenSpecification::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__TokenSpecification::ClientIPAddress);
	soap_default_int(soap, &this->ns1__TokenSpecification::TokenValidityDurationMinutes);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__TokenSpecification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__TokenSpecification::ClientIPAddress);
	soap_embedded(soap, &this->ns1__TokenSpecification::TokenValidityDurationMinutes, SOAP_TYPE_int);
	/* transient soap skipped */
}

int ns1__TokenSpecification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__TokenSpecification);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__TokenSpecification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TokenSpecification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TokenSpecification(struct soap *soap, const char *tag, int id, const ns1__TokenSpecification *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TokenSpecification), "ns1:TokenSpecification"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:ClientIPAddress", -1, &(a->ns1__TokenSpecification::ClientIPAddress), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:TokenValidityDurationMinutes", -1, &(a->ns1__TokenSpecification::TokenValidityDurationMinutes), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TokenSpecification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TokenSpecification(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TokenSpecification * SOAP_FMAC4 soap_get_ns1__TokenSpecification(struct soap *soap, ns1__TokenSpecification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TokenSpecification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__TokenSpecification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TokenSpecification(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TokenSpecification * SOAP_FMAC4 soap_in_ns1__TokenSpecification(struct soap *soap, const char *tag, ns1__TokenSpecification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TokenSpecification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TokenSpecification, sizeof(ns1__TokenSpecification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__TokenSpecification)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__TokenSpecification *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ClientIPAddress1 = 1;
	size_t soap_flag_TokenValidityDurationMinutes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ClientIPAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ClientIPAddress", &(a->ns1__TokenSpecification::ClientIPAddress), "xsd:string"))
				{	soap_flag_ClientIPAddress1--;
					continue;
				}
			if (soap_flag_TokenValidityDurationMinutes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:TokenValidityDurationMinutes", &(a->ns1__TokenSpecification::TokenValidityDurationMinutes), "xsd:int"))
				{	soap_flag_TokenValidityDurationMinutes1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TokenSpecification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TokenSpecification, 0, sizeof(ns1__TokenSpecification), 0, soap_copy_ns1__TokenSpecification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TokenValidityDurationMinutes1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__TokenSpecification * SOAP_FMAC4 soap_instantiate_ns1__TokenSpecification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TokenSpecification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TokenSpecification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__TokenSpecification;
		if (size)
			*size = sizeof(ns1__TokenSpecification);
		((ns1__TokenSpecification*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__TokenSpecification[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__TokenSpecification);
		for (int i = 0; i < n; i++)
			((ns1__TokenSpecification*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__TokenSpecification*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__TokenSpecification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__TokenSpecification %p -> %p\n", q, p));
	*(ns1__TokenSpecification*)p = *(ns1__TokenSpecification*)q;
}

void ns1__ArrayOfDouble::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfDouble::__sizedouble_ = 0;
	this->ns1__ArrayOfDouble::double_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfDouble::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfDouble::double_)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfDouble::__sizedouble_; i++)
		{
			soap_embedded(soap, this->ns1__ArrayOfDouble::double_ + i, SOAP_TYPE_double);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfDouble::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDouble);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfDouble::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfDouble(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDouble(struct soap *soap, const char *tag, int id, const ns1__ArrayOfDouble *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDouble), "ns1:ArrayOfDouble"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__ArrayOfDouble::double_)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfDouble::__sizedouble_; i++)
			if (soap_out_double(soap, "ns1:double", -1, a->ns1__ArrayOfDouble::double_ + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfDouble::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfDouble(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfDouble * SOAP_FMAC4 soap_get_ns1__ArrayOfDouble(struct soap *soap, ns1__ArrayOfDouble *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ArrayOfDouble::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfDouble(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfDouble * SOAP_FMAC4 soap_in_ns1__ArrayOfDouble(struct soap *soap, const char *tag, ns1__ArrayOfDouble *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfDouble *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDouble, sizeof(ns1__ArrayOfDouble), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfDouble)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfDouble *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_double_1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:double", 1, NULL))
			{	if (a->ns1__ArrayOfDouble::double_ == NULL)
				{	if (soap_blist_double_1 == NULL)
						soap_blist_double_1 = soap_new_block(soap);
					a->ns1__ArrayOfDouble::double_ = (double *)soap_push_block(soap, soap_blist_double_1, sizeof(double));
					if (a->ns1__ArrayOfDouble::double_ == NULL)
						return NULL;
					soap_default_double(soap, a->ns1__ArrayOfDouble::double_);
				}soap_revert(soap);
				if (soap_in_double(soap, "ns1:double", a->ns1__ArrayOfDouble::double_, "xsd:double"))
				{	a->ns1__ArrayOfDouble::__sizedouble_++;
					a->ns1__ArrayOfDouble::double_ = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfDouble::double_)
			soap_pop_block(soap, soap_blist_double_1);
		if (a->ns1__ArrayOfDouble::__sizedouble_)
			a->ns1__ArrayOfDouble::double_ = (double *)soap_save_block(soap, soap_blist_double_1, NULL, 1);
		else
		{	a->ns1__ArrayOfDouble::double_ = NULL;
			if (soap_blist_double_1)
				soap_end_block(soap, soap_blist_double_1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfDouble *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDouble, 0, sizeof(ns1__ArrayOfDouble), 0, soap_copy_ns1__ArrayOfDouble);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ArrayOfDouble * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfDouble(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfDouble(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfDouble, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfDouble;
		if (size)
			*size = sizeof(ns1__ArrayOfDouble);
		((ns1__ArrayOfDouble*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfDouble[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfDouble);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfDouble*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfDouble*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfDouble(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfDouble %p -> %p\n", q, p));
	*(ns1__ArrayOfDouble*)p = *(ns1__ArrayOfDouble*)q;
}

void ns1__ArrayOfLatLong::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfLatLong::__sizeLatLong = 0;
	this->ns1__ArrayOfLatLong::LatLong = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfLatLong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfLatLong::LatLong)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfLatLong::__sizeLatLong; i++)
		{
			soap_serialize_PointerTons1__LatLong(soap, this->ns1__ArrayOfLatLong::LatLong + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfLatLong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfLatLong);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfLatLong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfLatLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfLatLong(struct soap *soap, const char *tag, int id, const ns1__ArrayOfLatLong *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfLatLong), "ns1:ArrayOfLatLong"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__ArrayOfLatLong::LatLong)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfLatLong::__sizeLatLong; i++)
			if (soap_out_PointerTons1__LatLong(soap, "ns1:LatLong", -1, a->ns1__ArrayOfLatLong::LatLong + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfLatLong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfLatLong(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfLatLong * SOAP_FMAC4 soap_get_ns1__ArrayOfLatLong(struct soap *soap, ns1__ArrayOfLatLong *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfLatLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ArrayOfLatLong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfLatLong(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfLatLong * SOAP_FMAC4 soap_in_ns1__ArrayOfLatLong(struct soap *soap, const char *tag, ns1__ArrayOfLatLong *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfLatLong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfLatLong, sizeof(ns1__ArrayOfLatLong), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfLatLong)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfLatLong *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_LatLong1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:LatLong", 1, NULL))
			{	if (a->ns1__ArrayOfLatLong::LatLong == NULL)
				{	if (soap_blist_LatLong1 == NULL)
						soap_blist_LatLong1 = soap_new_block(soap);
					a->ns1__ArrayOfLatLong::LatLong = (ns1__LatLong **)soap_push_block(soap, soap_blist_LatLong1, sizeof(ns1__LatLong *));
					if (a->ns1__ArrayOfLatLong::LatLong == NULL)
						return NULL;
					*a->ns1__ArrayOfLatLong::LatLong = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons1__LatLong(soap, "ns1:LatLong", a->ns1__ArrayOfLatLong::LatLong, "ns1:LatLong"))
				{	a->ns1__ArrayOfLatLong::__sizeLatLong++;
					a->ns1__ArrayOfLatLong::LatLong = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfLatLong::LatLong)
			soap_pop_block(soap, soap_blist_LatLong1);
		if (a->ns1__ArrayOfLatLong::__sizeLatLong)
			a->ns1__ArrayOfLatLong::LatLong = (ns1__LatLong **)soap_save_block(soap, soap_blist_LatLong1, NULL, 1);
		else
		{	a->ns1__ArrayOfLatLong::LatLong = NULL;
			if (soap_blist_LatLong1)
				soap_end_block(soap, soap_blist_LatLong1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfLatLong *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfLatLong, 0, sizeof(ns1__ArrayOfLatLong), 0, soap_copy_ns1__ArrayOfLatLong);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ArrayOfLatLong * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfLatLong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfLatLong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfLatLong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfLatLong;
		if (size)
			*size = sizeof(ns1__ArrayOfLatLong);
		((ns1__ArrayOfLatLong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfLatLong[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfLatLong);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfLatLong*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfLatLong*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfLatLong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfLatLong %p -> %p\n", q, p));
	*(ns1__ArrayOfLatLong*)p = *(ns1__ArrayOfLatLong*)q;
}

void ns1__DataSource::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__DataSource::Name);
	soap_default_string(soap, &this->ns1__DataSource::Version);
	soap_default_string(soap, &this->ns1__DataSource::Description);
	soap_default_ns1__DataSourceCapability(soap, &this->ns1__DataSource::Capability);
	this->ns1__DataSource::EntityExtent = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__DataSource::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__DataSource::Name);
	soap_serialize_string(soap, &this->ns1__DataSource::Version);
	soap_serialize_string(soap, &this->ns1__DataSource::Description);
	soap_serialize_PointerTons1__ArrayOfInt(soap, &this->ns1__DataSource::EntityExtent);
	/* transient soap skipped */
}

int ns1__DataSource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DataSource);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__DataSource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DataSource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataSource(struct soap *soap, const char *tag, int id, const ns1__DataSource *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataSource), "ns1:DataSource"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:Name", -1, &(a->ns1__DataSource::Name), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Version", -1, &(a->ns1__DataSource::Version), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Description", -1, &(a->ns1__DataSource::Description), ""))
		return soap->error;
	if (soap_out_ns1__DataSourceCapability(soap, "ns1:Capability", -1, &(a->ns1__DataSource::Capability), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfInt(soap, "ns1:EntityExtent", -1, &(a->ns1__DataSource::EntityExtent), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DataSource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DataSource(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DataSource * SOAP_FMAC4 soap_get_ns1__DataSource(struct soap *soap, ns1__DataSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DataSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__DataSource::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DataSource(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DataSource * SOAP_FMAC4 soap_in_ns1__DataSource(struct soap *soap, const char *tag, ns1__DataSource *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DataSource *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataSource, sizeof(ns1__DataSource), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DataSource)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__DataSource *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Version1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_Capability1 = 1;
	size_t soap_flag_EntityExtent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Name", &(a->ns1__DataSource::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Version", &(a->ns1__DataSource::Version), "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Description", &(a->ns1__DataSource::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_Capability1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__DataSourceCapability(soap, "ns1:Capability", &(a->ns1__DataSource::Capability), "ns1:DataSourceCapability"))
				{	soap_flag_Capability1--;
					continue;
				}
			if (soap_flag_EntityExtent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfInt(soap, "ns1:EntityExtent", &(a->ns1__DataSource::EntityExtent), "ns1:ArrayOfInt"))
				{	soap_flag_EntityExtent1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DataSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataSource, 0, sizeof(ns1__DataSource), 0, soap_copy_ns1__DataSource);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capability1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__DataSource * SOAP_FMAC4 soap_instantiate_ns1__DataSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DataSource(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DataSource, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__DataSource;
		if (size)
			*size = sizeof(ns1__DataSource);
		((ns1__DataSource*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__DataSource[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DataSource);
		for (int i = 0; i < n; i++)
			((ns1__DataSource*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DataSource*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DataSource(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DataSource %p -> %p\n", q, p));
	*(ns1__DataSource*)p = *(ns1__DataSource*)q;
}

void ns1__ArrayOfDataSource::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfDataSource::__sizeDataSource = 0;
	this->ns1__ArrayOfDataSource::DataSource = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfDataSource::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfDataSource::DataSource)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfDataSource::__sizeDataSource; i++)
		{
			soap_serialize_PointerTons1__DataSource(soap, this->ns1__ArrayOfDataSource::DataSource + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfDataSource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDataSource);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfDataSource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfDataSource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDataSource(struct soap *soap, const char *tag, int id, const ns1__ArrayOfDataSource *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDataSource), "ns1:ArrayOfDataSource"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__ArrayOfDataSource::DataSource)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfDataSource::__sizeDataSource; i++)
			if (soap_out_PointerTons1__DataSource(soap, "ns1:DataSource", -1, a->ns1__ArrayOfDataSource::DataSource + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfDataSource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfDataSource(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfDataSource * SOAP_FMAC4 soap_get_ns1__ArrayOfDataSource(struct soap *soap, ns1__ArrayOfDataSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDataSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ArrayOfDataSource::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfDataSource(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfDataSource * SOAP_FMAC4 soap_in_ns1__ArrayOfDataSource(struct soap *soap, const char *tag, ns1__ArrayOfDataSource *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfDataSource *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDataSource, sizeof(ns1__ArrayOfDataSource), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfDataSource)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfDataSource *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_DataSource1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:DataSource", 1, NULL))
			{	if (a->ns1__ArrayOfDataSource::DataSource == NULL)
				{	if (soap_blist_DataSource1 == NULL)
						soap_blist_DataSource1 = soap_new_block(soap);
					a->ns1__ArrayOfDataSource::DataSource = (ns1__DataSource **)soap_push_block(soap, soap_blist_DataSource1, sizeof(ns1__DataSource *));
					if (a->ns1__ArrayOfDataSource::DataSource == NULL)
						return NULL;
					*a->ns1__ArrayOfDataSource::DataSource = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons1__DataSource(soap, "ns1:DataSource", a->ns1__ArrayOfDataSource::DataSource, "ns1:DataSource"))
				{	a->ns1__ArrayOfDataSource::__sizeDataSource++;
					a->ns1__ArrayOfDataSource::DataSource = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfDataSource::DataSource)
			soap_pop_block(soap, soap_blist_DataSource1);
		if (a->ns1__ArrayOfDataSource::__sizeDataSource)
			a->ns1__ArrayOfDataSource::DataSource = (ns1__DataSource **)soap_save_block(soap, soap_blist_DataSource1, NULL, 1);
		else
		{	a->ns1__ArrayOfDataSource::DataSource = NULL;
			if (soap_blist_DataSource1)
				soap_end_block(soap, soap_blist_DataSource1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfDataSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDataSource, 0, sizeof(ns1__ArrayOfDataSource), 0, soap_copy_ns1__ArrayOfDataSource);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ArrayOfDataSource * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfDataSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfDataSource(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfDataSource, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfDataSource;
		if (size)
			*size = sizeof(ns1__ArrayOfDataSource);
		((ns1__ArrayOfDataSource*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfDataSource[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfDataSource);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfDataSource*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfDataSource*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfDataSource(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfDataSource %p -> %p\n", q, p));
	*(ns1__ArrayOfDataSource*)p = *(ns1__ArrayOfDataSource*)q;
}

void ns1__ArrayOfString::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfString::__sizestring = 0;
	this->ns1__ArrayOfString::string = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfString::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfString::string)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfString::__sizestring; i++)
		{
			soap_serialize_string(soap, this->ns1__ArrayOfString::string + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfString);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfString(struct soap *soap, const char *tag, int id, const ns1__ArrayOfString *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfString), "ns1:ArrayOfString"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__ArrayOfString::string)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfString::__sizestring; i++)
			if (soap_out_string(soap, "ns1:string", -1, a->ns1__ArrayOfString::string + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfString(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_get_ns1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ArrayOfString::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfString(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_in_ns1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfString)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfString *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_string1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:string", 1, NULL))
			{	if (a->ns1__ArrayOfString::string == NULL)
				{	if (soap_blist_string1 == NULL)
						soap_blist_string1 = soap_new_block(soap);
					a->ns1__ArrayOfString::string = (char **)soap_push_block(soap, soap_blist_string1, sizeof(char *));
					if (a->ns1__ArrayOfString::string == NULL)
						return NULL;
					*a->ns1__ArrayOfString::string = NULL;
				}soap_revert(soap);
				if (soap_in_string(soap, "ns1:string", a->ns1__ArrayOfString::string, "xsd:string"))
				{	a->ns1__ArrayOfString::__sizestring++;
					a->ns1__ArrayOfString::string = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfString::string)
			soap_pop_block(soap, soap_blist_string1);
		if (a->ns1__ArrayOfString::__sizestring)
			a->ns1__ArrayOfString::string = (char **)soap_save_block(soap, soap_blist_string1, NULL, 1);
		else
		{	a->ns1__ArrayOfString::string = NULL;
			if (soap_blist_string1)
				soap_end_block(soap, soap_blist_string1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfString, 0, sizeof(ns1__ArrayOfString), 0, soap_copy_ns1__ArrayOfString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfString;
		if (size)
			*size = sizeof(ns1__ArrayOfString);
		((ns1__ArrayOfString*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfString[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfString);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfString*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfString*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfString %p -> %p\n", q, p));
	*(ns1__ArrayOfString*)p = *(ns1__ArrayOfString*)q;
}

void ns1__EntityProperty::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__EntityProperty::Name);
	soap_default_string(soap, &this->ns1__EntityProperty::DisplayName);
	soap_default_string(soap, &this->ns1__EntityProperty::DataType);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__EntityProperty::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__EntityProperty::Name);
	soap_serialize_string(soap, &this->ns1__EntityProperty::DisplayName);
	soap_serialize_string(soap, &this->ns1__EntityProperty::DataType);
	/* transient soap skipped */
}

int ns1__EntityProperty::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__EntityProperty);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__EntityProperty::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EntityProperty(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EntityProperty(struct soap *soap, const char *tag, int id, const ns1__EntityProperty *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EntityProperty), "ns1:EntityProperty"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:Name", -1, &(a->ns1__EntityProperty::Name), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DisplayName", -1, &(a->ns1__EntityProperty::DisplayName), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DataType", -1, &(a->ns1__EntityProperty::DataType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__EntityProperty::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EntityProperty(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EntityProperty * SOAP_FMAC4 soap_get_ns1__EntityProperty(struct soap *soap, ns1__EntityProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EntityProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__EntityProperty::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__EntityProperty(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EntityProperty * SOAP_FMAC4 soap_in_ns1__EntityProperty(struct soap *soap, const char *tag, ns1__EntityProperty *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EntityProperty *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EntityProperty, sizeof(ns1__EntityProperty), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__EntityProperty)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__EntityProperty *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_DisplayName1 = 1;
	size_t soap_flag_DataType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Name", &(a->ns1__EntityProperty::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_DisplayName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DisplayName", &(a->ns1__EntityProperty::DisplayName), "xsd:string"))
				{	soap_flag_DisplayName1--;
					continue;
				}
			if (soap_flag_DataType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DataType", &(a->ns1__EntityProperty::DataType), "xsd:string"))
				{	soap_flag_DataType1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__EntityProperty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EntityProperty, 0, sizeof(ns1__EntityProperty), 0, soap_copy_ns1__EntityProperty);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__EntityProperty * SOAP_FMAC4 soap_instantiate_ns1__EntityProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EntityProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__EntityProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__EntityProperty;
		if (size)
			*size = sizeof(ns1__EntityProperty);
		((ns1__EntityProperty*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__EntityProperty[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__EntityProperty);
		for (int i = 0; i < n; i++)
			((ns1__EntityProperty*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__EntityProperty*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__EntityProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__EntityProperty %p -> %p\n", q, p));
	*(ns1__EntityProperty*)p = *(ns1__EntityProperty*)q;
}

void ns1__ArrayOfEntityProperty::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfEntityProperty::__sizeProperty = 0;
	this->ns1__ArrayOfEntityProperty::Property = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfEntityProperty::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfEntityProperty::Property)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfEntityProperty::__sizeProperty; i++)
		{
			soap_serialize_PointerTons1__EntityProperty(soap, this->ns1__ArrayOfEntityProperty::Property + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfEntityProperty::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfEntityProperty);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfEntityProperty::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfEntityProperty(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfEntityProperty(struct soap *soap, const char *tag, int id, const ns1__ArrayOfEntityProperty *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfEntityProperty), "ns1:ArrayOfEntityProperty"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__ArrayOfEntityProperty::Property)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfEntityProperty::__sizeProperty; i++)
			if (soap_out_PointerTons1__EntityProperty(soap, "ns1:Property", -1, a->ns1__ArrayOfEntityProperty::Property + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfEntityProperty::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfEntityProperty(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfEntityProperty * SOAP_FMAC4 soap_get_ns1__ArrayOfEntityProperty(struct soap *soap, ns1__ArrayOfEntityProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfEntityProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ArrayOfEntityProperty::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfEntityProperty(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfEntityProperty * SOAP_FMAC4 soap_in_ns1__ArrayOfEntityProperty(struct soap *soap, const char *tag, ns1__ArrayOfEntityProperty *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfEntityProperty *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfEntityProperty, sizeof(ns1__ArrayOfEntityProperty), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfEntityProperty)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfEntityProperty *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_Property1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Property", 1, NULL))
			{	if (a->ns1__ArrayOfEntityProperty::Property == NULL)
				{	if (soap_blist_Property1 == NULL)
						soap_blist_Property1 = soap_new_block(soap);
					a->ns1__ArrayOfEntityProperty::Property = (ns1__EntityProperty **)soap_push_block(soap, soap_blist_Property1, sizeof(ns1__EntityProperty *));
					if (a->ns1__ArrayOfEntityProperty::Property == NULL)
						return NULL;
					*a->ns1__ArrayOfEntityProperty::Property = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons1__EntityProperty(soap, "ns1:Property", a->ns1__ArrayOfEntityProperty::Property, "ns1:EntityProperty"))
				{	a->ns1__ArrayOfEntityProperty::__sizeProperty++;
					a->ns1__ArrayOfEntityProperty::Property = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfEntityProperty::Property)
			soap_pop_block(soap, soap_blist_Property1);
		if (a->ns1__ArrayOfEntityProperty::__sizeProperty)
			a->ns1__ArrayOfEntityProperty::Property = (ns1__EntityProperty **)soap_save_block(soap, soap_blist_Property1, NULL, 1);
		else
		{	a->ns1__ArrayOfEntityProperty::Property = NULL;
			if (soap_blist_Property1)
				soap_end_block(soap, soap_blist_Property1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfEntityProperty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfEntityProperty, 0, sizeof(ns1__ArrayOfEntityProperty), 0, soap_copy_ns1__ArrayOfEntityProperty);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ArrayOfEntityProperty * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfEntityProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfEntityProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfEntityProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfEntityProperty;
		if (size)
			*size = sizeof(ns1__ArrayOfEntityProperty);
		((ns1__ArrayOfEntityProperty*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfEntityProperty[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfEntityProperty);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfEntityProperty*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfEntityProperty*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfEntityProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfEntityProperty %p -> %p\n", q, p));
	*(ns1__ArrayOfEntityProperty*)p = *(ns1__ArrayOfEntityProperty*)q;
}

void ns1__EntityType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__EntityType::Name);
	soap_default_string(soap, &this->ns1__EntityType::DisplayName);
	soap_default_string(soap, &this->ns1__EntityType::ParentName);
	soap_default_string(soap, &this->ns1__EntityType::Definition);
	this->ns1__EntityType::Properties = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__EntityType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__EntityType::Name);
	soap_serialize_string(soap, &this->ns1__EntityType::DisplayName);
	soap_serialize_string(soap, &this->ns1__EntityType::ParentName);
	soap_serialize_string(soap, &this->ns1__EntityType::Definition);
	soap_serialize_PointerTons1__ArrayOfEntityProperty(soap, &this->ns1__EntityType::Properties);
	/* transient soap skipped */
}

int ns1__EntityType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__EntityType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__EntityType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EntityType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EntityType(struct soap *soap, const char *tag, int id, const ns1__EntityType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EntityType), "ns1:EntityType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:Name", -1, &(a->ns1__EntityType::Name), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DisplayName", -1, &(a->ns1__EntityType::DisplayName), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ParentName", -1, &(a->ns1__EntityType::ParentName), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Definition", -1, &(a->ns1__EntityType::Definition), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfEntityProperty(soap, "ns1:Properties", -1, &(a->ns1__EntityType::Properties), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__EntityType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EntityType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EntityType * SOAP_FMAC4 soap_get_ns1__EntityType(struct soap *soap, ns1__EntityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EntityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__EntityType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__EntityType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EntityType * SOAP_FMAC4 soap_in_ns1__EntityType(struct soap *soap, const char *tag, ns1__EntityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EntityType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EntityType, sizeof(ns1__EntityType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__EntityType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__EntityType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_DisplayName1 = 1;
	size_t soap_flag_ParentName1 = 1;
	size_t soap_flag_Definition1 = 1;
	size_t soap_flag_Properties1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Name", &(a->ns1__EntityType::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_DisplayName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DisplayName", &(a->ns1__EntityType::DisplayName), "xsd:string"))
				{	soap_flag_DisplayName1--;
					continue;
				}
			if (soap_flag_ParentName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ParentName", &(a->ns1__EntityType::ParentName), "xsd:string"))
				{	soap_flag_ParentName1--;
					continue;
				}
			if (soap_flag_Definition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Definition", &(a->ns1__EntityType::Definition), "xsd:string"))
				{	soap_flag_Definition1--;
					continue;
				}
			if (soap_flag_Properties1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfEntityProperty(soap, "ns1:Properties", &(a->ns1__EntityType::Properties), "ns1:ArrayOfEntityProperty"))
				{	soap_flag_Properties1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__EntityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EntityType, 0, sizeof(ns1__EntityType), 0, soap_copy_ns1__EntityType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__EntityType * SOAP_FMAC4 soap_instantiate_ns1__EntityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EntityType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__EntityType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__EntityType;
		if (size)
			*size = sizeof(ns1__EntityType);
		((ns1__EntityType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__EntityType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__EntityType);
		for (int i = 0; i < n; i++)
			((ns1__EntityType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__EntityType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__EntityType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__EntityType %p -> %p\n", q, p));
	*(ns1__EntityType*)p = *(ns1__EntityType*)q;
}

void ns1__ArrayOfEntityType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfEntityType::__sizeEntityType = 0;
	this->ns1__ArrayOfEntityType::EntityType = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfEntityType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfEntityType::EntityType)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfEntityType::__sizeEntityType; i++)
		{
			soap_serialize_PointerTons1__EntityType(soap, this->ns1__ArrayOfEntityType::EntityType + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfEntityType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfEntityType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfEntityType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfEntityType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfEntityType(struct soap *soap, const char *tag, int id, const ns1__ArrayOfEntityType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfEntityType), "ns1:ArrayOfEntityType"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__ArrayOfEntityType::EntityType)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfEntityType::__sizeEntityType; i++)
			if (soap_out_PointerTons1__EntityType(soap, "ns1:EntityType", -1, a->ns1__ArrayOfEntityType::EntityType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfEntityType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfEntityType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfEntityType * SOAP_FMAC4 soap_get_ns1__ArrayOfEntityType(struct soap *soap, ns1__ArrayOfEntityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfEntityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ArrayOfEntityType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfEntityType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfEntityType * SOAP_FMAC4 soap_in_ns1__ArrayOfEntityType(struct soap *soap, const char *tag, ns1__ArrayOfEntityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfEntityType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfEntityType, sizeof(ns1__ArrayOfEntityType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfEntityType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfEntityType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_EntityType1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:EntityType", 1, NULL))
			{	if (a->ns1__ArrayOfEntityType::EntityType == NULL)
				{	if (soap_blist_EntityType1 == NULL)
						soap_blist_EntityType1 = soap_new_block(soap);
					a->ns1__ArrayOfEntityType::EntityType = (ns1__EntityType **)soap_push_block(soap, soap_blist_EntityType1, sizeof(ns1__EntityType *));
					if (a->ns1__ArrayOfEntityType::EntityType == NULL)
						return NULL;
					*a->ns1__ArrayOfEntityType::EntityType = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons1__EntityType(soap, "ns1:EntityType", a->ns1__ArrayOfEntityType::EntityType, "ns1:EntityType"))
				{	a->ns1__ArrayOfEntityType::__sizeEntityType++;
					a->ns1__ArrayOfEntityType::EntityType = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfEntityType::EntityType)
			soap_pop_block(soap, soap_blist_EntityType1);
		if (a->ns1__ArrayOfEntityType::__sizeEntityType)
			a->ns1__ArrayOfEntityType::EntityType = (ns1__EntityType **)soap_save_block(soap, soap_blist_EntityType1, NULL, 1);
		else
		{	a->ns1__ArrayOfEntityType::EntityType = NULL;
			if (soap_blist_EntityType1)
				soap_end_block(soap, soap_blist_EntityType1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfEntityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfEntityType, 0, sizeof(ns1__ArrayOfEntityType), 0, soap_copy_ns1__ArrayOfEntityType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ArrayOfEntityType * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfEntityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfEntityType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfEntityType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfEntityType;
		if (size)
			*size = sizeof(ns1__ArrayOfEntityType);
		((ns1__ArrayOfEntityType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfEntityType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfEntityType);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfEntityType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfEntityType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfEntityType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfEntityType %p -> %p\n", q, p));
	*(ns1__ArrayOfEntityType*)p = *(ns1__ArrayOfEntityType*)q;
}

void ns1__LatLong::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__LatLong::Latitude = 0.000000;
	this->ns1__LatLong::Longitude = 0.000000;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__LatLong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__LatLong::Latitude, SOAP_TYPE_double);
	soap_embedded(soap, &this->ns1__LatLong::Longitude, SOAP_TYPE_double);
	/* transient soap skipped */
}

int ns1__LatLong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__LatLong);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__LatLong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LatLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LatLong(struct soap *soap, const char *tag, int id, const ns1__LatLong *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LatLong), "ns1:LatLong"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_double(soap, "ns1:Latitude", -1, &(a->ns1__LatLong::Latitude), ""))
		return soap->error;
	if (soap_out_double(soap, "ns1:Longitude", -1, &(a->ns1__LatLong::Longitude), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__LatLong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LatLong(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LatLong * SOAP_FMAC4 soap_get_ns1__LatLong(struct soap *soap, ns1__LatLong *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LatLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__LatLong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LatLong(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LatLong * SOAP_FMAC4 soap_in_ns1__LatLong(struct soap *soap, const char *tag, ns1__LatLong *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LatLong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LatLong, sizeof(ns1__LatLong), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__LatLong)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__LatLong *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Latitude1 = 1;
	size_t soap_flag_Longitude1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Latitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:Latitude", &(a->ns1__LatLong::Latitude), "xsd:double"))
				{	soap_flag_Latitude1--;
					continue;
				}
			if (soap_flag_Longitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:Longitude", &(a->ns1__LatLong::Longitude), "xsd:double"))
				{	soap_flag_Longitude1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__LatLong *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LatLong, 0, sizeof(ns1__LatLong), 0, soap_copy_ns1__LatLong);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__LatLong * SOAP_FMAC4 soap_instantiate_ns1__LatLong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LatLong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__LatLong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__LatLong;
		if (size)
			*size = sizeof(ns1__LatLong);
		((ns1__LatLong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__LatLong[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__LatLong);
		for (int i = 0; i < n; i++)
			((ns1__LatLong*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__LatLong*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__LatLong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__LatLong %p -> %p\n", q, p));
	*(ns1__LatLong*)p = *(ns1__LatLong*)q;
}

void ns1__CountryRegionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__CountryRegionInfo::EntityID);
	this->ns1__CountryRegionInfo::LatLong = NULL;
	soap_default_string(soap, &this->ns1__CountryRegionInfo::Iso2);
	soap_default_string(soap, &this->ns1__CountryRegionInfo::Iso3);
	soap_default_string(soap, &this->ns1__CountryRegionInfo::FriendlyName);
	soap_default_string(soap, &this->ns1__CountryRegionInfo::OfficialName);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__CountryRegionInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CountryRegionInfo::EntityID, SOAP_TYPE_int);
	soap_serialize_PointerTons1__LatLong(soap, &this->ns1__CountryRegionInfo::LatLong);
	soap_serialize_string(soap, &this->ns1__CountryRegionInfo::Iso2);
	soap_serialize_string(soap, &this->ns1__CountryRegionInfo::Iso3);
	soap_serialize_string(soap, &this->ns1__CountryRegionInfo::FriendlyName);
	soap_serialize_string(soap, &this->ns1__CountryRegionInfo::OfficialName);
	/* transient soap skipped */
}

int ns1__CountryRegionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CountryRegionInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CountryRegionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CountryRegionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CountryRegionInfo(struct soap *soap, const char *tag, int id, const ns1__CountryRegionInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CountryRegionInfo), "ns1:CountryRegionInfo"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "ns1:EntityID", -1, &(a->ns1__CountryRegionInfo::EntityID), ""))
		return soap->error;
	if (soap_out_PointerTons1__LatLong(soap, "ns1:LatLong", -1, &(a->ns1__CountryRegionInfo::LatLong), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Iso2", -1, &(a->ns1__CountryRegionInfo::Iso2), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Iso3", -1, &(a->ns1__CountryRegionInfo::Iso3), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:FriendlyName", -1, &(a->ns1__CountryRegionInfo::FriendlyName), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:OfficialName", -1, &(a->ns1__CountryRegionInfo::OfficialName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CountryRegionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CountryRegionInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CountryRegionInfo * SOAP_FMAC4 soap_get_ns1__CountryRegionInfo(struct soap *soap, ns1__CountryRegionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CountryRegionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__CountryRegionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CountryRegionInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CountryRegionInfo * SOAP_FMAC4 soap_in_ns1__CountryRegionInfo(struct soap *soap, const char *tag, ns1__CountryRegionInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CountryRegionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CountryRegionInfo, sizeof(ns1__CountryRegionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CountryRegionInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CountryRegionInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_EntityID1 = 1;
	size_t soap_flag_LatLong1 = 1;
	size_t soap_flag_Iso21 = 1;
	size_t soap_flag_Iso31 = 1;
	size_t soap_flag_FriendlyName1 = 1;
	size_t soap_flag_OfficialName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_EntityID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:EntityID", &(a->ns1__CountryRegionInfo::EntityID), "xsd:int"))
				{	soap_flag_EntityID1--;
					continue;
				}
			if (soap_flag_LatLong1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__LatLong(soap, "ns1:LatLong", &(a->ns1__CountryRegionInfo::LatLong), "ns1:LatLong"))
				{	soap_flag_LatLong1--;
					continue;
				}
			if (soap_flag_Iso21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Iso2", &(a->ns1__CountryRegionInfo::Iso2), "xsd:string"))
				{	soap_flag_Iso21--;
					continue;
				}
			if (soap_flag_Iso31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Iso3", &(a->ns1__CountryRegionInfo::Iso3), "xsd:string"))
				{	soap_flag_Iso31--;
					continue;
				}
			if (soap_flag_FriendlyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:FriendlyName", &(a->ns1__CountryRegionInfo::FriendlyName), "xsd:string"))
				{	soap_flag_FriendlyName1--;
					continue;
				}
			if (soap_flag_OfficialName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:OfficialName", &(a->ns1__CountryRegionInfo::OfficialName), "xsd:string"))
				{	soap_flag_OfficialName1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CountryRegionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CountryRegionInfo, 0, sizeof(ns1__CountryRegionInfo), 0, soap_copy_ns1__CountryRegionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EntityID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__CountryRegionInfo * SOAP_FMAC4 soap_instantiate_ns1__CountryRegionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CountryRegionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CountryRegionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CountryRegionInfo;
		if (size)
			*size = sizeof(ns1__CountryRegionInfo);
		((ns1__CountryRegionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CountryRegionInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CountryRegionInfo);
		for (int i = 0; i < n; i++)
			((ns1__CountryRegionInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CountryRegionInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CountryRegionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CountryRegionInfo %p -> %p\n", q, p));
	*(ns1__CountryRegionInfo*)p = *(ns1__CountryRegionInfo*)q;
}

void ns1__ArrayOfCountryRegionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfCountryRegionInfo::__sizeCountryRegionInfo = 0;
	this->ns1__ArrayOfCountryRegionInfo::CountryRegionInfo = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfCountryRegionInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfCountryRegionInfo::CountryRegionInfo)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfCountryRegionInfo::__sizeCountryRegionInfo; i++)
		{
			soap_serialize_PointerTons1__CountryRegionInfo(soap, this->ns1__ArrayOfCountryRegionInfo::CountryRegionInfo + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfCountryRegionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfCountryRegionInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfCountryRegionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfCountryRegionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfCountryRegionInfo(struct soap *soap, const char *tag, int id, const ns1__ArrayOfCountryRegionInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfCountryRegionInfo), "ns1:ArrayOfCountryRegionInfo"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__ArrayOfCountryRegionInfo::CountryRegionInfo)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfCountryRegionInfo::__sizeCountryRegionInfo; i++)
			if (soap_out_PointerTons1__CountryRegionInfo(soap, "ns1:CountryRegionInfo", -1, a->ns1__ArrayOfCountryRegionInfo::CountryRegionInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfCountryRegionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfCountryRegionInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfCountryRegionInfo * SOAP_FMAC4 soap_get_ns1__ArrayOfCountryRegionInfo(struct soap *soap, ns1__ArrayOfCountryRegionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfCountryRegionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ArrayOfCountryRegionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfCountryRegionInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfCountryRegionInfo * SOAP_FMAC4 soap_in_ns1__ArrayOfCountryRegionInfo(struct soap *soap, const char *tag, ns1__ArrayOfCountryRegionInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfCountryRegionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfCountryRegionInfo, sizeof(ns1__ArrayOfCountryRegionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfCountryRegionInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfCountryRegionInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_CountryRegionInfo1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:CountryRegionInfo", 1, NULL))
			{	if (a->ns1__ArrayOfCountryRegionInfo::CountryRegionInfo == NULL)
				{	if (soap_blist_CountryRegionInfo1 == NULL)
						soap_blist_CountryRegionInfo1 = soap_new_block(soap);
					a->ns1__ArrayOfCountryRegionInfo::CountryRegionInfo = (ns1__CountryRegionInfo **)soap_push_block(soap, soap_blist_CountryRegionInfo1, sizeof(ns1__CountryRegionInfo *));
					if (a->ns1__ArrayOfCountryRegionInfo::CountryRegionInfo == NULL)
						return NULL;
					*a->ns1__ArrayOfCountryRegionInfo::CountryRegionInfo = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons1__CountryRegionInfo(soap, "ns1:CountryRegionInfo", a->ns1__ArrayOfCountryRegionInfo::CountryRegionInfo, "ns1:CountryRegionInfo"))
				{	a->ns1__ArrayOfCountryRegionInfo::__sizeCountryRegionInfo++;
					a->ns1__ArrayOfCountryRegionInfo::CountryRegionInfo = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfCountryRegionInfo::CountryRegionInfo)
			soap_pop_block(soap, soap_blist_CountryRegionInfo1);
		if (a->ns1__ArrayOfCountryRegionInfo::__sizeCountryRegionInfo)
			a->ns1__ArrayOfCountryRegionInfo::CountryRegionInfo = (ns1__CountryRegionInfo **)soap_save_block(soap, soap_blist_CountryRegionInfo1, NULL, 1);
		else
		{	a->ns1__ArrayOfCountryRegionInfo::CountryRegionInfo = NULL;
			if (soap_blist_CountryRegionInfo1)
				soap_end_block(soap, soap_blist_CountryRegionInfo1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfCountryRegionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfCountryRegionInfo, 0, sizeof(ns1__ArrayOfCountryRegionInfo), 0, soap_copy_ns1__ArrayOfCountryRegionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ArrayOfCountryRegionInfo * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfCountryRegionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfCountryRegionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfCountryRegionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfCountryRegionInfo;
		if (size)
			*size = sizeof(ns1__ArrayOfCountryRegionInfo);
		((ns1__ArrayOfCountryRegionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfCountryRegionInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfCountryRegionInfo);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfCountryRegionInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfCountryRegionInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfCountryRegionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfCountryRegionInfo %p -> %p\n", q, p));
	*(ns1__ArrayOfCountryRegionInfo*)p = *(ns1__ArrayOfCountryRegionInfo*)q;
}

void ns1__ArrayOfInt::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfInt::__sizeint_ = 0;
	this->ns1__ArrayOfInt::int_ = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfInt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfInt::int_)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfInt::__sizeint_; i++)
		{
			soap_embedded(soap, this->ns1__ArrayOfInt::int_ + i, SOAP_TYPE_int);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfInt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfInt);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfInt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfInt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfInt(struct soap *soap, const char *tag, int id, const ns1__ArrayOfInt *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfInt), "ns1:ArrayOfInt"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__ArrayOfInt::int_)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfInt::__sizeint_; i++)
			if (soap_out_int(soap, "ns1:int", -1, a->ns1__ArrayOfInt::int_ + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfInt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfInt(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfInt * SOAP_FMAC4 soap_get_ns1__ArrayOfInt(struct soap *soap, ns1__ArrayOfInt *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ArrayOfInt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfInt(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfInt * SOAP_FMAC4 soap_in_ns1__ArrayOfInt(struct soap *soap, const char *tag, ns1__ArrayOfInt *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfInt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfInt, sizeof(ns1__ArrayOfInt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfInt)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfInt *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_int_1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:int", 1, NULL))
			{	if (a->ns1__ArrayOfInt::int_ == NULL)
				{	if (soap_blist_int_1 == NULL)
						soap_blist_int_1 = soap_new_block(soap);
					a->ns1__ArrayOfInt::int_ = (int *)soap_push_block(soap, soap_blist_int_1, sizeof(int));
					if (a->ns1__ArrayOfInt::int_ == NULL)
						return NULL;
					soap_default_int(soap, a->ns1__ArrayOfInt::int_);
				}soap_revert(soap);
				if (soap_in_int(soap, "ns1:int", a->ns1__ArrayOfInt::int_, "xsd:int"))
				{	a->ns1__ArrayOfInt::__sizeint_++;
					a->ns1__ArrayOfInt::int_ = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfInt::int_)
			soap_pop_block(soap, soap_blist_int_1);
		if (a->ns1__ArrayOfInt::__sizeint_)
			a->ns1__ArrayOfInt::int_ = (int *)soap_save_block(soap, soap_blist_int_1, NULL, 1);
		else
		{	a->ns1__ArrayOfInt::int_ = NULL;
			if (soap_blist_int_1)
				soap_end_block(soap, soap_blist_int_1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfInt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfInt, 0, sizeof(ns1__ArrayOfInt), 0, soap_copy_ns1__ArrayOfInt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ArrayOfInt * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfInt;
		if (size)
			*size = sizeof(ns1__ArrayOfInt);
		((ns1__ArrayOfInt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfInt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfInt);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfInt*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfInt*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfInt %p -> %p\n", q, p));
	*(ns1__ArrayOfInt*)p = *(ns1__ArrayOfInt*)q;
}

void ns1__CountryRegionContext::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CountryRegionContext::EntityID = 0;
	soap_default_string(soap, &this->ns1__CountryRegionContext::Iso2);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__CountryRegionContext::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CountryRegionContext::EntityID, SOAP_TYPE_int);
	soap_serialize_string(soap, &this->ns1__CountryRegionContext::Iso2);
	/* transient soap skipped */
}

int ns1__CountryRegionContext::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CountryRegionContext);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CountryRegionContext::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CountryRegionContext(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CountryRegionContext(struct soap *soap, const char *tag, int id, const ns1__CountryRegionContext *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CountryRegionContext), "ns1:CountryRegionContext"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "ns1:EntityID", -1, &(a->ns1__CountryRegionContext::EntityID), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Iso2", -1, &(a->ns1__CountryRegionContext::Iso2), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CountryRegionContext::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CountryRegionContext(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CountryRegionContext * SOAP_FMAC4 soap_get_ns1__CountryRegionContext(struct soap *soap, ns1__CountryRegionContext *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CountryRegionContext(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__CountryRegionContext::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CountryRegionContext(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CountryRegionContext * SOAP_FMAC4 soap_in_ns1__CountryRegionContext(struct soap *soap, const char *tag, ns1__CountryRegionContext *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CountryRegionContext *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CountryRegionContext, sizeof(ns1__CountryRegionContext), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CountryRegionContext)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CountryRegionContext *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_EntityID1 = 1;
	size_t soap_flag_Iso21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_EntityID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:EntityID", &(a->ns1__CountryRegionContext::EntityID), "xsd:int"))
				{	soap_flag_EntityID1--;
					continue;
				}
			if (soap_flag_Iso21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Iso2", &(a->ns1__CountryRegionContext::Iso2), "xsd:string"))
				{	soap_flag_Iso21--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CountryRegionContext *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CountryRegionContext, 0, sizeof(ns1__CountryRegionContext), 0, soap_copy_ns1__CountryRegionContext);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__CountryRegionContext * SOAP_FMAC4 soap_instantiate_ns1__CountryRegionContext(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CountryRegionContext(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CountryRegionContext, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CountryRegionContext;
		if (size)
			*size = sizeof(ns1__CountryRegionContext);
		((ns1__CountryRegionContext*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CountryRegionContext[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CountryRegionContext);
		for (int i = 0; i < n; i++)
			((ns1__CountryRegionContext*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CountryRegionContext*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CountryRegionContext(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CountryRegionContext %p -> %p\n", q, p));
	*(ns1__CountryRegionContext*)p = *(ns1__CountryRegionContext*)q;
}

void ns1__CultureInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CultureInfo::Name);
	soap_default_int(soap, &this->ns1__CultureInfo::Lcid);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__CultureInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CultureInfo::Name);
	soap_embedded(soap, &this->ns1__CultureInfo::Lcid, SOAP_TYPE_int);
	/* transient soap skipped */
}

int ns1__CultureInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CultureInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CultureInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CultureInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CultureInfo(struct soap *soap, const char *tag, int id, const ns1__CultureInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CultureInfo), "ns1:CultureInfo"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:Name", -1, &(a->ns1__CultureInfo::Name), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Lcid", -1, &(a->ns1__CultureInfo::Lcid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CultureInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CultureInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CultureInfo * SOAP_FMAC4 soap_get_ns1__CultureInfo(struct soap *soap, ns1__CultureInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CultureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__CultureInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CultureInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CultureInfo * SOAP_FMAC4 soap_in_ns1__CultureInfo(struct soap *soap, const char *tag, ns1__CultureInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CultureInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CultureInfo, sizeof(ns1__CultureInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CultureInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CultureInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Lcid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Name", &(a->ns1__CultureInfo::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Lcid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Lcid", &(a->ns1__CultureInfo::Lcid), "xsd:int"))
				{	soap_flag_Lcid1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CultureInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CultureInfo, 0, sizeof(ns1__CultureInfo), 0, soap_copy_ns1__CultureInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Lcid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__CultureInfo * SOAP_FMAC4 soap_instantiate_ns1__CultureInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CultureInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CultureInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CultureInfo;
		if (size)
			*size = sizeof(ns1__CultureInfo);
		((ns1__CultureInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CultureInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CultureInfo);
		for (int i = 0; i < n; i++)
			((ns1__CultureInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CultureInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CultureInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CultureInfo %p -> %p\n", q, p));
	*(ns1__CultureInfo*)p = *(ns1__CultureInfo*)q;
}

void ns1__UserInfoHeader::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__UserInfoHeader::Culture = NULL;
	soap_default_ns1__DistanceUnit(soap, &this->ns1__UserInfoHeader::DefaultDistanceUnit);
	this->ns1__UserInfoHeader::Context = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__UserInfoHeader::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CultureInfo(soap, &this->ns1__UserInfoHeader::Culture);
	soap_serialize_PointerTons1__CountryRegionContext(soap, &this->ns1__UserInfoHeader::Context);
	/* transient soap skipped */
}

int ns1__UserInfoHeader::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UserInfoHeader);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__UserInfoHeader::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UserInfoHeader(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UserInfoHeader(struct soap *soap, const char *tag, int id, const ns1__UserInfoHeader *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UserInfoHeader), "ns1:UserInfoHeader"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__CultureInfo(soap, "ns1:Culture", -1, &(a->ns1__UserInfoHeader::Culture), ""))
		return soap->error;
	if (soap_out_ns1__DistanceUnit(soap, "ns1:DefaultDistanceUnit", -1, &(a->ns1__UserInfoHeader::DefaultDistanceUnit), ""))
		return soap->error;
	if (soap_out_PointerTons1__CountryRegionContext(soap, "ns1:Context", -1, &(a->ns1__UserInfoHeader::Context), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__UserInfoHeader::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UserInfoHeader(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UserInfoHeader * SOAP_FMAC4 soap_get_ns1__UserInfoHeader(struct soap *soap, ns1__UserInfoHeader *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UserInfoHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__UserInfoHeader::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UserInfoHeader(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UserInfoHeader * SOAP_FMAC4 soap_in_ns1__UserInfoHeader(struct soap *soap, const char *tag, ns1__UserInfoHeader *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UserInfoHeader *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UserInfoHeader, sizeof(ns1__UserInfoHeader), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UserInfoHeader)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UserInfoHeader *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Culture1 = 1;
	size_t soap_flag_DefaultDistanceUnit1 = 1;
	size_t soap_flag_Context1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Culture1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CultureInfo(soap, "ns1:Culture", &(a->ns1__UserInfoHeader::Culture), "ns1:CultureInfo"))
				{	soap_flag_Culture1--;
					continue;
				}
			if (soap_flag_DefaultDistanceUnit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__DistanceUnit(soap, "ns1:DefaultDistanceUnit", &(a->ns1__UserInfoHeader::DefaultDistanceUnit), "ns1:DistanceUnit"))
				{	soap_flag_DefaultDistanceUnit1--;
					continue;
				}
			if (soap_flag_Context1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CountryRegionContext(soap, "ns1:Context", &(a->ns1__UserInfoHeader::Context), "ns1:CountryRegionContext"))
				{	soap_flag_Context1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UserInfoHeader *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UserInfoHeader, 0, sizeof(ns1__UserInfoHeader), 0, soap_copy_ns1__UserInfoHeader);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DefaultDistanceUnit1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__UserInfoHeader * SOAP_FMAC4 soap_instantiate_ns1__UserInfoHeader(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UserInfoHeader(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UserInfoHeader, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__UserInfoHeader;
		if (size)
			*size = sizeof(ns1__UserInfoHeader);
		((ns1__UserInfoHeader*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__UserInfoHeader[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UserInfoHeader);
		for (int i = 0; i < n; i++)
			((ns1__UserInfoHeader*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UserInfoHeader*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UserInfoHeader(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UserInfoHeader %p -> %p\n", q, p));
	*(ns1__UserInfoHeader*)p = *(ns1__UserInfoHeader*)q;
}

void ns1__CustomerInfoHeader::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &this->ns1__CustomerInfoHeader::CustomLogEntry);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__CustomerInfoHeader::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__CustomerInfoHeader::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CustomerInfoHeader);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CustomerInfoHeader::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CustomerInfoHeader(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CustomerInfoHeader(struct soap *soap, const char *tag, int id, const ns1__CustomerInfoHeader *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CustomerInfoHeader), "ns1:CustomerInfoHeader"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_short(soap, "ns1:CustomLogEntry", -1, &(a->ns1__CustomerInfoHeader::CustomLogEntry), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CustomerInfoHeader::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CustomerInfoHeader(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CustomerInfoHeader * SOAP_FMAC4 soap_get_ns1__CustomerInfoHeader(struct soap *soap, ns1__CustomerInfoHeader *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CustomerInfoHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__CustomerInfoHeader::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CustomerInfoHeader(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CustomerInfoHeader * SOAP_FMAC4 soap_in_ns1__CustomerInfoHeader(struct soap *soap, const char *tag, ns1__CustomerInfoHeader *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CustomerInfoHeader *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CustomerInfoHeader, sizeof(ns1__CustomerInfoHeader), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CustomerInfoHeader)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CustomerInfoHeader *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_CustomLogEntry1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_CustomLogEntry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "ns1:CustomLogEntry", &(a->ns1__CustomerInfoHeader::CustomLogEntry), "xsd:short"))
				{	soap_flag_CustomLogEntry1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CustomerInfoHeader *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CustomerInfoHeader, 0, sizeof(ns1__CustomerInfoHeader), 0, soap_copy_ns1__CustomerInfoHeader);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CustomLogEntry1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__CustomerInfoHeader * SOAP_FMAC4 soap_instantiate_ns1__CustomerInfoHeader(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CustomerInfoHeader(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CustomerInfoHeader, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CustomerInfoHeader;
		if (size)
			*size = sizeof(ns1__CustomerInfoHeader);
		((ns1__CustomerInfoHeader*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CustomerInfoHeader[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CustomerInfoHeader);
		for (int i = 0; i < n; i++)
			((ns1__CustomerInfoHeader*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CustomerInfoHeader*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CustomerInfoHeader(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CustomerInfoHeader %p -> %p\n", q, p));
	*(ns1__CustomerInfoHeader*)p = *(ns1__CustomerInfoHeader*)q;
}

void ns1__VersionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__VersionInfo::Component);
	soap_default_string(soap, &this->ns1__VersionInfo::Version);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__VersionInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__VersionInfo::Component);
	soap_serialize_string(soap, &this->ns1__VersionInfo::Version);
	/* transient soap skipped */
}

int ns1__VersionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__VersionInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__VersionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__VersionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__VersionInfo(struct soap *soap, const char *tag, int id, const ns1__VersionInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__VersionInfo), "ns1:VersionInfo"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:Component", -1, &(a->ns1__VersionInfo::Component), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Version", -1, &(a->ns1__VersionInfo::Version), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__VersionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__VersionInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__VersionInfo * SOAP_FMAC4 soap_get_ns1__VersionInfo(struct soap *soap, ns1__VersionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__VersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__VersionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__VersionInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__VersionInfo * SOAP_FMAC4 soap_in_ns1__VersionInfo(struct soap *soap, const char *tag, ns1__VersionInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__VersionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__VersionInfo, sizeof(ns1__VersionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__VersionInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__VersionInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Component1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Component1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Component", &(a->ns1__VersionInfo::Component), "xsd:string"))
				{	soap_flag_Component1--;
					continue;
				}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Version", &(a->ns1__VersionInfo::Version), "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__VersionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__VersionInfo, 0, sizeof(ns1__VersionInfo), 0, soap_copy_ns1__VersionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__VersionInfo * SOAP_FMAC4 soap_instantiate_ns1__VersionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__VersionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__VersionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__VersionInfo;
		if (size)
			*size = sizeof(ns1__VersionInfo);
		((ns1__VersionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__VersionInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__VersionInfo);
		for (int i = 0; i < n; i++)
			((ns1__VersionInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__VersionInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__VersionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__VersionInfo %p -> %p\n", q, p));
	*(ns1__VersionInfo*)p = *(ns1__VersionInfo*)q;
}

void ns1__ArrayOfVersionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfVersionInfo::__sizeVersionInfo = 0;
	this->ns1__ArrayOfVersionInfo::VersionInfo = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfVersionInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfVersionInfo::VersionInfo)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfVersionInfo::__sizeVersionInfo; i++)
		{
			soap_serialize_PointerTons1__VersionInfo(soap, this->ns1__ArrayOfVersionInfo::VersionInfo + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfVersionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfVersionInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfVersionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfVersionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfVersionInfo(struct soap *soap, const char *tag, int id, const ns1__ArrayOfVersionInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfVersionInfo), "ns1:ArrayOfVersionInfo"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__ArrayOfVersionInfo::VersionInfo)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfVersionInfo::__sizeVersionInfo; i++)
			if (soap_out_PointerTons1__VersionInfo(soap, "ns1:VersionInfo", -1, a->ns1__ArrayOfVersionInfo::VersionInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfVersionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfVersionInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfVersionInfo * SOAP_FMAC4 soap_get_ns1__ArrayOfVersionInfo(struct soap *soap, ns1__ArrayOfVersionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ArrayOfVersionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfVersionInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfVersionInfo * SOAP_FMAC4 soap_in_ns1__ArrayOfVersionInfo(struct soap *soap, const char *tag, ns1__ArrayOfVersionInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfVersionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfVersionInfo, sizeof(ns1__ArrayOfVersionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfVersionInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfVersionInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_VersionInfo1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:VersionInfo", 1, NULL))
			{	if (a->ns1__ArrayOfVersionInfo::VersionInfo == NULL)
				{	if (soap_blist_VersionInfo1 == NULL)
						soap_blist_VersionInfo1 = soap_new_block(soap);
					a->ns1__ArrayOfVersionInfo::VersionInfo = (ns1__VersionInfo **)soap_push_block(soap, soap_blist_VersionInfo1, sizeof(ns1__VersionInfo *));
					if (a->ns1__ArrayOfVersionInfo::VersionInfo == NULL)
						return NULL;
					*a->ns1__ArrayOfVersionInfo::VersionInfo = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons1__VersionInfo(soap, "ns1:VersionInfo", a->ns1__ArrayOfVersionInfo::VersionInfo, "ns1:VersionInfo"))
				{	a->ns1__ArrayOfVersionInfo::__sizeVersionInfo++;
					a->ns1__ArrayOfVersionInfo::VersionInfo = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfVersionInfo::VersionInfo)
			soap_pop_block(soap, soap_blist_VersionInfo1);
		if (a->ns1__ArrayOfVersionInfo::__sizeVersionInfo)
			a->ns1__ArrayOfVersionInfo::VersionInfo = (ns1__VersionInfo **)soap_save_block(soap, soap_blist_VersionInfo1, NULL, 1);
		else
		{	a->ns1__ArrayOfVersionInfo::VersionInfo = NULL;
			if (soap_blist_VersionInfo1)
				soap_end_block(soap, soap_blist_VersionInfo1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfVersionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfVersionInfo, 0, sizeof(ns1__ArrayOfVersionInfo), 0, soap_copy_ns1__ArrayOfVersionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ArrayOfVersionInfo * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfVersionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfVersionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfVersionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfVersionInfo;
		if (size)
			*size = sizeof(ns1__ArrayOfVersionInfo);
		((ns1__ArrayOfVersionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfVersionInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfVersionInfo);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfVersionInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfVersionInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfVersionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfVersionInfo %p -> %p\n", q, p));
	*(ns1__ArrayOfVersionInfo*)p = *(ns1__ArrayOfVersionInfo*)q;
}

void xsd__unsignedShort::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedShort(soap, &this->xsd__unsignedShort::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__unsignedShort::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__unsignedShort::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedShort);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedShort::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedShort(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedShort(struct soap *soap, const char *tag, int id, const xsd__unsignedShort *a, const char *type)
{
	return soap_out_unsignedShort(soap, tag, id, &(a->xsd__unsignedShort::__item), "xsd:unsignedShort");
}

void *xsd__unsignedShort::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedShort(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedShort * SOAP_FMAC4 soap_get_xsd__unsignedShort(struct soap *soap, xsd__unsignedShort *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedShort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__unsignedShort::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedShort(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedShort * SOAP_FMAC4 soap_in_xsd__unsignedShort(struct soap *soap, const char *tag, xsd__unsignedShort *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedShort *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedShort, sizeof(xsd__unsignedShort), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedShort)
			return (xsd__unsignedShort *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_unsignedShort(soap, tag, &(a->xsd__unsignedShort::__item), "xsd:unsignedShort"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__unsignedShort * SOAP_FMAC4 soap_instantiate_xsd__unsignedShort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedShort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedShort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedShort;
		if (size)
			*size = sizeof(xsd__unsignedShort);
		((xsd__unsignedShort*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedShort[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__unsignedShort);
		for (int i = 0; i < n; i++)
			((xsd__unsignedShort*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedShort*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedShort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedShort %p -> %p\n", q, p));
	*(xsd__unsignedShort*)p = *(xsd__unsignedShort*)q;
}

void xsd__unsignedLong::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedLONG64(soap, &this->xsd__unsignedLong::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__unsignedLong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__unsignedLong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedLong);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedLong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedLong(struct soap *soap, const char *tag, int id, const xsd__unsignedLong *a, const char *type)
{
	return soap_out_unsignedLONG64(soap, tag, id, &(a->xsd__unsignedLong::__item), "xsd:unsignedLong");
}

void *xsd__unsignedLong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedLong(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedLong * SOAP_FMAC4 soap_get_xsd__unsignedLong(struct soap *soap, xsd__unsignedLong *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__unsignedLong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedLong(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedLong * SOAP_FMAC4 soap_in_xsd__unsignedLong(struct soap *soap, const char *tag, xsd__unsignedLong *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedLong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedLong, sizeof(xsd__unsignedLong), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedLong)
			return (xsd__unsignedLong *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_unsignedLONG64(soap, tag, &(a->xsd__unsignedLong::__item), "xsd:unsignedLong"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__unsignedLong * SOAP_FMAC4 soap_instantiate_xsd__unsignedLong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedLong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedLong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedLong;
		if (size)
			*size = sizeof(xsd__unsignedLong);
		((xsd__unsignedLong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedLong[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__unsignedLong);
		for (int i = 0; i < n; i++)
			((xsd__unsignedLong*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedLong*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedLong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedLong %p -> %p\n", q, p));
	*(xsd__unsignedLong*)p = *(xsd__unsignedLong*)q;
}

void xsd__unsignedInt::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->xsd__unsignedInt::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__unsignedInt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__unsignedInt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedInt);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedInt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedInt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedInt(struct soap *soap, const char *tag, int id, const xsd__unsignedInt *a, const char *type)
{
	return soap_out_unsignedInt(soap, tag, id, &(a->xsd__unsignedInt::__item), "xsd:unsignedInt");
}

void *xsd__unsignedInt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedInt(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedInt * SOAP_FMAC4 soap_get_xsd__unsignedInt(struct soap *soap, xsd__unsignedInt *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__unsignedInt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedInt(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedInt * SOAP_FMAC4 soap_in_xsd__unsignedInt(struct soap *soap, const char *tag, xsd__unsignedInt *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedInt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedInt, sizeof(xsd__unsignedInt), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedInt)
			return (xsd__unsignedInt *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_unsignedInt(soap, tag, &(a->xsd__unsignedInt::__item), "xsd:unsignedInt"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__unsignedInt * SOAP_FMAC4 soap_instantiate_xsd__unsignedInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedInt;
		if (size)
			*size = sizeof(xsd__unsignedInt);
		((xsd__unsignedInt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedInt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__unsignedInt);
		for (int i = 0; i < n; i++)
			((xsd__unsignedInt*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedInt*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedInt %p -> %p\n", q, p));
	*(xsd__unsignedInt*)p = *(xsd__unsignedInt*)q;
}

void xsd__unsignedByte_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__unsignedByte(soap, &this->xsd__unsignedByte_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__unsignedByte_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__unsignedByte_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedByte_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedByte_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedByte_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte_(struct soap *soap, const char *tag, int id, const xsd__unsignedByte_ *a, const char *type)
{
	return soap_out_xsd__unsignedByte(soap, tag, id, &(a->xsd__unsignedByte_::__item), "xsd:unsignedByte");
}

void *xsd__unsignedByte_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedByte_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedByte_ * SOAP_FMAC4 soap_get_xsd__unsignedByte_(struct soap *soap, xsd__unsignedByte_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedByte_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__unsignedByte_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedByte_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedByte_ * SOAP_FMAC4 soap_in_xsd__unsignedByte_(struct soap *soap, const char *tag, xsd__unsignedByte_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedByte_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedByte_, sizeof(xsd__unsignedByte_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedByte_)
			return (xsd__unsignedByte_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__unsignedByte(soap, tag, &(a->xsd__unsignedByte_::__item), "xsd:unsignedByte"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__unsignedByte_ * SOAP_FMAC4 soap_instantiate_xsd__unsignedByte_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedByte_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedByte_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedByte_;
		if (size)
			*size = sizeof(xsd__unsignedByte_);
		((xsd__unsignedByte_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedByte_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__unsignedByte_);
		for (int i = 0; i < n; i++)
			((xsd__unsignedByte_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedByte_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedByte_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedByte_ %p -> %p\n", q, p));
	*(xsd__unsignedByte_*)p = *(xsd__unsignedByte_*)q;
}

void xsd__string::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->xsd__string::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__string::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->xsd__string::__item);
	/* transient soap skipped */
}

int xsd__string::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__string::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const xsd__string *a, const char *type)
{
	return soap_out_string(soap, tag, id, &(a->xsd__string::__item), "xsd:string");
}

void *xsd__string::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, xsd__string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__string::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__string(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, xsd__string *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string, sizeof(xsd__string), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__string)
			return (xsd__string *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_string(soap, tag, &(a->xsd__string::__item), "xsd:string"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_instantiate_xsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__string;
		if (size)
			*size = sizeof(xsd__string);
		((xsd__string*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__string);
		for (int i = 0; i < n; i++)
			((xsd__string*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string %p -> %p\n", q, p));
	*(xsd__string*)p = *(xsd__string*)q;
}

void xsd__short::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &this->xsd__short::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__short::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__short::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__short);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__short::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__short(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__short(struct soap *soap, const char *tag, int id, const xsd__short *a, const char *type)
{
	return soap_out_short(soap, tag, id, &(a->xsd__short::__item), "xsd:short");
}

void *xsd__short::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__short(soap, this, tag, type);
}

SOAP_FMAC3 xsd__short * SOAP_FMAC4 soap_get_xsd__short(struct soap *soap, xsd__short *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__short::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__short(soap, tag, this, type);
}

SOAP_FMAC3 xsd__short * SOAP_FMAC4 soap_in_xsd__short(struct soap *soap, const char *tag, xsd__short *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__short *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__short, sizeof(xsd__short), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__short)
			return (xsd__short *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_short(soap, tag, &(a->xsd__short::__item), "xsd:short"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__short * SOAP_FMAC4 soap_instantiate_xsd__short(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__short(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__short, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__short;
		if (size)
			*size = sizeof(xsd__short);
		((xsd__short*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__short[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__short);
		for (int i = 0; i < n; i++)
			((xsd__short*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__short*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__short(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__short %p -> %p\n", q, p));
	*(xsd__short*)p = *(xsd__short*)q;
}

void xsd__long::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->xsd__long::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__long::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__long::__item, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int xsd__long::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__long);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__long::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__long(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap *soap, const char *tag, int id, const xsd__long *a, const char *type)
{
	return soap_out_LONG64(soap, tag, id, &(a->xsd__long::__item), "xsd:long");
}

void *xsd__long::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__long(soap, this, tag, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_get_xsd__long(struct soap *soap, xsd__long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__long::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__long(soap, tag, this, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_in_xsd__long(struct soap *soap, const char *tag, xsd__long *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__long *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__long, sizeof(xsd__long), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__long)
			return (xsd__long *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_LONG64(soap, tag, &(a->xsd__long::__item), "xsd:long"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_instantiate_xsd__long(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__long(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__long, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__long;
		if (size)
			*size = sizeof(xsd__long);
		((xsd__long*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__long[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__long);
		for (int i = 0; i < n; i++)
			((xsd__long*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__long*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__long(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__long %p -> %p\n", q, p));
	*(xsd__long*)p = *(xsd__long*)q;
}

void xsd__int::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->xsd__int::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__int::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__int::__item, SOAP_TYPE_int);
	/* transient soap skipped */
}

int xsd__int::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__int::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const xsd__int *a, const char *type)
{
	return soap_out_int(soap, tag, id, &(a->xsd__int::__item), "xsd:int");
}

void *xsd__int::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, xsd__int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__int::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__int(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, xsd__int *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__int *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int, sizeof(xsd__int), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__int)
			return (xsd__int *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_int(soap, tag, &(a->xsd__int::__item), "xsd:int"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_instantiate_xsd__int(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__int, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__int;
		if (size)
			*size = sizeof(xsd__int);
		((xsd__int*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__int[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__int);
		for (int i = 0; i < n; i++)
			((xsd__int*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__int*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__int(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int %p -> %p\n", q, p));
	*(xsd__int*)p = *(xsd__int*)q;
}

void xsd__float::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->xsd__float::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__float::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__float::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__float);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__float::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__float(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__float(struct soap *soap, const char *tag, int id, const xsd__float *a, const char *type)
{
	return soap_out_float(soap, tag, id, &(a->xsd__float::__item), "xsd:float");
}

void *xsd__float::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__float(soap, this, tag, type);
}

SOAP_FMAC3 xsd__float * SOAP_FMAC4 soap_get_xsd__float(struct soap *soap, xsd__float *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__float::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__float(soap, tag, this, type);
}

SOAP_FMAC3 xsd__float * SOAP_FMAC4 soap_in_xsd__float(struct soap *soap, const char *tag, xsd__float *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__float *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__float, sizeof(xsd__float), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__float)
			return (xsd__float *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_float(soap, tag, &(a->xsd__float::__item), "xsd:float"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__float * SOAP_FMAC4 soap_instantiate_xsd__float(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__float(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__float, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__float;
		if (size)
			*size = sizeof(xsd__float);
		((xsd__float*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__float[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__float);
		for (int i = 0; i < n; i++)
			((xsd__float*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__float*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__float(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__float %p -> %p\n", q, p));
	*(xsd__float*)p = *(xsd__float*)q;
}

void xsd__duration_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__duration(soap, &this->xsd__duration_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__duration_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__duration(soap, &this->xsd__duration_::__item);
	/* transient soap skipped */
}

int xsd__duration_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__duration_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__duration_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__duration_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration_(struct soap *soap, const char *tag, int id, const xsd__duration_ *a, const char *type)
{
	return soap_out_xsd__duration(soap, tag, id, &(a->xsd__duration_::__item), "xsd:duration");
}

void *xsd__duration_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__duration_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__duration_ * SOAP_FMAC4 soap_get_xsd__duration_(struct soap *soap, xsd__duration_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__duration_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__duration_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__duration_ * SOAP_FMAC4 soap_in_xsd__duration_(struct soap *soap, const char *tag, xsd__duration_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__duration_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__duration_, sizeof(xsd__duration_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__duration_)
			return (xsd__duration_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__duration(soap, tag, &(a->xsd__duration_::__item), "xsd:duration"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__duration_ * SOAP_FMAC4 soap_instantiate_xsd__duration_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__duration_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__duration_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__duration_;
		if (size)
			*size = sizeof(xsd__duration_);
		((xsd__duration_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__duration_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__duration_);
		for (int i = 0; i < n; i++)
			((xsd__duration_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__duration_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__duration_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__duration_ %p -> %p\n", q, p));
	*(xsd__duration_*)p = *(xsd__duration_*)q;
}

void xsd__double::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->xsd__double::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__double::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__double::__item, SOAP_TYPE_double);
	/* transient soap skipped */
}

int xsd__double::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__double);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__double::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__double(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap *soap, const char *tag, int id, const xsd__double *a, const char *type)
{
	return soap_out_double(soap, tag, id, &(a->xsd__double::__item), "xsd:double");
}

void *xsd__double::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__double(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_get_xsd__double(struct soap *soap, xsd__double *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__double::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__double(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_in_xsd__double(struct soap *soap, const char *tag, xsd__double *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__double *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__double, sizeof(xsd__double), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__double)
			return (xsd__double *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_double(soap, tag, &(a->xsd__double::__item), "xsd:double"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_instantiate_xsd__double(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__double(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__double, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__double;
		if (size)
			*size = sizeof(xsd__double);
		((xsd__double*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__double[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__double);
		for (int i = 0; i < n; i++)
			((xsd__double*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__double*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__double(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__double %p -> %p\n", q, p));
	*(xsd__double*)p = *(xsd__double*)q;
}

void xsd__decimal_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__decimal(soap, &this->xsd__decimal_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__decimal_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__decimal(soap, &this->xsd__decimal_::__item);
	/* transient soap skipped */
}

int xsd__decimal_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__decimal_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__decimal_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__decimal_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal_(struct soap *soap, const char *tag, int id, const xsd__decimal_ *a, const char *type)
{
	return soap_out_xsd__decimal(soap, tag, id, &(a->xsd__decimal_::__item), "xsd:decimal");
}

void *xsd__decimal_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__decimal_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_get_xsd__decimal_(struct soap *soap, xsd__decimal_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__decimal_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__decimal_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_in_xsd__decimal_(struct soap *soap, const char *tag, xsd__decimal_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__decimal_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__decimal_, sizeof(xsd__decimal_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__decimal_)
			return (xsd__decimal_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__decimal(soap, tag, &(a->xsd__decimal_::__item), "xsd:decimal"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_instantiate_xsd__decimal_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__decimal_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__decimal_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__decimal_;
		if (size)
			*size = sizeof(xsd__decimal_);
		((xsd__decimal_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__decimal_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__decimal_);
		for (int i = 0; i < n; i++)
			((xsd__decimal_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__decimal_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__decimal_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__decimal_ %p -> %p\n", q, p));
	*(xsd__decimal_*)p = *(xsd__decimal_*)q;
}

void xsd__dateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->xsd__dateTime::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__dateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__dateTime::__item, SOAP_TYPE_time);
	/* transient soap skipped */
}

int xsd__dateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__dateTime);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__dateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, const xsd__dateTime *a, const char *type)
{
	return soap_out_time(soap, tag, id, &(a->xsd__dateTime::__item), "xsd:dateTime");
}

void *xsd__dateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, xsd__dateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__dateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__dateTime(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, xsd__dateTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__dateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__dateTime)
			return (xsd__dateTime *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_time(soap, tag, &(a->xsd__dateTime::__item), "xsd:dateTime"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_instantiate_xsd__dateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__dateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__dateTime;
		if (size)
			*size = sizeof(xsd__dateTime);
		((xsd__dateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__dateTime[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__dateTime);
		for (int i = 0; i < n; i++)
			((xsd__dateTime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__dateTime*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__dateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__dateTime %p -> %p\n", q, p));
	*(xsd__dateTime*)p = *(xsd__dateTime*)q;
}

void xsd__byte_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->xsd__byte_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__byte_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__byte_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__byte_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__byte_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__byte_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte_(struct soap *soap, const char *tag, int id, const xsd__byte_ *a, const char *type)
{
	return soap_out_xsd__byte(soap, tag, id, &(a->xsd__byte_::__item), "xsd:byte");
}

void *xsd__byte_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__byte_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__byte_ * SOAP_FMAC4 soap_get_xsd__byte_(struct soap *soap, xsd__byte_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__byte_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__byte_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__byte_ * SOAP_FMAC4 soap_in_xsd__byte_(struct soap *soap, const char *tag, xsd__byte_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__byte_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__byte_, sizeof(xsd__byte_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__byte_)
			return (xsd__byte_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__byte(soap, tag, &(a->xsd__byte_::__item), "xsd:byte"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__byte_ * SOAP_FMAC4 soap_instantiate_xsd__byte_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__byte_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__byte_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__byte_;
		if (size)
			*size = sizeof(xsd__byte_);
		((xsd__byte_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__byte_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__byte_);
		for (int i = 0; i < n; i++)
			((xsd__byte_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__byte_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__byte_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__byte_ %p -> %p\n", q, p));
	*(xsd__byte_*)p = *(xsd__byte_*)q;
}

void xsd__boolean::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->xsd__boolean::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__boolean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__boolean::__item, SOAP_TYPE_bool);
	/* transient soap skipped */
}

int xsd__boolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__boolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const xsd__boolean *a, const char *type)
{
	return soap_out_bool(soap, tag, id, &(a->xsd__boolean::__item), "xsd:boolean");
}

void *xsd__boolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__boolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__boolean(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__boolean)
			return (xsd__boolean *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_bool(soap, tag, &(a->xsd__boolean::__item), "xsd:boolean"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_instantiate_xsd__boolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__boolean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__boolean;
		if (size)
			*size = sizeof(xsd__boolean);
		((xsd__boolean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__boolean[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__boolean);
		for (int i = 0; i < n; i++)
			((xsd__boolean*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__boolean*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__boolean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean %p -> %p\n", q, p));
	*(xsd__boolean*)p = *(xsd__boolean*)q;
}

void xsd__base64Binary_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__base64Binary_::__item.xsd__base64Binary::soap_default(soap);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__base64Binary_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->xsd__base64Binary_::__item.soap_serialize(soap);
	/* transient soap skipped */
}

int xsd__base64Binary_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__base64Binary_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__base64Binary_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary_(struct soap *soap, const char *tag, int id, const xsd__base64Binary_ *a, const char *type)
{
	return (a->xsd__base64Binary_::__item).soap_out(soap, tag, id, "xsd:base64Binary");
}

void *xsd__base64Binary_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary_ * SOAP_FMAC4 soap_get_xsd__base64Binary_(struct soap *soap, xsd__base64Binary_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__base64Binary_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary_ * SOAP_FMAC4 soap_in_xsd__base64Binary_(struct soap *soap, const char *tag, xsd__base64Binary_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__base64Binary_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary_, sizeof(xsd__base64Binary_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__base64Binary_)
			return (xsd__base64Binary_ *)a->soap_in(soap, tag, type);
	}
	if (!(a->xsd__base64Binary_::__item).soap_in(soap, tag, "xsd:base64Binary"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__base64Binary_ * SOAP_FMAC4 soap_instantiate_xsd__base64Binary_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__base64Binary_;
		if (size)
			*size = sizeof(xsd__base64Binary_);
		((xsd__base64Binary_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__base64Binary_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__base64Binary_);
		for (int i = 0; i < n; i++)
			((xsd__base64Binary_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary_ %p -> %p\n", q, p));
	*(xsd__base64Binary_*)p = *(xsd__base64Binary_*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__base64Binary;
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__base64Binary[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		for (int i = 0; i < n; i++)
			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

void xsd__anyURI_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->xsd__anyURI_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__anyURI_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &this->xsd__anyURI_::__item);
	/* transient soap skipped */
}

int xsd__anyURI_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyURI_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anyURI_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyURI_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI_(struct soap *soap, const char *tag, int id, const xsd__anyURI_ *a, const char *type)
{
	return soap_out_xsd__anyURI(soap, tag, id, &(a->xsd__anyURI_::__item), "xsd:anyURI");
}

void *xsd__anyURI_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyURI_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_get_xsd__anyURI_(struct soap *soap, xsd__anyURI_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__anyURI_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyURI_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_in_xsd__anyURI_(struct soap *soap, const char *tag, xsd__anyURI_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyURI_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyURI_, sizeof(xsd__anyURI_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyURI_)
			return (xsd__anyURI_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__anyURI(soap, tag, &(a->xsd__anyURI_::__item), "xsd:anyURI"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_instantiate_xsd__anyURI_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyURI_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyURI_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anyURI_;
		if (size)
			*size = sizeof(xsd__anyURI_);
		((xsd__anyURI_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__anyURI_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__anyURI_);
		for (int i = 0; i < n; i++)
			((xsd__anyURI_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyURI_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyURI_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyURI_ %p -> %p\n", q, p));
	*(xsd__anyURI_*)p = *(xsd__anyURI_*)q;
}

void xsd__QName::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__QName(soap, &this->xsd__QName::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__QName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &this->xsd__QName::__item);
	/* transient soap skipped */
}

int xsd__QName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__QName);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__QName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__QName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const xsd__QName *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	return soap_out__QName(soap, tag, id, (char*const*)&soap_tmp___item, "xsd:QName");
}

void *xsd__QName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__QName(soap, this, tag, type);
}

SOAP_FMAC3 xsd__QName * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, xsd__QName *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__QName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__QName(soap, tag, this, type);
}

SOAP_FMAC3 xsd__QName * SOAP_FMAC4 soap_in_xsd__QName(struct soap *soap, const char *tag, xsd__QName *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__QName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__QName, sizeof(xsd__QName), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__QName)
			return (xsd__QName *)a->soap_in(soap, tag, type);
	}
	if (!soap_in__QName(soap, tag, &(a->xsd__QName::__item), "xsd:QName"))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__QName * SOAP_FMAC4 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__QName;
		if (size)
			*size = sizeof(xsd__QName);
		((xsd__QName*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__QName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__QName);
		for (int i = 0; i < n; i++)
			((xsd__QName*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__QName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__QName %p -> %p\n", q, p));
	*(xsd__QName*)p = *(xsd__QName*)q;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), NULL);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyType)
			return (xsd__anyType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:QName"))
	{	cp->type = SOAP_TYPE_xsd__QName;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__QName;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__QName);
			((xsd__QName*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__QName[n];
			if (size)
				*size = n * sizeof(xsd__QName);
			for (int i = 0; i < n; i++)
				((xsd__QName*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__QName*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:anyURI"))
	{	cp->type = SOAP_TYPE_xsd__anyURI_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__anyURI_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__anyURI_);
			((xsd__anyURI_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__anyURI_[n];
			if (size)
				*size = n * sizeof(xsd__anyURI_);
			for (int i = 0; i < n; i++)
				((xsd__anyURI_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__anyURI_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:base64Binary"))
	{	cp->type = SOAP_TYPE_xsd__base64Binary_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__base64Binary_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__base64Binary_);
			((xsd__base64Binary_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__base64Binary_[n];
			if (size)
				*size = n * sizeof(xsd__base64Binary_);
			for (int i = 0; i < n; i++)
				((xsd__base64Binary_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__base64Binary_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_xsd__boolean;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__boolean;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__boolean);
			((xsd__boolean*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__boolean[n];
			if (size)
				*size = n * sizeof(xsd__boolean);
			for (int i = 0; i < n; i++)
				((xsd__boolean*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__boolean*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__byte_);
			((xsd__byte_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
			for (int i = 0; i < n; i++)
				((xsd__byte_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:dateTime"))
	{	cp->type = SOAP_TYPE_xsd__dateTime;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__dateTime;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__dateTime);
			((xsd__dateTime*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__dateTime[n];
			if (size)
				*size = n * sizeof(xsd__dateTime);
			for (int i = 0; i < n; i++)
				((xsd__dateTime*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__dateTime*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:decimal"))
	{	cp->type = SOAP_TYPE_xsd__decimal_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__decimal_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__decimal_);
			((xsd__decimal_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__decimal_[n];
			if (size)
				*size = n * sizeof(xsd__decimal_);
			for (int i = 0; i < n; i++)
				((xsd__decimal_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__decimal_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:double"))
	{	cp->type = SOAP_TYPE_xsd__double;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__double;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__double);
			((xsd__double*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__double[n];
			if (size)
				*size = n * sizeof(xsd__double);
			for (int i = 0; i < n; i++)
				((xsd__double*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__double*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:duration"))
	{	cp->type = SOAP_TYPE_xsd__duration_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__duration_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__duration_);
			((xsd__duration_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__duration_[n];
			if (size)
				*size = n * sizeof(xsd__duration_);
			for (int i = 0; i < n; i++)
				((xsd__duration_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__duration_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:float"))
	{	cp->type = SOAP_TYPE_xsd__float;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__float;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__float);
			((xsd__float*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__float[n];
			if (size)
				*size = n * sizeof(xsd__float);
			for (int i = 0; i < n; i++)
				((xsd__float*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__float*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__int);
			((xsd__int*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__int[n];
			if (size)
				*size = n * sizeof(xsd__int);
			for (int i = 0; i < n; i++)
				((xsd__int*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__long;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__long);
			((xsd__long*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__long[n];
			if (size)
				*size = n * sizeof(xsd__long);
			for (int i = 0; i < n; i++)
				((xsd__long*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__long*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__short;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__short);
			((xsd__short*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__short[n];
			if (size)
				*size = n * sizeof(xsd__short);
			for (int i = 0; i < n; i++)
				((xsd__short*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__short*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_xsd__string;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__string;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__string);
			((xsd__string*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__string[n];
			if (size)
				*size = n * sizeof(xsd__string);
			for (int i = 0; i < n; i++)
				((xsd__string*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__string*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__unsignedByte_);
			((xsd__unsignedByte_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
			for (int i = 0; i < n; i++)
				((xsd__unsignedByte_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__unsignedInt);
			((xsd__unsignedInt*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt);
			for (int i = 0; i < n; i++)
				((xsd__unsignedInt*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
	{	cp->type = SOAP_TYPE_xsd__unsignedLong;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedLong;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__unsignedLong);
			((xsd__unsignedLong*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedLong[n];
			if (size)
				*size = n * sizeof(xsd__unsignedLong);
			for (int i = 0; i < n; i++)
				((xsd__unsignedLong*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedLong*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__unsignedShort);
			((xsd__unsignedShort*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort);
			for (int i = 0; i < n; i++)
				((xsd__unsignedShort*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:DataSourceCapability"))
	{	cp->type = SOAP_TYPE_ns1__DataSourceCapability_;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__DataSourceCapability_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__DataSourceCapability_);
			((ns1__DataSourceCapability_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__DataSourceCapability_[n];
			if (size)
				*size = n * sizeof(ns1__DataSourceCapability_);
			for (int i = 0; i < n; i++)
				((ns1__DataSourceCapability_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__DataSourceCapability_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:DistanceUnit"))
	{	cp->type = SOAP_TYPE_ns1__DistanceUnit_;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__DistanceUnit_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__DistanceUnit_);
			((ns1__DistanceUnit_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__DistanceUnit_[n];
			if (size)
				*size = n * sizeof(ns1__DistanceUnit_);
			for (int i = 0; i < n; i++)
				((ns1__DistanceUnit_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__DistanceUnit_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:Confidence"))
	{	cp->type = SOAP_TYPE_ns4__Confidence_;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__Confidence_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__Confidence_);
			((ns4__Confidence_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__Confidence_[n];
			if (size)
				*size = n * sizeof(ns4__Confidence_);
			for (int i = 0; i < n; i++)
				((ns4__Confidence_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__Confidence_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:DeviceType"))
	{	cp->type = SOAP_TYPE_ns4__DeviceType_;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__DeviceType_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__DeviceType_);
			((ns4__DeviceType_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__DeviceType_[n];
			if (size)
				*size = n * sizeof(ns4__DeviceType_);
			for (int i = 0; i < n; i++)
				((ns4__DeviceType_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__DeviceType_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:DistanceUnit"))
	{	cp->type = SOAP_TYPE_ns4__DistanceUnit_;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__DistanceUnit_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__DistanceUnit_);
			((ns4__DistanceUnit_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__DistanceUnit_[n];
			if (size)
				*size = n * sizeof(ns4__DistanceUnit_);
			for (int i = 0; i < n; i++)
				((ns4__DistanceUnit_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__DistanceUnit_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:CompareOperator"))
	{	cp->type = SOAP_TYPE_ns4__CompareOperator_;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__CompareOperator_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__CompareOperator_);
			((ns4__CompareOperator_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__CompareOperator_[n];
			if (size)
				*size = n * sizeof(ns4__CompareOperator_);
			for (int i = 0; i < n; i++)
				((ns4__CompareOperator_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__CompareOperator_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:LogicalOperator"))
	{	cp->type = SOAP_TYPE_ns4__LogicalOperator_;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__LogicalOperator_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__LogicalOperator_);
			((ns4__LogicalOperator_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__LogicalOperator_[n];
			if (size)
				*size = n * sizeof(ns4__LogicalOperator_);
			for (int i = 0; i < n; i++)
				((ns4__LogicalOperator_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__LogicalOperator_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:AuthenticationResultCode"))
	{	cp->type = SOAP_TYPE_ns4__AuthenticationResultCode_;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__AuthenticationResultCode_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__AuthenticationResultCode_);
			((ns4__AuthenticationResultCode_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__AuthenticationResultCode_[n];
			if (size)
				*size = n * sizeof(ns4__AuthenticationResultCode_);
			for (int i = 0; i < n; i++)
				((ns4__AuthenticationResultCode_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__AuthenticationResultCode_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ResponseStatusCode"))
	{	cp->type = SOAP_TYPE_ns4__ResponseStatusCode_;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ResponseStatusCode_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__ResponseStatusCode_);
			((ns4__ResponseStatusCode_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ResponseStatusCode_[n];
			if (size)
				*size = n * sizeof(ns4__ResponseStatusCode_);
			for (int i = 0; i < n; i++)
				((ns4__ResponseStatusCode_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ResponseStatusCode_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:UriScheme"))
	{	cp->type = SOAP_TYPE_ns4__UriScheme_;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__UriScheme_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__UriScheme_);
			((ns4__UriScheme_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__UriScheme_[n];
			if (size)
				*size = n * sizeof(ns4__UriScheme_);
			for (int i = 0; i < n; i++)
				((ns4__UriScheme_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__UriScheme_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:MapStyle"))
	{	cp->type = SOAP_TYPE_ns4__MapStyle_;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__MapStyle_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__MapStyle_);
			((ns4__MapStyle_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__MapStyle_[n];
			if (size)
				*size = n * sizeof(ns4__MapStyle_);
			for (int i = 0; i < n; i++)
				((ns4__MapStyle_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__MapStyle_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ImageType"))
	{	cp->type = SOAP_TYPE_ns4__ImageType_;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ImageType_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__ImageType_);
			((ns4__ImageType_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ImageType_[n];
			if (size)
				*size = n * sizeof(ns4__ImageType_);
			for (int i = 0; i < n; i++)
				((ns4__ImageType_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ImageType_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:char"))
	{	cp->type = SOAP_TYPE_ns5__char__;
		if (n < 0)
		{	cp->ptr = (void*)new ns5__char__;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns5__char__);
			((ns5__char__*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns5__char__[n];
			if (size)
				*size = n * sizeof(ns5__char__);
			for (int i = 0; i < n; i++)
				((ns5__char__*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__char__*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:duration"))
	{	cp->type = SOAP_TYPE_ns5__duration__;
		if (n < 0)
		{	cp->ptr = (void*)new ns5__duration__;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns5__duration__);
			((ns5__duration__*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns5__duration__[n];
			if (size)
				*size = n * sizeof(ns5__duration__);
			for (int i = 0; i < n; i++)
				((ns5__duration__*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__duration__*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:guid"))
	{	cp->type = SOAP_TYPE_ns5__guid__;
		if (n < 0)
		{	cp->ptr = (void*)new ns5__guid__;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns5__guid__);
			((ns5__guid__*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns5__guid__[n];
			if (size)
				*size = n * sizeof(ns5__guid__);
			for (int i = 0; i < n; i++)
				((ns5__guid__*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__guid__*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:ListingType"))
	{	cp->type = SOAP_TYPE_ns6__ListingType_;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__ListingType_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__ListingType_);
			((ns6__ListingType_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__ListingType_[n];
			if (size)
				*size = n * sizeof(ns6__ListingType_);
			for (int i = 0; i < n; i++)
				((ns6__ListingType_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ListingType_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:SortOrder"))
	{	cp->type = SOAP_TYPE_ns6__SortOrder_;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__SortOrder_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__SortOrder_);
			((ns6__SortOrder_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__SortOrder_[n];
			if (size)
				*size = n * sizeof(ns6__SortOrder_);
			for (int i = 0; i < n; i++)
				((ns6__SortOrder_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__SortOrder_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:TravelMode"))
	{	cp->type = SOAP_TYPE_ns16__TravelMode_;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__TravelMode_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__TravelMode_);
			((ns16__TravelMode_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__TravelMode_[n];
			if (size)
				*size = n * sizeof(ns16__TravelMode_);
			for (int i = 0; i < n; i++)
				((ns16__TravelMode_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__TravelMode_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:RouteOptimization"))
	{	cp->type = SOAP_TYPE_ns16__RouteOptimization_;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__RouteOptimization_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__RouteOptimization_);
			((ns16__RouteOptimization_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__RouteOptimization_[n];
			if (size)
				*size = n * sizeof(ns16__RouteOptimization_);
			for (int i = 0; i < n; i++)
				((ns16__RouteOptimization_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__RouteOptimization_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:RoutePathType"))
	{	cp->type = SOAP_TYPE_ns16__RoutePathType_;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__RoutePathType_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__RoutePathType_);
			((ns16__RoutePathType_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__RoutePathType_[n];
			if (size)
				*size = n * sizeof(ns16__RoutePathType_);
			for (int i = 0; i < n; i++)
				((ns16__RoutePathType_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__RoutePathType_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:TrafficUsage"))
	{	cp->type = SOAP_TYPE_ns16__TrafficUsage_;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__TrafficUsage_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__TrafficUsage_);
			((ns16__TrafficUsage_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__TrafficUsage_[n];
			if (size)
				*size = n * sizeof(ns16__TrafficUsage_);
			for (int i = 0; i < n; i++)
				((ns16__TrafficUsage_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__TrafficUsage_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:ItineraryItemHintType"))
	{	cp->type = SOAP_TYPE_ns16__ItineraryItemHintType_;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__ItineraryItemHintType_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__ItineraryItemHintType_);
			((ns16__ItineraryItemHintType_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__ItineraryItemHintType_[n];
			if (size)
				*size = n * sizeof(ns16__ItineraryItemHintType_);
			for (int i = 0; i < n; i++)
				((ns16__ItineraryItemHintType_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__ItineraryItemHintType_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:ManeuverType"))
	{	cp->type = SOAP_TYPE_ns16__ManeuverType_;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__ManeuverType_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__ManeuverType_);
			((ns16__ManeuverType_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__ManeuverType_[n];
			if (size)
				*size = n * sizeof(ns16__ManeuverType_);
			for (int i = 0; i < n; i++)
				((ns16__ManeuverType_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__ManeuverType_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:ItineraryWarningSeverity"))
	{	cp->type = SOAP_TYPE_ns16__ItineraryWarningSeverity_;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__ItineraryWarningSeverity_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__ItineraryWarningSeverity_);
			((ns16__ItineraryWarningSeverity_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__ItineraryWarningSeverity_[n];
			if (size)
				*size = n * sizeof(ns16__ItineraryWarningSeverity_);
			for (int i = 0; i < n; i++)
				((ns16__ItineraryWarningSeverity_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__ItineraryWarningSeverity_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:ItineraryWarningType"))
	{	cp->type = SOAP_TYPE_ns16__ItineraryWarningType_;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__ItineraryWarningType_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__ItineraryWarningType_);
			((ns16__ItineraryWarningType_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__ItineraryWarningType_[n];
			if (size)
				*size = n * sizeof(ns16__ItineraryWarningType_);
			for (int i = 0; i < n; i++)
				((ns16__ItineraryWarningType_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__ItineraryWarningType_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ArrayOfVersionInfo"))
	{	cp->type = SOAP_TYPE_ns1__ArrayOfVersionInfo;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ArrayOfVersionInfo;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__ArrayOfVersionInfo);
			((ns1__ArrayOfVersionInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ArrayOfVersionInfo[n];
			if (size)
				*size = n * sizeof(ns1__ArrayOfVersionInfo);
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfVersionInfo*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ArrayOfVersionInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:VersionInfo"))
	{	cp->type = SOAP_TYPE_ns1__VersionInfo;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__VersionInfo;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__VersionInfo);
			((ns1__VersionInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__VersionInfo[n];
			if (size)
				*size = n * sizeof(ns1__VersionInfo);
			for (int i = 0; i < n; i++)
				((ns1__VersionInfo*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__VersionInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:CustomerInfoHeader"))
	{	cp->type = SOAP_TYPE_ns1__CustomerInfoHeader;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__CustomerInfoHeader;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__CustomerInfoHeader);
			((ns1__CustomerInfoHeader*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__CustomerInfoHeader[n];
			if (size)
				*size = n * sizeof(ns1__CustomerInfoHeader);
			for (int i = 0; i < n; i++)
				((ns1__CustomerInfoHeader*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__CustomerInfoHeader*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:UserInfoHeader"))
	{	cp->type = SOAP_TYPE_ns1__UserInfoHeader;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__UserInfoHeader;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__UserInfoHeader);
			((ns1__UserInfoHeader*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__UserInfoHeader[n];
			if (size)
				*size = n * sizeof(ns1__UserInfoHeader);
			for (int i = 0; i < n; i++)
				((ns1__UserInfoHeader*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__UserInfoHeader*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:CultureInfo"))
	{	cp->type = SOAP_TYPE_ns1__CultureInfo;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__CultureInfo;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__CultureInfo);
			((ns1__CultureInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__CultureInfo[n];
			if (size)
				*size = n * sizeof(ns1__CultureInfo);
			for (int i = 0; i < n; i++)
				((ns1__CultureInfo*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__CultureInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:CountryRegionContext"))
	{	cp->type = SOAP_TYPE_ns1__CountryRegionContext;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__CountryRegionContext;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__CountryRegionContext);
			((ns1__CountryRegionContext*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__CountryRegionContext[n];
			if (size)
				*size = n * sizeof(ns1__CountryRegionContext);
			for (int i = 0; i < n; i++)
				((ns1__CountryRegionContext*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__CountryRegionContext*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ArrayOfInt"))
	{	cp->type = SOAP_TYPE_ns1__ArrayOfInt;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ArrayOfInt;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__ArrayOfInt);
			((ns1__ArrayOfInt*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ArrayOfInt[n];
			if (size)
				*size = n * sizeof(ns1__ArrayOfInt);
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfInt*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ArrayOfInt*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ArrayOfCountryRegionInfo"))
	{	cp->type = SOAP_TYPE_ns1__ArrayOfCountryRegionInfo;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ArrayOfCountryRegionInfo;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__ArrayOfCountryRegionInfo);
			((ns1__ArrayOfCountryRegionInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ArrayOfCountryRegionInfo[n];
			if (size)
				*size = n * sizeof(ns1__ArrayOfCountryRegionInfo);
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfCountryRegionInfo*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ArrayOfCountryRegionInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:CountryRegionInfo"))
	{	cp->type = SOAP_TYPE_ns1__CountryRegionInfo;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__CountryRegionInfo;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__CountryRegionInfo);
			((ns1__CountryRegionInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__CountryRegionInfo[n];
			if (size)
				*size = n * sizeof(ns1__CountryRegionInfo);
			for (int i = 0; i < n; i++)
				((ns1__CountryRegionInfo*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__CountryRegionInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:LatLong"))
	{	cp->type = SOAP_TYPE_ns1__LatLong;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__LatLong;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__LatLong);
			((ns1__LatLong*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__LatLong[n];
			if (size)
				*size = n * sizeof(ns1__LatLong);
			for (int i = 0; i < n; i++)
				((ns1__LatLong*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__LatLong*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ArrayOfEntityType"))
	{	cp->type = SOAP_TYPE_ns1__ArrayOfEntityType;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ArrayOfEntityType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__ArrayOfEntityType);
			((ns1__ArrayOfEntityType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ArrayOfEntityType[n];
			if (size)
				*size = n * sizeof(ns1__ArrayOfEntityType);
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfEntityType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ArrayOfEntityType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:EntityType"))
	{	cp->type = SOAP_TYPE_ns1__EntityType;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__EntityType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__EntityType);
			((ns1__EntityType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__EntityType[n];
			if (size)
				*size = n * sizeof(ns1__EntityType);
			for (int i = 0; i < n; i++)
				((ns1__EntityType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__EntityType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ArrayOfEntityProperty"))
	{	cp->type = SOAP_TYPE_ns1__ArrayOfEntityProperty;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ArrayOfEntityProperty;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__ArrayOfEntityProperty);
			((ns1__ArrayOfEntityProperty*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ArrayOfEntityProperty[n];
			if (size)
				*size = n * sizeof(ns1__ArrayOfEntityProperty);
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfEntityProperty*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ArrayOfEntityProperty*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:EntityProperty"))
	{	cp->type = SOAP_TYPE_ns1__EntityProperty;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__EntityProperty;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__EntityProperty);
			((ns1__EntityProperty*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__EntityProperty[n];
			if (size)
				*size = n * sizeof(ns1__EntityProperty);
			for (int i = 0; i < n; i++)
				((ns1__EntityProperty*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__EntityProperty*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ArrayOfString"))
	{	cp->type = SOAP_TYPE_ns1__ArrayOfString;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ArrayOfString;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__ArrayOfString);
			((ns1__ArrayOfString*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ArrayOfString[n];
			if (size)
				*size = n * sizeof(ns1__ArrayOfString);
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfString*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ArrayOfString*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ArrayOfDataSource"))
	{	cp->type = SOAP_TYPE_ns1__ArrayOfDataSource;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ArrayOfDataSource;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__ArrayOfDataSource);
			((ns1__ArrayOfDataSource*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ArrayOfDataSource[n];
			if (size)
				*size = n * sizeof(ns1__ArrayOfDataSource);
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfDataSource*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ArrayOfDataSource*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:DataSource"))
	{	cp->type = SOAP_TYPE_ns1__DataSource;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__DataSource;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__DataSource);
			((ns1__DataSource*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__DataSource[n];
			if (size)
				*size = n * sizeof(ns1__DataSource);
			for (int i = 0; i < n; i++)
				((ns1__DataSource*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__DataSource*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ArrayOfLatLong"))
	{	cp->type = SOAP_TYPE_ns1__ArrayOfLatLong;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ArrayOfLatLong;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__ArrayOfLatLong);
			((ns1__ArrayOfLatLong*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ArrayOfLatLong[n];
			if (size)
				*size = n * sizeof(ns1__ArrayOfLatLong);
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfLatLong*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ArrayOfLatLong*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ArrayOfDouble"))
	{	cp->type = SOAP_TYPE_ns1__ArrayOfDouble;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ArrayOfDouble;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__ArrayOfDouble);
			((ns1__ArrayOfDouble*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ArrayOfDouble[n];
			if (size)
				*size = n * sizeof(ns1__ArrayOfDouble);
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfDouble*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ArrayOfDouble*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:TokenSpecification"))
	{	cp->type = SOAP_TYPE_ns1__TokenSpecification;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__TokenSpecification;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__TokenSpecification);
			((ns1__TokenSpecification*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__TokenSpecification[n];
			if (size)
				*size = n * sizeof(ns1__TokenSpecification);
			for (int i = 0; i < n; i++)
				((ns1__TokenSpecification*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__TokenSpecification*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:RequestBase"))
	{	cp->type = SOAP_TYPE_ns4__RequestBase;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__RequestBase;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__RequestBase);
			((ns4__RequestBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__RequestBase[n];
			if (size)
				*size = n * sizeof(ns4__RequestBase);
			for (int i = 0; i < n; i++)
				((ns4__RequestBase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__RequestBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:Credentials"))
	{	cp->type = SOAP_TYPE_ns4__Credentials;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__Credentials;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__Credentials);
			((ns4__Credentials*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__Credentials[n];
			if (size)
				*size = n * sizeof(ns4__Credentials);
			for (int i = 0; i < n; i++)
				((ns4__Credentials*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__Credentials*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ExecutionOptions"))
	{	cp->type = SOAP_TYPE_ns4__ExecutionOptions;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ExecutionOptions;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__ExecutionOptions);
			((ns4__ExecutionOptions*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ExecutionOptions[n];
			if (size)
				*size = n * sizeof(ns4__ExecutionOptions);
			for (int i = 0; i < n; i++)
				((ns4__ExecutionOptions*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ExecutionOptions*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:UserProfile"))
	{	cp->type = SOAP_TYPE_ns4__UserProfile;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__UserProfile;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__UserProfile);
			((ns4__UserProfile*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__UserProfile[n];
			if (size)
				*size = n * sizeof(ns4__UserProfile);
			for (int i = 0; i < n; i++)
				((ns4__UserProfile*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__UserProfile*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:Heading"))
	{	cp->type = SOAP_TYPE_ns4__Heading;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__Heading;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__Heading);
			((ns4__Heading*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__Heading[n];
			if (size)
				*size = n * sizeof(ns4__Heading);
			for (int i = 0; i < n; i++)
				((ns4__Heading*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__Heading*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:Location"))
	{	cp->type = SOAP_TYPE_ns4__Location;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__Location;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__Location);
			((ns4__Location*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__Location[n];
			if (size)
				*size = n * sizeof(ns4__Location);
			for (int i = 0; i < n; i++)
				((ns4__Location*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__Location*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ShapeBase"))
	{	cp->type = SOAP_TYPE_ns4__ShapeBase;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ShapeBase;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__ShapeBase);
			((ns4__ShapeBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ShapeBase[n];
			if (size)
				*size = n * sizeof(ns4__ShapeBase);
			for (int i = 0; i < n; i++)
				((ns4__ShapeBase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ShapeBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfLocation"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfLocation;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfLocation;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__ArrayOfLocation);
			((ns4__ArrayOfLocation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfLocation[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfLocation);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfLocation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfLocation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:SizeOfint"))
	{	cp->type = SOAP_TYPE_ns4__SizeOfint;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__SizeOfint;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__SizeOfint);
			((ns4__SizeOfint*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__SizeOfint[n];
			if (size)
				*size = n * sizeof(ns4__SizeOfint);
			for (int i = 0; i < n; i++)
				((ns4__SizeOfint*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__SizeOfint*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:FilterExpressionBase"))
	{	cp->type = SOAP_TYPE_ns4__FilterExpressionBase;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__FilterExpressionBase;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__FilterExpressionBase);
			((ns4__FilterExpressionBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__FilterExpressionBase[n];
			if (size)
				*size = n * sizeof(ns4__FilterExpressionBase);
			for (int i = 0; i < n; i++)
				((ns4__FilterExpressionBase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__FilterExpressionBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfFilterExpressionBase"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfFilterExpressionBase;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfFilterExpressionBase;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__ArrayOfFilterExpressionBase);
			((ns4__ArrayOfFilterExpressionBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfFilterExpressionBase[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfFilterExpressionBase);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfFilterExpressionBase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfFilterExpressionBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ResponseBase"))
	{	cp->type = SOAP_TYPE_ns4__ResponseBase;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ResponseBase;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__ResponseBase);
			((ns4__ResponseBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ResponseBase[n];
			if (size)
				*size = n * sizeof(ns4__ResponseBase);
			for (int i = 0; i < n; i++)
				((ns4__ResponseBase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ResponseBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ResponseSummary"))
	{	cp->type = SOAP_TYPE_ns4__ResponseSummary;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ResponseSummary;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__ResponseSummary);
			((ns4__ResponseSummary*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ResponseSummary[n];
			if (size)
				*size = n * sizeof(ns4__ResponseSummary);
			for (int i = 0; i < n; i++)
				((ns4__ResponseSummary*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ResponseSummary*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:GeocodeResult"))
	{	cp->type = SOAP_TYPE_ns4__GeocodeResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__GeocodeResult;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__GeocodeResult);
			((ns4__GeocodeResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__GeocodeResult[n];
			if (size)
				*size = n * sizeof(ns4__GeocodeResult);
			for (int i = 0; i < n; i++)
				((ns4__GeocodeResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__GeocodeResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:Address"))
	{	cp->type = SOAP_TYPE_ns4__Address;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__Address;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__Address);
			((ns4__Address*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__Address[n];
			if (size)
				*size = n * sizeof(ns4__Address);
			for (int i = 0; i < n; i++)
				((ns4__Address*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__Address*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfGeocodeLocation"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfGeocodeLocation;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfGeocodeLocation;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__ArrayOfGeocodeLocation);
			((ns4__ArrayOfGeocodeLocation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfGeocodeLocation[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfGeocodeLocation);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfGeocodeLocation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfGeocodeLocation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfGeocodeResult"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfGeocodeResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfGeocodeResult;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__ArrayOfGeocodeResult);
			((ns4__ArrayOfGeocodeResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfGeocodeResult[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfGeocodeResult);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfGeocodeResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfGeocodeResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:RangeOfint"))
	{	cp->type = SOAP_TYPE_ns4__RangeOfint;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__RangeOfint;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__RangeOfint);
			((ns4__RangeOfint*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__RangeOfint[n];
			if (size)
				*size = n * sizeof(ns4__RangeOfint);
			for (int i = 0; i < n; i++)
				((ns4__RangeOfint*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__RangeOfint*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:RangeOfdateTime"))
	{	cp->type = SOAP_TYPE_ns4__RangeOfdateTime;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__RangeOfdateTime;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__RangeOfdateTime);
			((ns4__RangeOfdateTime*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__RangeOfdateTime[n];
			if (size)
				*size = n * sizeof(ns4__RangeOfdateTime);
			for (int i = 0; i < n; i++)
				((ns4__RangeOfdateTime*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__RangeOfdateTime*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfPushpin"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfPushpin;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__ArrayOfPushpin;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__ArrayOfPushpin);
			((ns4__ArrayOfPushpin*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__ArrayOfPushpin[n];
			if (size)
				*size = n * sizeof(ns4__ArrayOfPushpin);
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfPushpin*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__ArrayOfPushpin*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:Pushpin"))
	{	cp->type = SOAP_TYPE_ns4__Pushpin;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__Pushpin;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__Pushpin);
			((ns4__Pushpin*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__Pushpin[n];
			if (size)
				*size = n * sizeof(ns4__Pushpin);
			for (int i = 0; i < n; i++)
				((ns4__Pushpin*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__Pushpin*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:SearchOptions"))
	{	cp->type = SOAP_TYPE_ns6__SearchOptions;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__SearchOptions;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__SearchOptions);
			((ns6__SearchOptions*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__SearchOptions[n];
			if (size)
				*size = n * sizeof(ns6__SearchOptions);
			for (int i = 0; i < n; i++)
				((ns6__SearchOptions*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__SearchOptions*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:StructuredSearchQuery"))
	{	cp->type = SOAP_TYPE_ns6__StructuredSearchQuery;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__StructuredSearchQuery;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__StructuredSearchQuery);
			((ns6__StructuredSearchQuery*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__StructuredSearchQuery[n];
			if (size)
				*size = n * sizeof(ns6__StructuredSearchQuery);
			for (int i = 0; i < n; i++)
				((ns6__StructuredSearchQuery*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__StructuredSearchQuery*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:QuerySuggestion"))
	{	cp->type = SOAP_TYPE_ns6__QuerySuggestion;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__QuerySuggestion;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__QuerySuggestion);
			((ns6__QuerySuggestion*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__QuerySuggestion[n];
			if (size)
				*size = n * sizeof(ns6__QuerySuggestion);
			for (int i = 0; i < n; i++)
				((ns6__QuerySuggestion*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__QuerySuggestion*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:ArrayOfSearchResultSet"))
	{	cp->type = SOAP_TYPE_ns6__ArrayOfSearchResultSet;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__ArrayOfSearchResultSet;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__ArrayOfSearchResultSet);
			((ns6__ArrayOfSearchResultSet*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__ArrayOfSearchResultSet[n];
			if (size)
				*size = n * sizeof(ns6__ArrayOfSearchResultSet);
			for (int i = 0; i < n; i++)
				((ns6__ArrayOfSearchResultSet*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ArrayOfSearchResultSet*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:SearchResultSet"))
	{	cp->type = SOAP_TYPE_ns6__SearchResultSet;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__SearchResultSet;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__SearchResultSet);
			((ns6__SearchResultSet*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__SearchResultSet[n];
			if (size)
				*size = n * sizeof(ns6__SearchResultSet);
			for (int i = 0; i < n; i++)
				((ns6__SearchResultSet*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__SearchResultSet*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:ArrayOfSearchRegion"))
	{	cp->type = SOAP_TYPE_ns6__ArrayOfSearchRegion;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__ArrayOfSearchRegion;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__ArrayOfSearchRegion);
			((ns6__ArrayOfSearchRegion*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__ArrayOfSearchRegion[n];
			if (size)
				*size = n * sizeof(ns6__ArrayOfSearchRegion);
			for (int i = 0; i < n; i++)
				((ns6__ArrayOfSearchRegion*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ArrayOfSearchRegion*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:SearchRegion"))
	{	cp->type = SOAP_TYPE_ns6__SearchRegion;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__SearchRegion;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__SearchRegion);
			((ns6__SearchRegion*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__SearchRegion[n];
			if (size)
				*size = n * sizeof(ns6__SearchRegion);
			for (int i = 0; i < n; i++)
				((ns6__SearchRegion*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__SearchRegion*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:ArrayOfAvailableFilter"))
	{	cp->type = SOAP_TYPE_ns6__ArrayOfAvailableFilter;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__ArrayOfAvailableFilter;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__ArrayOfAvailableFilter);
			((ns6__ArrayOfAvailableFilter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__ArrayOfAvailableFilter[n];
			if (size)
				*size = n * sizeof(ns6__ArrayOfAvailableFilter);
			for (int i = 0; i < n; i++)
				((ns6__ArrayOfAvailableFilter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ArrayOfAvailableFilter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:AvailableFilter"))
	{	cp->type = SOAP_TYPE_ns6__AvailableFilter;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__AvailableFilter;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__AvailableFilter);
			((ns6__AvailableFilter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__AvailableFilter[n];
			if (size)
				*size = n * sizeof(ns6__AvailableFilter);
			for (int i = 0; i < n; i++)
				((ns6__AvailableFilter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__AvailableFilter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:Neighborhood"))
	{	cp->type = SOAP_TYPE_ns6__Neighborhood;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__Neighborhood;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__Neighborhood);
			((ns6__Neighborhood*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__Neighborhood[n];
			if (size)
				*size = n * sizeof(ns6__Neighborhood);
			for (int i = 0; i < n; i++)
				((ns6__Neighborhood*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Neighborhood*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:Category"))
	{	cp->type = SOAP_TYPE_ns6__Category;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__Category;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__Category);
			((ns6__Category*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__Category[n];
			if (size)
				*size = n * sizeof(ns6__Category);
			for (int i = 0; i < n; i++)
				((ns6__Category*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Category*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:FilterValue"))
	{	cp->type = SOAP_TYPE_ns6__FilterValue;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__FilterValue;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__FilterValue);
			((ns6__FilterValue*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__FilterValue[n];
			if (size)
				*size = n * sizeof(ns6__FilterValue);
			for (int i = 0; i < n; i++)
				((ns6__FilterValue*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__FilterValue*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:ArrayOfCategoryCount"))
	{	cp->type = SOAP_TYPE_ns6__ArrayOfCategoryCount;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__ArrayOfCategoryCount;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__ArrayOfCategoryCount);
			((ns6__ArrayOfCategoryCount*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__ArrayOfCategoryCount[n];
			if (size)
				*size = n * sizeof(ns6__ArrayOfCategoryCount);
			for (int i = 0; i < n; i++)
				((ns6__ArrayOfCategoryCount*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ArrayOfCategoryCount*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:CategoryCount"))
	{	cp->type = SOAP_TYPE_ns6__CategoryCount;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__CategoryCount;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__CategoryCount);
			((ns6__CategoryCount*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__CategoryCount[n];
			if (size)
				*size = n * sizeof(ns6__CategoryCount);
			for (int i = 0; i < n; i++)
				((ns6__CategoryCount*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__CategoryCount*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:Parse"))
	{	cp->type = SOAP_TYPE_ns6__Parse;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__Parse;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__Parse);
			((ns6__Parse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__Parse[n];
			if (size)
				*size = n * sizeof(ns6__Parse);
			for (int i = 0; i < n; i++)
				((ns6__Parse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Parse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:ArrayOfSearchResultBase"))
	{	cp->type = SOAP_TYPE_ns6__ArrayOfSearchResultBase;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__ArrayOfSearchResultBase;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__ArrayOfSearchResultBase);
			((ns6__ArrayOfSearchResultBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__ArrayOfSearchResultBase[n];
			if (size)
				*size = n * sizeof(ns6__ArrayOfSearchResultBase);
			for (int i = 0; i < n; i++)
				((ns6__ArrayOfSearchResultBase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ArrayOfSearchResultBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:SearchResultBase"))
	{	cp->type = SOAP_TYPE_ns6__SearchResultBase;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__SearchResultBase;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__SearchResultBase);
			((ns6__SearchResultBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__SearchResultBase[n];
			if (size)
				*size = n * sizeof(ns6__SearchResultBase);
			for (int i = 0; i < n; i++)
				((ns6__SearchResultBase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__SearchResultBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:LocationData"))
	{	cp->type = SOAP_TYPE_ns6__LocationData;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__LocationData;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__LocationData);
			((ns6__LocationData*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__LocationData[n];
			if (size)
				*size = n * sizeof(ns6__LocationData);
			for (int i = 0; i < n; i++)
				((ns6__LocationData*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__LocationData*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:ArrayOfCategory"))
	{	cp->type = SOAP_TYPE_ns6__ArrayOfCategory;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__ArrayOfCategory;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__ArrayOfCategory);
			((ns6__ArrayOfCategory*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__ArrayOfCategory[n];
			if (size)
				*size = n * sizeof(ns6__ArrayOfCategory);
			for (int i = 0; i < n; i++)
				((ns6__ArrayOfCategory*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ArrayOfCategory*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:CategorySpecificPropertySet"))
	{	cp->type = SOAP_TYPE_ns6__CategorySpecificPropertySet;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__CategorySpecificPropertySet;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__CategorySpecificPropertySet);
			((ns6__CategorySpecificPropertySet*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__CategorySpecificPropertySet[n];
			if (size)
				*size = n * sizeof(ns6__CategorySpecificPropertySet);
			for (int i = 0; i < n; i++)
				((ns6__CategorySpecificPropertySet*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__CategorySpecificPropertySet*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:ArrayOfNeighborhood"))
	{	cp->type = SOAP_TYPE_ns6__ArrayOfNeighborhood;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__ArrayOfNeighborhood;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__ArrayOfNeighborhood);
			((ns6__ArrayOfNeighborhood*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__ArrayOfNeighborhood[n];
			if (size)
				*size = n * sizeof(ns6__ArrayOfNeighborhood);
			for (int i = 0; i < n; i++)
				((ns6__ArrayOfNeighborhood*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ArrayOfNeighborhood*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns7:ArrayOfstring"))
	{	cp->type = SOAP_TYPE_ns7__ArrayOfstring;
		if (n < 0)
		{	cp->ptr = (void*)new ns7__ArrayOfstring;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns7__ArrayOfstring);
			((ns7__ArrayOfstring*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns7__ArrayOfstring[n];
			if (size)
				*size = n * sizeof(ns7__ArrayOfstring);
			for (int i = 0; i < n; i++)
				((ns7__ArrayOfstring*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__ArrayOfstring*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns7:ArrayOfanyType"))
	{	cp->type = SOAP_TYPE_ns7__ArrayOfanyType;
		if (n < 0)
		{	cp->ptr = (void*)new ns7__ArrayOfanyType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns7__ArrayOfanyType);
			((ns7__ArrayOfanyType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns7__ArrayOfanyType[n];
			if (size)
				*size = n * sizeof(ns7__ArrayOfanyType);
			for (int i = 0; i < n; i++)
				((ns7__ArrayOfanyType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__ArrayOfanyType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns7:ArrayOfKeyValueOfNeighborhoodintkC8b0tr6"))
	{	cp->type = SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6;
		if (n < 0)
		{	cp->ptr = (void*)new ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6);
			((ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6[n];
			if (size)
				*size = n * sizeof(ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6);
			for (int i = 0; i < n; i++)
				((ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns7:ArrayOfKeyValueOfstringanyType"))
	{	cp->type = SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType;
		if (n < 0)
		{	cp->ptr = (void*)new ns7__ArrayOfKeyValueOfstringanyType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns7__ArrayOfKeyValueOfstringanyType);
			((ns7__ArrayOfKeyValueOfstringanyType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns7__ArrayOfKeyValueOfstringanyType[n];
			if (size)
				*size = n * sizeof(ns7__ArrayOfKeyValueOfstringanyType);
			for (int i = 0; i < n; i++)
				((ns7__ArrayOfKeyValueOfstringanyType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__ArrayOfKeyValueOfstringanyType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns7:ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_P9s"))
	{	cp->type = SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s;
		if (n < 0)
		{	cp->ptr = (void*)new ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
			((ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s[n];
			if (size)
				*size = n * sizeof(ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
			for (int i = 0; i < n; i++)
				((ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns10:GeocodeOptions"))
	{	cp->type = SOAP_TYPE_ns10__GeocodeOptions;
		if (n < 0)
		{	cp->ptr = (void*)new ns10__GeocodeOptions;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns10__GeocodeOptions);
			((ns10__GeocodeOptions*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns10__GeocodeOptions[n];
			if (size)
				*size = n * sizeof(ns10__GeocodeOptions);
			for (int i = 0; i < n; i++)
				((ns10__GeocodeOptions*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns10__GeocodeOptions*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns10:ArrayOfFilterBase"))
	{	cp->type = SOAP_TYPE_ns10__ArrayOfFilterBase;
		if (n < 0)
		{	cp->ptr = (void*)new ns10__ArrayOfFilterBase;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns10__ArrayOfFilterBase);
			((ns10__ArrayOfFilterBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns10__ArrayOfFilterBase[n];
			if (size)
				*size = n * sizeof(ns10__ArrayOfFilterBase);
			for (int i = 0; i < n; i++)
				((ns10__ArrayOfFilterBase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns10__ArrayOfFilterBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns10:FilterBase"))
	{	cp->type = SOAP_TYPE_ns10__FilterBase;
		if (n < 0)
		{	cp->ptr = (void*)new ns10__FilterBase;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns10__FilterBase);
			((ns10__FilterBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns10__FilterBase[n];
			if (size)
				*size = n * sizeof(ns10__FilterBase);
			for (int i = 0; i < n; i++)
				((ns10__FilterBase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns10__FilterBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:ImageryMetadataOptions"))
	{	cp->type = SOAP_TYPE_ns13__ImageryMetadataOptions;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__ImageryMetadataOptions;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__ImageryMetadataOptions);
			((ns13__ImageryMetadataOptions*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__ImageryMetadataOptions[n];
			if (size)
				*size = n * sizeof(ns13__ImageryMetadataOptions);
			for (int i = 0; i < n; i++)
				((ns13__ImageryMetadataOptions*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__ImageryMetadataOptions*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:ArrayOfImageryMetadataResult"))
	{	cp->type = SOAP_TYPE_ns13__ArrayOfImageryMetadataResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__ArrayOfImageryMetadataResult;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__ArrayOfImageryMetadataResult);
			((ns13__ArrayOfImageryMetadataResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__ArrayOfImageryMetadataResult[n];
			if (size)
				*size = n * sizeof(ns13__ArrayOfImageryMetadataResult);
			for (int i = 0; i < n; i++)
				((ns13__ArrayOfImageryMetadataResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__ArrayOfImageryMetadataResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:ImageryMetadataResult"))
	{	cp->type = SOAP_TYPE_ns13__ImageryMetadataResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__ImageryMetadataResult;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__ImageryMetadataResult);
			((ns13__ImageryMetadataResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__ImageryMetadataResult[n];
			if (size)
				*size = n * sizeof(ns13__ImageryMetadataResult);
			for (int i = 0; i < n; i++)
				((ns13__ImageryMetadataResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__ImageryMetadataResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:ArrayOfImageryProvider"))
	{	cp->type = SOAP_TYPE_ns13__ArrayOfImageryProvider;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__ArrayOfImageryProvider;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__ArrayOfImageryProvider);
			((ns13__ArrayOfImageryProvider*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__ArrayOfImageryProvider[n];
			if (size)
				*size = n * sizeof(ns13__ArrayOfImageryProvider);
			for (int i = 0; i < n; i++)
				((ns13__ArrayOfImageryProvider*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__ArrayOfImageryProvider*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:ImageryProvider"))
	{	cp->type = SOAP_TYPE_ns13__ImageryProvider;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__ImageryProvider;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__ImageryProvider);
			((ns13__ImageryProvider*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__ImageryProvider[n];
			if (size)
				*size = n * sizeof(ns13__ImageryProvider);
			for (int i = 0; i < n; i++)
				((ns13__ImageryProvider*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__ImageryProvider*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:ArrayOfCoverageArea"))
	{	cp->type = SOAP_TYPE_ns13__ArrayOfCoverageArea;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__ArrayOfCoverageArea;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__ArrayOfCoverageArea);
			((ns13__ArrayOfCoverageArea*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__ArrayOfCoverageArea[n];
			if (size)
				*size = n * sizeof(ns13__ArrayOfCoverageArea);
			for (int i = 0; i < n; i++)
				((ns13__ArrayOfCoverageArea*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__ArrayOfCoverageArea*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:CoverageArea"))
	{	cp->type = SOAP_TYPE_ns13__CoverageArea;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__CoverageArea;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__CoverageArea);
			((ns13__CoverageArea*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__CoverageArea[n];
			if (size)
				*size = n * sizeof(ns13__CoverageArea);
			for (int i = 0; i < n; i++)
				((ns13__CoverageArea*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__CoverageArea*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:MapUriOptions"))
	{	cp->type = SOAP_TYPE_ns13__MapUriOptions;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__MapUriOptions;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__MapUriOptions);
			((ns13__MapUriOptions*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__MapUriOptions[n];
			if (size)
				*size = n * sizeof(ns13__MapUriOptions);
			for (int i = 0; i < n; i++)
				((ns13__MapUriOptions*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__MapUriOptions*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:RouteOptions"))
	{	cp->type = SOAP_TYPE_ns16__RouteOptions;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__RouteOptions;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__RouteOptions);
			((ns16__RouteOptions*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__RouteOptions[n];
			if (size)
				*size = n * sizeof(ns16__RouteOptions);
			for (int i = 0; i < n; i++)
				((ns16__RouteOptions*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__RouteOptions*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:ArrayOfWaypoint"))
	{	cp->type = SOAP_TYPE_ns16__ArrayOfWaypoint;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__ArrayOfWaypoint;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__ArrayOfWaypoint);
			((ns16__ArrayOfWaypoint*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__ArrayOfWaypoint[n];
			if (size)
				*size = n * sizeof(ns16__ArrayOfWaypoint);
			for (int i = 0; i < n; i++)
				((ns16__ArrayOfWaypoint*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__ArrayOfWaypoint*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:Waypoint"))
	{	cp->type = SOAP_TYPE_ns16__Waypoint;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__Waypoint;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__Waypoint);
			((ns16__Waypoint*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__Waypoint[n];
			if (size)
				*size = n * sizeof(ns16__Waypoint);
			for (int i = 0; i < n; i++)
				((ns16__Waypoint*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__Waypoint*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:RouteResult"))
	{	cp->type = SOAP_TYPE_ns16__RouteResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__RouteResult;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__RouteResult);
			((ns16__RouteResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__RouteResult[n];
			if (size)
				*size = n * sizeof(ns16__RouteResult);
			for (int i = 0; i < n; i++)
				((ns16__RouteResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__RouteResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:ArrayOfRouteLeg"))
	{	cp->type = SOAP_TYPE_ns16__ArrayOfRouteLeg;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__ArrayOfRouteLeg;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__ArrayOfRouteLeg);
			((ns16__ArrayOfRouteLeg*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__ArrayOfRouteLeg[n];
			if (size)
				*size = n * sizeof(ns16__ArrayOfRouteLeg);
			for (int i = 0; i < n; i++)
				((ns16__ArrayOfRouteLeg*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__ArrayOfRouteLeg*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:RouteLeg"))
	{	cp->type = SOAP_TYPE_ns16__RouteLeg;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__RouteLeg;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__RouteLeg);
			((ns16__RouteLeg*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__RouteLeg[n];
			if (size)
				*size = n * sizeof(ns16__RouteLeg);
			for (int i = 0; i < n; i++)
				((ns16__RouteLeg*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__RouteLeg*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:ArrayOfItineraryItem"))
	{	cp->type = SOAP_TYPE_ns16__ArrayOfItineraryItem;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__ArrayOfItineraryItem;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__ArrayOfItineraryItem);
			((ns16__ArrayOfItineraryItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__ArrayOfItineraryItem[n];
			if (size)
				*size = n * sizeof(ns16__ArrayOfItineraryItem);
			for (int i = 0; i < n; i++)
				((ns16__ArrayOfItineraryItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__ArrayOfItineraryItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:ItineraryItem"))
	{	cp->type = SOAP_TYPE_ns16__ItineraryItem;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__ItineraryItem;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__ItineraryItem);
			((ns16__ItineraryItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__ItineraryItem[n];
			if (size)
				*size = n * sizeof(ns16__ItineraryItem);
			for (int i = 0; i < n; i++)
				((ns16__ItineraryItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__ItineraryItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:ArrayOfItineraryItemHint"))
	{	cp->type = SOAP_TYPE_ns16__ArrayOfItineraryItemHint;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__ArrayOfItineraryItemHint;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__ArrayOfItineraryItemHint);
			((ns16__ArrayOfItineraryItemHint*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__ArrayOfItineraryItemHint[n];
			if (size)
				*size = n * sizeof(ns16__ArrayOfItineraryItemHint);
			for (int i = 0; i < n; i++)
				((ns16__ArrayOfItineraryItemHint*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__ArrayOfItineraryItemHint*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:ItineraryItemHint"))
	{	cp->type = SOAP_TYPE_ns16__ItineraryItemHint;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__ItineraryItemHint;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__ItineraryItemHint);
			((ns16__ItineraryItemHint*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__ItineraryItemHint[n];
			if (size)
				*size = n * sizeof(ns16__ItineraryItemHint);
			for (int i = 0; i < n; i++)
				((ns16__ItineraryItemHint*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__ItineraryItemHint*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:RouteSummary"))
	{	cp->type = SOAP_TYPE_ns16__RouteSummary;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__RouteSummary;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__RouteSummary);
			((ns16__RouteSummary*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__RouteSummary[n];
			if (size)
				*size = n * sizeof(ns16__RouteSummary);
			for (int i = 0; i < n; i++)
				((ns16__RouteSummary*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__RouteSummary*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:ArrayOfItineraryItemWarning"))
	{	cp->type = SOAP_TYPE_ns16__ArrayOfItineraryItemWarning;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__ArrayOfItineraryItemWarning;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__ArrayOfItineraryItemWarning);
			((ns16__ArrayOfItineraryItemWarning*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__ArrayOfItineraryItemWarning[n];
			if (size)
				*size = n * sizeof(ns16__ArrayOfItineraryItemWarning);
			for (int i = 0; i < n; i++)
				((ns16__ArrayOfItineraryItemWarning*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__ArrayOfItineraryItemWarning*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:ItineraryItemWarning"))
	{	cp->type = SOAP_TYPE_ns16__ItineraryItemWarning;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__ItineraryItemWarning;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__ItineraryItemWarning);
			((ns16__ItineraryItemWarning*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__ItineraryItemWarning[n];
			if (size)
				*size = n * sizeof(ns16__ItineraryItemWarning);
			for (int i = 0; i < n; i++)
				((ns16__ItineraryItemWarning*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__ItineraryItemWarning*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:RoutePath"))
	{	cp->type = SOAP_TYPE_ns16__RoutePath;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__RoutePath;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__RoutePath);
			((ns16__RoutePath*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__RoutePath[n];
			if (size)
				*size = n * sizeof(ns16__RoutePath);
			for (int i = 0; i < n; i++)
				((ns16__RoutePath*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__RoutePath*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:ArrayOfRouteResult"))
	{	cp->type = SOAP_TYPE_ns16__ArrayOfRouteResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__ArrayOfRouteResult;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__ArrayOfRouteResult);
			((ns16__ArrayOfRouteResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__ArrayOfRouteResult[n];
			if (size)
				*size = n * sizeof(ns16__ArrayOfRouteResult);
			for (int i = 0; i < n; i++)
				((ns16__ArrayOfRouteResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__ArrayOfRouteResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:UserLocation"))
	{	cp->type = SOAP_TYPE_ns4__UserLocation;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__UserLocation;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__UserLocation);
			((ns4__UserLocation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__UserLocation[n];
			if (size)
				*size = n * sizeof(ns4__UserLocation);
			for (int i = 0; i < n; i++)
				((ns4__UserLocation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__UserLocation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:GeocodeLocation"))
	{	cp->type = SOAP_TYPE_ns4__GeocodeLocation;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__GeocodeLocation;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__GeocodeLocation);
			((ns4__GeocodeLocation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__GeocodeLocation[n];
			if (size)
				*size = n * sizeof(ns4__GeocodeLocation);
			for (int i = 0; i < n; i++)
				((ns4__GeocodeLocation*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__GeocodeLocation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:Rectangle"))
	{	cp->type = SOAP_TYPE_ns4__Rectangle;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__Rectangle;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__Rectangle);
			((ns4__Rectangle*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__Rectangle[n];
			if (size)
				*size = n * sizeof(ns4__Rectangle);
			for (int i = 0; i < n; i++)
				((ns4__Rectangle*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__Rectangle*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:Circle"))
	{	cp->type = SOAP_TYPE_ns4__Circle;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__Circle;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__Circle);
			((ns4__Circle*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__Circle[n];
			if (size)
				*size = n * sizeof(ns4__Circle);
			for (int i = 0; i < n; i++)
				((ns4__Circle*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__Circle*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:Polygon"))
	{	cp->type = SOAP_TYPE_ns4__Polygon;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__Polygon;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__Polygon);
			((ns4__Polygon*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__Polygon[n];
			if (size)
				*size = n * sizeof(ns4__Polygon);
			for (int i = 0; i < n; i++)
				((ns4__Polygon*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__Polygon*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:FilterExpression"))
	{	cp->type = SOAP_TYPE_ns4__FilterExpression;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__FilterExpression;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__FilterExpression);
			((ns4__FilterExpression*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__FilterExpression[n];
			if (size)
				*size = n * sizeof(ns4__FilterExpression);
			for (int i = 0; i < n; i++)
				((ns4__FilterExpression*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__FilterExpression*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:FilterExpressionClause"))
	{	cp->type = SOAP_TYPE_ns4__FilterExpressionClause;
		if (n < 0)
		{	cp->ptr = (void*)new ns4__FilterExpressionClause;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns4__FilterExpressionClause);
			((ns4__FilterExpressionClause*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns4__FilterExpressionClause[n];
			if (size)
				*size = n * sizeof(ns4__FilterExpressionClause);
			for (int i = 0; i < n; i++)
				((ns4__FilterExpressionClause*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__FilterExpressionClause*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:SearchRequest"))
	{	cp->type = SOAP_TYPE_ns6__SearchRequest;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__SearchRequest;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__SearchRequest);
			((ns6__SearchRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__SearchRequest[n];
			if (size)
				*size = n * sizeof(ns6__SearchRequest);
			for (int i = 0; i < n; i++)
				((ns6__SearchRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__SearchRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:SearchResponse"))
	{	cp->type = SOAP_TYPE_ns6__SearchResponse;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__SearchResponse;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__SearchResponse);
			((ns6__SearchResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__SearchResponse[n];
			if (size)
				*size = n * sizeof(ns6__SearchResponse);
			for (int i = 0; i < n; i++)
				((ns6__SearchResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__SearchResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:RangeFilter"))
	{	cp->type = SOAP_TYPE_ns6__RangeFilter;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__RangeFilter;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__RangeFilter);
			((ns6__RangeFilter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__RangeFilter[n];
			if (size)
				*size = n * sizeof(ns6__RangeFilter);
			for (int i = 0; i < n; i++)
				((ns6__RangeFilter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__RangeFilter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:ValueListFilter"))
	{	cp->type = SOAP_TYPE_ns6__ValueListFilter;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__ValueListFilter;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__ValueListFilter);
			((ns6__ValueListFilter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__ValueListFilter[n];
			if (size)
				*size = n * sizeof(ns6__ValueListFilter);
			for (int i = 0; i < n; i++)
				((ns6__ValueListFilter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ValueListFilter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:CommunityContentSearchResult"))
	{	cp->type = SOAP_TYPE_ns6__CommunityContentSearchResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__CommunityContentSearchResult;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__CommunityContentSearchResult);
			((ns6__CommunityContentSearchResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__CommunityContentSearchResult[n];
			if (size)
				*size = n * sizeof(ns6__CommunityContentSearchResult);
			for (int i = 0; i < n; i++)
				((ns6__CommunityContentSearchResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__CommunityContentSearchResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:BusinessSearchResult"))
	{	cp->type = SOAP_TYPE_ns6__BusinessSearchResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__BusinessSearchResult;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__BusinessSearchResult);
			((ns6__BusinessSearchResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__BusinessSearchResult[n];
			if (size)
				*size = n * sizeof(ns6__BusinessSearchResult);
			for (int i = 0; i < n; i++)
				((ns6__BusinessSearchResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__BusinessSearchResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:PersonSearchResult"))
	{	cp->type = SOAP_TYPE_ns6__PersonSearchResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__PersonSearchResult;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__PersonSearchResult);
			((ns6__PersonSearchResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__PersonSearchResult[n];
			if (size)
				*size = n * sizeof(ns6__PersonSearchResult);
			for (int i = 0; i < n; i++)
				((ns6__PersonSearchResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__PersonSearchResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:SearchPoint"))
	{	cp->type = SOAP_TYPE_ns6__SearchPoint;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__SearchPoint;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__SearchPoint);
			((ns6__SearchPoint*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__SearchPoint[n];
			if (size)
				*size = n * sizeof(ns6__SearchPoint);
			for (int i = 0; i < n; i++)
				((ns6__SearchPoint*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__SearchPoint*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns10:GeocodeRequest"))
	{	cp->type = SOAP_TYPE_ns10__GeocodeRequest;
		if (n < 0)
		{	cp->ptr = (void*)new ns10__GeocodeRequest;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns10__GeocodeRequest);
			((ns10__GeocodeRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns10__GeocodeRequest[n];
			if (size)
				*size = n * sizeof(ns10__GeocodeRequest);
			for (int i = 0; i < n; i++)
				((ns10__GeocodeRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns10__GeocodeRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns10:ConfidenceFilter"))
	{	cp->type = SOAP_TYPE_ns10__ConfidenceFilter;
		if (n < 0)
		{	cp->ptr = (void*)new ns10__ConfidenceFilter;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns10__ConfidenceFilter);
			((ns10__ConfidenceFilter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns10__ConfidenceFilter[n];
			if (size)
				*size = n * sizeof(ns10__ConfidenceFilter);
			for (int i = 0; i < n; i++)
				((ns10__ConfidenceFilter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns10__ConfidenceFilter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns10:GeocodeResponse"))
	{	cp->type = SOAP_TYPE_ns10__GeocodeResponse;
		if (n < 0)
		{	cp->ptr = (void*)new ns10__GeocodeResponse;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns10__GeocodeResponse);
			((ns10__GeocodeResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns10__GeocodeResponse[n];
			if (size)
				*size = n * sizeof(ns10__GeocodeResponse);
			for (int i = 0; i < n; i++)
				((ns10__GeocodeResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns10__GeocodeResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns10:ReverseGeocodeRequest"))
	{	cp->type = SOAP_TYPE_ns10__ReverseGeocodeRequest;
		if (n < 0)
		{	cp->ptr = (void*)new ns10__ReverseGeocodeRequest;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns10__ReverseGeocodeRequest);
			((ns10__ReverseGeocodeRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns10__ReverseGeocodeRequest[n];
			if (size)
				*size = n * sizeof(ns10__ReverseGeocodeRequest);
			for (int i = 0; i < n; i++)
				((ns10__ReverseGeocodeRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns10__ReverseGeocodeRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:ImageryMetadataRequest"))
	{	cp->type = SOAP_TYPE_ns13__ImageryMetadataRequest;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__ImageryMetadataRequest;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__ImageryMetadataRequest);
			((ns13__ImageryMetadataRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__ImageryMetadataRequest[n];
			if (size)
				*size = n * sizeof(ns13__ImageryMetadataRequest);
			for (int i = 0; i < n; i++)
				((ns13__ImageryMetadataRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__ImageryMetadataRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:ImageryMetadataResponse"))
	{	cp->type = SOAP_TYPE_ns13__ImageryMetadataResponse;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__ImageryMetadataResponse;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__ImageryMetadataResponse);
			((ns13__ImageryMetadataResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__ImageryMetadataResponse[n];
			if (size)
				*size = n * sizeof(ns13__ImageryMetadataResponse);
			for (int i = 0; i < n; i++)
				((ns13__ImageryMetadataResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__ImageryMetadataResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:ImageryMetadataBirdseyeResult"))
	{	cp->type = SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__ImageryMetadataBirdseyeResult;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__ImageryMetadataBirdseyeResult);
			((ns13__ImageryMetadataBirdseyeResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__ImageryMetadataBirdseyeResult[n];
			if (size)
				*size = n * sizeof(ns13__ImageryMetadataBirdseyeResult);
			for (int i = 0; i < n; i++)
				((ns13__ImageryMetadataBirdseyeResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__ImageryMetadataBirdseyeResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:MapUriRequest"))
	{	cp->type = SOAP_TYPE_ns13__MapUriRequest;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__MapUriRequest;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__MapUriRequest);
			((ns13__MapUriRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__MapUriRequest[n];
			if (size)
				*size = n * sizeof(ns13__MapUriRequest);
			for (int i = 0; i < n; i++)
				((ns13__MapUriRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__MapUriRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:MapUriResponse"))
	{	cp->type = SOAP_TYPE_ns13__MapUriResponse;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__MapUriResponse;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns13__MapUriResponse);
			((ns13__MapUriResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__MapUriResponse[n];
			if (size)
				*size = n * sizeof(ns13__MapUriResponse);
			for (int i = 0; i < n; i++)
				((ns13__MapUriResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__MapUriResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:RouteRequest"))
	{	cp->type = SOAP_TYPE_ns16__RouteRequest;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__RouteRequest;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__RouteRequest);
			((ns16__RouteRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__RouteRequest[n];
			if (size)
				*size = n * sizeof(ns16__RouteRequest);
			for (int i = 0; i < n; i++)
				((ns16__RouteRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__RouteRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:RouteResponse"))
	{	cp->type = SOAP_TYPE_ns16__RouteResponse;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__RouteResponse;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__RouteResponse);
			((ns16__RouteResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__RouteResponse[n];
			if (size)
				*size = n * sizeof(ns16__RouteResponse);
			for (int i = 0; i < n; i++)
				((ns16__RouteResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__RouteResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:MajorRoutesRequest"))
	{	cp->type = SOAP_TYPE_ns16__MajorRoutesRequest;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__MajorRoutesRequest;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__MajorRoutesRequest);
			((ns16__MajorRoutesRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__MajorRoutesRequest[n];
			if (size)
				*size = n * sizeof(ns16__MajorRoutesRequest);
			for (int i = 0; i < n; i++)
				((ns16__MajorRoutesRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__MajorRoutesRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:MajorRoutesOptions"))
	{	cp->type = SOAP_TYPE_ns16__MajorRoutesOptions;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__MajorRoutesOptions;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__MajorRoutesOptions);
			((ns16__MajorRoutesOptions*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__MajorRoutesOptions[n];
			if (size)
				*size = n * sizeof(ns16__MajorRoutesOptions);
			for (int i = 0; i < n; i++)
				((ns16__MajorRoutesOptions*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__MajorRoutesOptions*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns16:MajorRoutesResponse"))
	{	cp->type = SOAP_TYPE_ns16__MajorRoutesResponse;
		if (n < 0)
		{	cp->ptr = (void*)new ns16__MajorRoutesResponse;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns16__MajorRoutesResponse);
			((ns16__MajorRoutesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns16__MajorRoutesResponse[n];
			if (size)
				*size = n * sizeof(ns16__MajorRoutesResponse);
			for (int i = 0; i < n; i++)
				((ns16__MajorRoutesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns16__MajorRoutesResponse*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anyType;
		if (size)
			*size = sizeof(xsd__anyType);
		((xsd__anyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__anyType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__anyType);
		for (int i = 0; i < n; i++)
			((xsd__anyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
	*(xsd__anyType*)p = *(xsd__anyType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__Search(struct soap *soap, struct __ns6__Search *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__Search = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__Search(struct soap *soap, const struct __ns6__Search *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__Search(soap, &a->ns3__Search);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__Search(struct soap *soap, const struct __ns6__Search *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__Search(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__Search(struct soap *soap, const char *tag, int id, const struct __ns6__Search *a, const char *type)
{
	if (soap_out_PointerTo_ns3__Search(soap, "ns3:Search", -1, &a->ns3__Search, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__Search * SOAP_FMAC4 soap_get___ns6__Search(struct soap *soap, struct __ns6__Search *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__Search(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns6__Search * SOAP_FMAC4 soap_in___ns6__Search(struct soap *soap, const char *tag, struct __ns6__Search *a, const char *type)
{
	size_t soap_flag_ns3__Search = 1;
	short soap_flag;
	a = (struct __ns6__Search *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__Search, sizeof(struct __ns6__Search), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__Search(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__Search && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__Search(soap, "ns3:Search", &a->ns3__Search, ""))
				{	soap_flag_ns3__Search--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns6__Search * SOAP_FMAC4 soap_instantiate___ns6__Search(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__Search(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__Search, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns6__Search;
		if (size)
			*size = sizeof(struct __ns6__Search);
	}
	else
	{	cp->ptr = (void*)new struct __ns6__Search[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__Search);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__Search*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__Search(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__Search %p -> %p\n", q, p));
	*(struct __ns6__Search*)p = *(struct __ns6__Search*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns16__CalculateRoutesFromMajorRoads(struct soap *soap, struct __ns16__CalculateRoutesFromMajorRoads *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns15__CalculateRoutesFromMajorRoads = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns16__CalculateRoutesFromMajorRoads(struct soap *soap, const struct __ns16__CalculateRoutesFromMajorRoads *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns15__CalculateRoutesFromMajorRoads(soap, &a->ns15__CalculateRoutesFromMajorRoads);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns16__CalculateRoutesFromMajorRoads(struct soap *soap, const struct __ns16__CalculateRoutesFromMajorRoads *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns16__CalculateRoutesFromMajorRoads(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns16__CalculateRoutesFromMajorRoads(struct soap *soap, const char *tag, int id, const struct __ns16__CalculateRoutesFromMajorRoads *a, const char *type)
{
	if (soap_out_PointerTo_ns15__CalculateRoutesFromMajorRoads(soap, "ns15:CalculateRoutesFromMajorRoads", -1, &a->ns15__CalculateRoutesFromMajorRoads, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns16__CalculateRoutesFromMajorRoads * SOAP_FMAC4 soap_get___ns16__CalculateRoutesFromMajorRoads(struct soap *soap, struct __ns16__CalculateRoutesFromMajorRoads *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns16__CalculateRoutesFromMajorRoads(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns16__CalculateRoutesFromMajorRoads * SOAP_FMAC4 soap_in___ns16__CalculateRoutesFromMajorRoads(struct soap *soap, const char *tag, struct __ns16__CalculateRoutesFromMajorRoads *a, const char *type)
{
	size_t soap_flag_ns15__CalculateRoutesFromMajorRoads = 1;
	short soap_flag;
	a = (struct __ns16__CalculateRoutesFromMajorRoads *)soap_id_enter(soap, "", a, SOAP_TYPE___ns16__CalculateRoutesFromMajorRoads, sizeof(struct __ns16__CalculateRoutesFromMajorRoads), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns16__CalculateRoutesFromMajorRoads(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns15__CalculateRoutesFromMajorRoads && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns15__CalculateRoutesFromMajorRoads(soap, "ns15:CalculateRoutesFromMajorRoads", &a->ns15__CalculateRoutesFromMajorRoads, ""))
				{	soap_flag_ns15__CalculateRoutesFromMajorRoads--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns16__CalculateRoutesFromMajorRoads * SOAP_FMAC4 soap_instantiate___ns16__CalculateRoutesFromMajorRoads(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns16__CalculateRoutesFromMajorRoads(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns16__CalculateRoutesFromMajorRoads, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns16__CalculateRoutesFromMajorRoads;
		if (size)
			*size = sizeof(struct __ns16__CalculateRoutesFromMajorRoads);
	}
	else
	{	cp->ptr = (void*)new struct __ns16__CalculateRoutesFromMajorRoads[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns16__CalculateRoutesFromMajorRoads);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns16__CalculateRoutesFromMajorRoads*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns16__CalculateRoutesFromMajorRoads(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns16__CalculateRoutesFromMajorRoads %p -> %p\n", q, p));
	*(struct __ns16__CalculateRoutesFromMajorRoads*)p = *(struct __ns16__CalculateRoutesFromMajorRoads*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns16__CalculateRoute(struct soap *soap, struct __ns16__CalculateRoute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns15__CalculateRoute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns16__CalculateRoute(struct soap *soap, const struct __ns16__CalculateRoute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns15__CalculateRoute(soap, &a->ns15__CalculateRoute);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns16__CalculateRoute(struct soap *soap, const struct __ns16__CalculateRoute *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns16__CalculateRoute(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns16__CalculateRoute(struct soap *soap, const char *tag, int id, const struct __ns16__CalculateRoute *a, const char *type)
{
	if (soap_out_PointerTo_ns15__CalculateRoute(soap, "ns15:CalculateRoute", -1, &a->ns15__CalculateRoute, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns16__CalculateRoute * SOAP_FMAC4 soap_get___ns16__CalculateRoute(struct soap *soap, struct __ns16__CalculateRoute *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns16__CalculateRoute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns16__CalculateRoute * SOAP_FMAC4 soap_in___ns16__CalculateRoute(struct soap *soap, const char *tag, struct __ns16__CalculateRoute *a, const char *type)
{
	size_t soap_flag_ns15__CalculateRoute = 1;
	short soap_flag;
	a = (struct __ns16__CalculateRoute *)soap_id_enter(soap, "", a, SOAP_TYPE___ns16__CalculateRoute, sizeof(struct __ns16__CalculateRoute), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns16__CalculateRoute(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns15__CalculateRoute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns15__CalculateRoute(soap, "ns15:CalculateRoute", &a->ns15__CalculateRoute, ""))
				{	soap_flag_ns15__CalculateRoute--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns16__CalculateRoute * SOAP_FMAC4 soap_instantiate___ns16__CalculateRoute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns16__CalculateRoute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns16__CalculateRoute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns16__CalculateRoute;
		if (size)
			*size = sizeof(struct __ns16__CalculateRoute);
	}
	else
	{	cp->ptr = (void*)new struct __ns16__CalculateRoute[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns16__CalculateRoute);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns16__CalculateRoute*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns16__CalculateRoute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns16__CalculateRoute %p -> %p\n", q, p));
	*(struct __ns16__CalculateRoute*)p = *(struct __ns16__CalculateRoute*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetMapUri(struct soap *soap, struct __ns13__GetMapUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns12__GetMapUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetMapUri(struct soap *soap, const struct __ns13__GetMapUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns12__GetMapUri(soap, &a->ns12__GetMapUri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetMapUri(struct soap *soap, const struct __ns13__GetMapUri *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetMapUri(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetMapUri(struct soap *soap, const char *tag, int id, const struct __ns13__GetMapUri *a, const char *type)
{
	if (soap_out_PointerTo_ns12__GetMapUri(soap, "ns12:GetMapUri", -1, &a->ns12__GetMapUri, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetMapUri * SOAP_FMAC4 soap_get___ns13__GetMapUri(struct soap *soap, struct __ns13__GetMapUri *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetMapUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns13__GetMapUri * SOAP_FMAC4 soap_in___ns13__GetMapUri(struct soap *soap, const char *tag, struct __ns13__GetMapUri *a, const char *type)
{
	size_t soap_flag_ns12__GetMapUri = 1;
	short soap_flag;
	a = (struct __ns13__GetMapUri *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetMapUri, sizeof(struct __ns13__GetMapUri), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetMapUri(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns12__GetMapUri && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns12__GetMapUri(soap, "ns12:GetMapUri", &a->ns12__GetMapUri, ""))
				{	soap_flag_ns12__GetMapUri--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns13__GetMapUri * SOAP_FMAC4 soap_instantiate___ns13__GetMapUri(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetMapUri(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetMapUri, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns13__GetMapUri;
		if (size)
			*size = sizeof(struct __ns13__GetMapUri);
	}
	else
	{	cp->ptr = (void*)new struct __ns13__GetMapUri[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetMapUri);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetMapUri*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetMapUri(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetMapUri %p -> %p\n", q, p));
	*(struct __ns13__GetMapUri*)p = *(struct __ns13__GetMapUri*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__GetImageryMetadata(struct soap *soap, struct __ns13__GetImageryMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns12__GetImageryMetadata = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__GetImageryMetadata(struct soap *soap, const struct __ns13__GetImageryMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns12__GetImageryMetadata(soap, &a->ns12__GetImageryMetadata);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__GetImageryMetadata(struct soap *soap, const struct __ns13__GetImageryMetadata *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns13__GetImageryMetadata(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__GetImageryMetadata(struct soap *soap, const char *tag, int id, const struct __ns13__GetImageryMetadata *a, const char *type)
{
	if (soap_out_PointerTo_ns12__GetImageryMetadata(soap, "ns12:GetImageryMetadata", -1, &a->ns12__GetImageryMetadata, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__GetImageryMetadata * SOAP_FMAC4 soap_get___ns13__GetImageryMetadata(struct soap *soap, struct __ns13__GetImageryMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__GetImageryMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns13__GetImageryMetadata * SOAP_FMAC4 soap_in___ns13__GetImageryMetadata(struct soap *soap, const char *tag, struct __ns13__GetImageryMetadata *a, const char *type)
{
	size_t soap_flag_ns12__GetImageryMetadata = 1;
	short soap_flag;
	a = (struct __ns13__GetImageryMetadata *)soap_id_enter(soap, "", a, SOAP_TYPE___ns13__GetImageryMetadata, sizeof(struct __ns13__GetImageryMetadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns13__GetImageryMetadata(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns12__GetImageryMetadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns12__GetImageryMetadata(soap, "ns12:GetImageryMetadata", &a->ns12__GetImageryMetadata, ""))
				{	soap_flag_ns12__GetImageryMetadata--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns13__GetImageryMetadata * SOAP_FMAC4 soap_instantiate___ns13__GetImageryMetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns13__GetImageryMetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns13__GetImageryMetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns13__GetImageryMetadata;
		if (size)
			*size = sizeof(struct __ns13__GetImageryMetadata);
	}
	else
	{	cp->ptr = (void*)new struct __ns13__GetImageryMetadata[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns13__GetImageryMetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns13__GetImageryMetadata*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns13__GetImageryMetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns13__GetImageryMetadata %p -> %p\n", q, p));
	*(struct __ns13__GetImageryMetadata*)p = *(struct __ns13__GetImageryMetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns10__ReverseGeocode(struct soap *soap, struct __ns10__ReverseGeocode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns9__ReverseGeocode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns10__ReverseGeocode(struct soap *soap, const struct __ns10__ReverseGeocode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns9__ReverseGeocode(soap, &a->ns9__ReverseGeocode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns10__ReverseGeocode(struct soap *soap, const struct __ns10__ReverseGeocode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns10__ReverseGeocode(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns10__ReverseGeocode(struct soap *soap, const char *tag, int id, const struct __ns10__ReverseGeocode *a, const char *type)
{
	if (soap_out_PointerTo_ns9__ReverseGeocode(soap, "ns9:ReverseGeocode", -1, &a->ns9__ReverseGeocode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns10__ReverseGeocode * SOAP_FMAC4 soap_get___ns10__ReverseGeocode(struct soap *soap, struct __ns10__ReverseGeocode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns10__ReverseGeocode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns10__ReverseGeocode * SOAP_FMAC4 soap_in___ns10__ReverseGeocode(struct soap *soap, const char *tag, struct __ns10__ReverseGeocode *a, const char *type)
{
	size_t soap_flag_ns9__ReverseGeocode = 1;
	short soap_flag;
	a = (struct __ns10__ReverseGeocode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns10__ReverseGeocode, sizeof(struct __ns10__ReverseGeocode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns10__ReverseGeocode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns9__ReverseGeocode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns9__ReverseGeocode(soap, "ns9:ReverseGeocode", &a->ns9__ReverseGeocode, ""))
				{	soap_flag_ns9__ReverseGeocode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns10__ReverseGeocode * SOAP_FMAC4 soap_instantiate___ns10__ReverseGeocode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns10__ReverseGeocode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns10__ReverseGeocode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns10__ReverseGeocode;
		if (size)
			*size = sizeof(struct __ns10__ReverseGeocode);
	}
	else
	{	cp->ptr = (void*)new struct __ns10__ReverseGeocode[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns10__ReverseGeocode);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns10__ReverseGeocode*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns10__ReverseGeocode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns10__ReverseGeocode %p -> %p\n", q, p));
	*(struct __ns10__ReverseGeocode*)p = *(struct __ns10__ReverseGeocode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns10__Geocode(struct soap *soap, struct __ns10__Geocode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns9__Geocode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns10__Geocode(struct soap *soap, const struct __ns10__Geocode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns9__Geocode(soap, &a->ns9__Geocode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns10__Geocode(struct soap *soap, const struct __ns10__Geocode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns10__Geocode(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns10__Geocode(struct soap *soap, const char *tag, int id, const struct __ns10__Geocode *a, const char *type)
{
	if (soap_out_PointerTo_ns9__Geocode(soap, "ns9:Geocode", -1, &a->ns9__Geocode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns10__Geocode * SOAP_FMAC4 soap_get___ns10__Geocode(struct soap *soap, struct __ns10__Geocode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns10__Geocode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns10__Geocode * SOAP_FMAC4 soap_in___ns10__Geocode(struct soap *soap, const char *tag, struct __ns10__Geocode *a, const char *type)
{
	size_t soap_flag_ns9__Geocode = 1;
	short soap_flag;
	a = (struct __ns10__Geocode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns10__Geocode, sizeof(struct __ns10__Geocode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns10__Geocode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns9__Geocode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns9__Geocode(soap, "ns9:Geocode", &a->ns9__Geocode, ""))
				{	soap_flag_ns9__Geocode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns10__Geocode * SOAP_FMAC4 soap_instantiate___ns10__Geocode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns10__Geocode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns10__Geocode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns10__Geocode;
		if (size)
			*size = sizeof(struct __ns10__Geocode);
	}
	else
	{	cp->ptr = (void*)new struct __ns10__Geocode[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns10__Geocode);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns10__Geocode*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns10__Geocode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns10__Geocode %p -> %p\n", q, p));
	*(struct __ns10__Geocode*)p = *(struct __ns10__Geocode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetClientToken(struct soap *soap, struct __ns1__GetClientToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetClientToken = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetClientToken(struct soap *soap, const struct __ns1__GetClientToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetClientToken(soap, &a->ns1__GetClientToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetClientToken(struct soap *soap, const struct __ns1__GetClientToken *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetClientToken(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetClientToken(struct soap *soap, const char *tag, int id, const struct __ns1__GetClientToken *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetClientToken(soap, "ns1:GetClientToken", -1, &a->ns1__GetClientToken, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetClientToken * SOAP_FMAC4 soap_get___ns1__GetClientToken(struct soap *soap, struct __ns1__GetClientToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetClientToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetClientToken * SOAP_FMAC4 soap_in___ns1__GetClientToken(struct soap *soap, const char *tag, struct __ns1__GetClientToken *a, const char *type)
{
	size_t soap_flag_ns1__GetClientToken = 1;
	short soap_flag;
	a = (struct __ns1__GetClientToken *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetClientToken, sizeof(struct __ns1__GetClientToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetClientToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetClientToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetClientToken(soap, "ns1:GetClientToken", &a->ns1__GetClientToken, ""))
				{	soap_flag_ns1__GetClientToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetClientToken * SOAP_FMAC4 soap_instantiate___ns1__GetClientToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetClientToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetClientToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetClientToken;
		if (size)
			*size = sizeof(struct __ns1__GetClientToken);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetClientToken[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetClientToken);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetClientToken*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetClientToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetClientToken %p -> %p\n", q, p));
	*(struct __ns1__GetClientToken*)p = *(struct __ns1__GetClientToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetGreatCircleDistances(struct soap *soap, struct __ns1__GetGreatCircleDistances *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetGreatCircleDistances = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetGreatCircleDistances(struct soap *soap, const struct __ns1__GetGreatCircleDistances *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetGreatCircleDistances(soap, &a->ns1__GetGreatCircleDistances);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetGreatCircleDistances(struct soap *soap, const struct __ns1__GetGreatCircleDistances *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetGreatCircleDistances(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetGreatCircleDistances(struct soap *soap, const char *tag, int id, const struct __ns1__GetGreatCircleDistances *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetGreatCircleDistances(soap, "ns1:GetGreatCircleDistances", -1, &a->ns1__GetGreatCircleDistances, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetGreatCircleDistances * SOAP_FMAC4 soap_get___ns1__GetGreatCircleDistances(struct soap *soap, struct __ns1__GetGreatCircleDistances *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetGreatCircleDistances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetGreatCircleDistances * SOAP_FMAC4 soap_in___ns1__GetGreatCircleDistances(struct soap *soap, const char *tag, struct __ns1__GetGreatCircleDistances *a, const char *type)
{
	size_t soap_flag_ns1__GetGreatCircleDistances = 1;
	short soap_flag;
	a = (struct __ns1__GetGreatCircleDistances *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetGreatCircleDistances, sizeof(struct __ns1__GetGreatCircleDistances), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetGreatCircleDistances(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetGreatCircleDistances && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetGreatCircleDistances(soap, "ns1:GetGreatCircleDistances", &a->ns1__GetGreatCircleDistances, ""))
				{	soap_flag_ns1__GetGreatCircleDistances--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetGreatCircleDistances * SOAP_FMAC4 soap_instantiate___ns1__GetGreatCircleDistances(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetGreatCircleDistances(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetGreatCircleDistances, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetGreatCircleDistances;
		if (size)
			*size = sizeof(struct __ns1__GetGreatCircleDistances);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetGreatCircleDistances[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetGreatCircleDistances);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetGreatCircleDistances*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetGreatCircleDistances(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetGreatCircleDistances %p -> %p\n", q, p));
	*(struct __ns1__GetGreatCircleDistances*)p = *(struct __ns1__GetGreatCircleDistances*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDataSourceInfo(struct soap *soap, struct __ns1__GetDataSourceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDataSourceInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDataSourceInfo(struct soap *soap, const struct __ns1__GetDataSourceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetDataSourceInfo(soap, &a->ns1__GetDataSourceInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDataSourceInfo(struct soap *soap, const struct __ns1__GetDataSourceInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetDataSourceInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDataSourceInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetDataSourceInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDataSourceInfo(soap, "ns1:GetDataSourceInfo", -1, &a->ns1__GetDataSourceInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDataSourceInfo * SOAP_FMAC4 soap_get___ns1__GetDataSourceInfo(struct soap *soap, struct __ns1__GetDataSourceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDataSourceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetDataSourceInfo * SOAP_FMAC4 soap_in___ns1__GetDataSourceInfo(struct soap *soap, const char *tag, struct __ns1__GetDataSourceInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetDataSourceInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetDataSourceInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDataSourceInfo, sizeof(struct __ns1__GetDataSourceInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDataSourceInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDataSourceInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetDataSourceInfo(soap, "ns1:GetDataSourceInfo", &a->ns1__GetDataSourceInfo, ""))
				{	soap_flag_ns1__GetDataSourceInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetDataSourceInfo * SOAP_FMAC4 soap_instantiate___ns1__GetDataSourceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDataSourceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetDataSourceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetDataSourceInfo;
		if (size)
			*size = sizeof(struct __ns1__GetDataSourceInfo);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetDataSourceInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetDataSourceInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetDataSourceInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetDataSourceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetDataSourceInfo %p -> %p\n", q, p));
	*(struct __ns1__GetDataSourceInfo*)p = *(struct __ns1__GetDataSourceInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetEntityTypes(struct soap *soap, struct __ns1__GetEntityTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetEntityTypes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetEntityTypes(struct soap *soap, const struct __ns1__GetEntityTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetEntityTypes(soap, &a->ns1__GetEntityTypes);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetEntityTypes(struct soap *soap, const struct __ns1__GetEntityTypes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetEntityTypes(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetEntityTypes(struct soap *soap, const char *tag, int id, const struct __ns1__GetEntityTypes *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetEntityTypes(soap, "ns1:GetEntityTypes", -1, &a->ns1__GetEntityTypes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEntityTypes * SOAP_FMAC4 soap_get___ns1__GetEntityTypes(struct soap *soap, struct __ns1__GetEntityTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetEntityTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetEntityTypes * SOAP_FMAC4 soap_in___ns1__GetEntityTypes(struct soap *soap, const char *tag, struct __ns1__GetEntityTypes *a, const char *type)
{
	size_t soap_flag_ns1__GetEntityTypes = 1;
	short soap_flag;
	a = (struct __ns1__GetEntityTypes *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetEntityTypes, sizeof(struct __ns1__GetEntityTypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetEntityTypes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetEntityTypes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetEntityTypes(soap, "ns1:GetEntityTypes", &a->ns1__GetEntityTypes, ""))
				{	soap_flag_ns1__GetEntityTypes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetEntityTypes * SOAP_FMAC4 soap_instantiate___ns1__GetEntityTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetEntityTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetEntityTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetEntityTypes;
		if (size)
			*size = sizeof(struct __ns1__GetEntityTypes);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetEntityTypes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetEntityTypes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetEntityTypes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetEntityTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetEntityTypes %p -> %p\n", q, p));
	*(struct __ns1__GetEntityTypes*)p = *(struct __ns1__GetEntityTypes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetCountryRegionInfo(struct soap *soap, struct __ns1__GetCountryRegionInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetCountryRegionInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetCountryRegionInfo(struct soap *soap, const struct __ns1__GetCountryRegionInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetCountryRegionInfo(soap, &a->ns1__GetCountryRegionInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetCountryRegionInfo(struct soap *soap, const struct __ns1__GetCountryRegionInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetCountryRegionInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetCountryRegionInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetCountryRegionInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetCountryRegionInfo(soap, "ns1:GetCountryRegionInfo", -1, &a->ns1__GetCountryRegionInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetCountryRegionInfo * SOAP_FMAC4 soap_get___ns1__GetCountryRegionInfo(struct soap *soap, struct __ns1__GetCountryRegionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetCountryRegionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetCountryRegionInfo * SOAP_FMAC4 soap_in___ns1__GetCountryRegionInfo(struct soap *soap, const char *tag, struct __ns1__GetCountryRegionInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetCountryRegionInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetCountryRegionInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetCountryRegionInfo, sizeof(struct __ns1__GetCountryRegionInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetCountryRegionInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetCountryRegionInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetCountryRegionInfo(soap, "ns1:GetCountryRegionInfo", &a->ns1__GetCountryRegionInfo, ""))
				{	soap_flag_ns1__GetCountryRegionInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetCountryRegionInfo * SOAP_FMAC4 soap_instantiate___ns1__GetCountryRegionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetCountryRegionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetCountryRegionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetCountryRegionInfo;
		if (size)
			*size = sizeof(struct __ns1__GetCountryRegionInfo);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetCountryRegionInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetCountryRegionInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetCountryRegionInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetCountryRegionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetCountryRegionInfo %p -> %p\n", q, p));
	*(struct __ns1__GetCountryRegionInfo*)p = *(struct __ns1__GetCountryRegionInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetVersionInfo(struct soap *soap, struct __ns1__GetVersionInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetVersionInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetVersionInfo(struct soap *soap, const struct __ns1__GetVersionInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetVersionInfo(soap, &a->ns1__GetVersionInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetVersionInfo(struct soap *soap, const struct __ns1__GetVersionInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetVersionInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetVersionInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetVersionInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetVersionInfo(soap, "ns1:GetVersionInfo", -1, &a->ns1__GetVersionInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVersionInfo * SOAP_FMAC4 soap_get___ns1__GetVersionInfo(struct soap *soap, struct __ns1__GetVersionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetVersionInfo * SOAP_FMAC4 soap_in___ns1__GetVersionInfo(struct soap *soap, const char *tag, struct __ns1__GetVersionInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetVersionInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetVersionInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetVersionInfo, sizeof(struct __ns1__GetVersionInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetVersionInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetVersionInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetVersionInfo(soap, "ns1:GetVersionInfo", &a->ns1__GetVersionInfo, ""))
				{	soap_flag_ns1__GetVersionInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetVersionInfo * SOAP_FMAC4 soap_instantiate___ns1__GetVersionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetVersionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetVersionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetVersionInfo;
		if (size)
			*size = sizeof(struct __ns1__GetVersionInfo);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetVersionInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetVersionInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetVersionInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetVersionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetVersionInfo %p -> %p\n", q, p));
	*(struct __ns1__GetVersionInfo*)p = *(struct __ns1__GetVersionInfo*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CustomerInfoHeader_ = NULL;
	a->ns1__UserInfoHeader_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CustomerInfoHeader(soap, &a->ns1__CustomerInfoHeader_);
	soap_serialize_PointerTons1__UserInfoHeader(soap, &a->ns1__UserInfoHeader_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTons1__CustomerInfoHeader(soap, "ns1:CustomerInfoHeader", -1, &a->ns1__CustomerInfoHeader_, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTons1__UserInfoHeader(soap, "ns1:UserInfoHeader", -1, &a->ns1__UserInfoHeader_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_ns1__CustomerInfoHeader_ = 1;
	size_t soap_flag_ns1__UserInfoHeader_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CustomerInfoHeader_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomerInfoHeader(soap, "ns1:CustomerInfoHeader", &a->ns1__CustomerInfoHeader_, "ns1:CustomerInfoHeader"))
				{	soap_flag_ns1__CustomerInfoHeader_--;
					continue;
				}
			if (soap_flag_ns1__UserInfoHeader_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UserInfoHeader(soap, "ns1:UserInfoHeader", &a->ns1__UserInfoHeader_, "ns1:UserInfoHeader"))
				{	soap_flag_ns1__UserInfoHeader_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__SearchResponse(struct soap *soap, _ns3__SearchResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__SearchResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__SearchResponse(struct soap *soap, _ns3__SearchResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__SearchResponse);
	if (soap_out_PointerTo_ns3__SearchResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__SearchResponse(struct soap *soap, const char *tag, int id, _ns3__SearchResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__SearchResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__SearchResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__SearchResponse(struct soap *soap, _ns3__SearchResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__SearchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__SearchResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__SearchResponse(struct soap *soap, const char *tag, _ns3__SearchResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__SearchResponse **)soap_malloc(soap, sizeof(_ns3__SearchResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__SearchResponse *)soap_instantiate__ns3__SearchResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__SearchResponse ** p = (_ns3__SearchResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__SearchResponse, sizeof(_ns3__SearchResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__Search(struct soap *soap, _ns3__Search *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__Search))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__Search(struct soap *soap, _ns3__Search *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__Search);
	if (soap_out_PointerTo_ns3__Search(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__Search(struct soap *soap, const char *tag, int id, _ns3__Search *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__Search);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__Search ** SOAP_FMAC4 soap_get_PointerTo_ns3__Search(struct soap *soap, _ns3__Search **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__Search(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__Search ** SOAP_FMAC4 soap_in_PointerTo_ns3__Search(struct soap *soap, const char *tag, _ns3__Search **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__Search **)soap_malloc(soap, sizeof(_ns3__Search *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__Search *)soap_instantiate__ns3__Search(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__Search ** p = (_ns3__Search **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__Search, sizeof(_ns3__Search), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns15__CalculateRoutesFromMajorRoadsResponse(struct soap *soap, _ns15__CalculateRoutesFromMajorRoadsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoadsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns15__CalculateRoutesFromMajorRoadsResponse(struct soap *soap, _ns15__CalculateRoutesFromMajorRoadsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns15__CalculateRoutesFromMajorRoadsResponse);
	if (soap_out_PointerTo_ns15__CalculateRoutesFromMajorRoadsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns15__CalculateRoutesFromMajorRoadsResponse(struct soap *soap, const char *tag, int id, _ns15__CalculateRoutesFromMajorRoadsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoadsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns15__CalculateRoutesFromMajorRoadsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns15__CalculateRoutesFromMajorRoadsResponse(struct soap *soap, _ns15__CalculateRoutesFromMajorRoadsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns15__CalculateRoutesFromMajorRoadsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns15__CalculateRoutesFromMajorRoadsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns15__CalculateRoutesFromMajorRoadsResponse(struct soap *soap, const char *tag, _ns15__CalculateRoutesFromMajorRoadsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns15__CalculateRoutesFromMajorRoadsResponse **)soap_malloc(soap, sizeof(_ns15__CalculateRoutesFromMajorRoadsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns15__CalculateRoutesFromMajorRoadsResponse *)soap_instantiate__ns15__CalculateRoutesFromMajorRoadsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns15__CalculateRoutesFromMajorRoadsResponse ** p = (_ns15__CalculateRoutesFromMajorRoadsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoadsResponse, sizeof(_ns15__CalculateRoutesFromMajorRoadsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns15__CalculateRoutesFromMajorRoads(struct soap *soap, _ns15__CalculateRoutesFromMajorRoads *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoads))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns15__CalculateRoutesFromMajorRoads(struct soap *soap, _ns15__CalculateRoutesFromMajorRoads *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns15__CalculateRoutesFromMajorRoads);
	if (soap_out_PointerTo_ns15__CalculateRoutesFromMajorRoads(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns15__CalculateRoutesFromMajorRoads(struct soap *soap, const char *tag, int id, _ns15__CalculateRoutesFromMajorRoads *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoads);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns15__CalculateRoutesFromMajorRoads ** SOAP_FMAC4 soap_get_PointerTo_ns15__CalculateRoutesFromMajorRoads(struct soap *soap, _ns15__CalculateRoutesFromMajorRoads **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns15__CalculateRoutesFromMajorRoads(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns15__CalculateRoutesFromMajorRoads ** SOAP_FMAC4 soap_in_PointerTo_ns15__CalculateRoutesFromMajorRoads(struct soap *soap, const char *tag, _ns15__CalculateRoutesFromMajorRoads **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns15__CalculateRoutesFromMajorRoads **)soap_malloc(soap, sizeof(_ns15__CalculateRoutesFromMajorRoads *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns15__CalculateRoutesFromMajorRoads *)soap_instantiate__ns15__CalculateRoutesFromMajorRoads(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns15__CalculateRoutesFromMajorRoads ** p = (_ns15__CalculateRoutesFromMajorRoads **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns15__CalculateRoutesFromMajorRoads, sizeof(_ns15__CalculateRoutesFromMajorRoads), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns15__CalculateRouteResponse(struct soap *soap, _ns15__CalculateRouteResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns15__CalculateRouteResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns15__CalculateRouteResponse(struct soap *soap, _ns15__CalculateRouteResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns15__CalculateRouteResponse);
	if (soap_out_PointerTo_ns15__CalculateRouteResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns15__CalculateRouteResponse(struct soap *soap, const char *tag, int id, _ns15__CalculateRouteResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns15__CalculateRouteResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns15__CalculateRouteResponse ** SOAP_FMAC4 soap_get_PointerTo_ns15__CalculateRouteResponse(struct soap *soap, _ns15__CalculateRouteResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns15__CalculateRouteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns15__CalculateRouteResponse ** SOAP_FMAC4 soap_in_PointerTo_ns15__CalculateRouteResponse(struct soap *soap, const char *tag, _ns15__CalculateRouteResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns15__CalculateRouteResponse **)soap_malloc(soap, sizeof(_ns15__CalculateRouteResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns15__CalculateRouteResponse *)soap_instantiate__ns15__CalculateRouteResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns15__CalculateRouteResponse ** p = (_ns15__CalculateRouteResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns15__CalculateRouteResponse, sizeof(_ns15__CalculateRouteResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns15__CalculateRoute(struct soap *soap, _ns15__CalculateRoute *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns15__CalculateRoute))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns15__CalculateRoute(struct soap *soap, _ns15__CalculateRoute *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns15__CalculateRoute);
	if (soap_out_PointerTo_ns15__CalculateRoute(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns15__CalculateRoute(struct soap *soap, const char *tag, int id, _ns15__CalculateRoute *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns15__CalculateRoute);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns15__CalculateRoute ** SOAP_FMAC4 soap_get_PointerTo_ns15__CalculateRoute(struct soap *soap, _ns15__CalculateRoute **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns15__CalculateRoute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns15__CalculateRoute ** SOAP_FMAC4 soap_in_PointerTo_ns15__CalculateRoute(struct soap *soap, const char *tag, _ns15__CalculateRoute **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns15__CalculateRoute **)soap_malloc(soap, sizeof(_ns15__CalculateRoute *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns15__CalculateRoute *)soap_instantiate__ns15__CalculateRoute(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns15__CalculateRoute ** p = (_ns15__CalculateRoute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns15__CalculateRoute, sizeof(_ns15__CalculateRoute), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns12__GetMapUriResponse(struct soap *soap, _ns12__GetMapUriResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns12__GetMapUriResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns12__GetMapUriResponse(struct soap *soap, _ns12__GetMapUriResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns12__GetMapUriResponse);
	if (soap_out_PointerTo_ns12__GetMapUriResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns12__GetMapUriResponse(struct soap *soap, const char *tag, int id, _ns12__GetMapUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns12__GetMapUriResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns12__GetMapUriResponse ** SOAP_FMAC4 soap_get_PointerTo_ns12__GetMapUriResponse(struct soap *soap, _ns12__GetMapUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns12__GetMapUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns12__GetMapUriResponse ** SOAP_FMAC4 soap_in_PointerTo_ns12__GetMapUriResponse(struct soap *soap, const char *tag, _ns12__GetMapUriResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns12__GetMapUriResponse **)soap_malloc(soap, sizeof(_ns12__GetMapUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns12__GetMapUriResponse *)soap_instantiate__ns12__GetMapUriResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns12__GetMapUriResponse ** p = (_ns12__GetMapUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns12__GetMapUriResponse, sizeof(_ns12__GetMapUriResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns12__GetMapUri(struct soap *soap, _ns12__GetMapUri *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns12__GetMapUri))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns12__GetMapUri(struct soap *soap, _ns12__GetMapUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns12__GetMapUri);
	if (soap_out_PointerTo_ns12__GetMapUri(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns12__GetMapUri(struct soap *soap, const char *tag, int id, _ns12__GetMapUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns12__GetMapUri);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns12__GetMapUri ** SOAP_FMAC4 soap_get_PointerTo_ns12__GetMapUri(struct soap *soap, _ns12__GetMapUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns12__GetMapUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns12__GetMapUri ** SOAP_FMAC4 soap_in_PointerTo_ns12__GetMapUri(struct soap *soap, const char *tag, _ns12__GetMapUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns12__GetMapUri **)soap_malloc(soap, sizeof(_ns12__GetMapUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns12__GetMapUri *)soap_instantiate__ns12__GetMapUri(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns12__GetMapUri ** p = (_ns12__GetMapUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns12__GetMapUri, sizeof(_ns12__GetMapUri), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns12__GetImageryMetadataResponse(struct soap *soap, _ns12__GetImageryMetadataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns12__GetImageryMetadataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns12__GetImageryMetadataResponse(struct soap *soap, _ns12__GetImageryMetadataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns12__GetImageryMetadataResponse);
	if (soap_out_PointerTo_ns12__GetImageryMetadataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns12__GetImageryMetadataResponse(struct soap *soap, const char *tag, int id, _ns12__GetImageryMetadataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns12__GetImageryMetadataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns12__GetImageryMetadataResponse ** SOAP_FMAC4 soap_get_PointerTo_ns12__GetImageryMetadataResponse(struct soap *soap, _ns12__GetImageryMetadataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns12__GetImageryMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns12__GetImageryMetadataResponse ** SOAP_FMAC4 soap_in_PointerTo_ns12__GetImageryMetadataResponse(struct soap *soap, const char *tag, _ns12__GetImageryMetadataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns12__GetImageryMetadataResponse **)soap_malloc(soap, sizeof(_ns12__GetImageryMetadataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns12__GetImageryMetadataResponse *)soap_instantiate__ns12__GetImageryMetadataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns12__GetImageryMetadataResponse ** p = (_ns12__GetImageryMetadataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns12__GetImageryMetadataResponse, sizeof(_ns12__GetImageryMetadataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns12__GetImageryMetadata(struct soap *soap, _ns12__GetImageryMetadata *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns12__GetImageryMetadata))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns12__GetImageryMetadata(struct soap *soap, _ns12__GetImageryMetadata *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns12__GetImageryMetadata);
	if (soap_out_PointerTo_ns12__GetImageryMetadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns12__GetImageryMetadata(struct soap *soap, const char *tag, int id, _ns12__GetImageryMetadata *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns12__GetImageryMetadata);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns12__GetImageryMetadata ** SOAP_FMAC4 soap_get_PointerTo_ns12__GetImageryMetadata(struct soap *soap, _ns12__GetImageryMetadata **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns12__GetImageryMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns12__GetImageryMetadata ** SOAP_FMAC4 soap_in_PointerTo_ns12__GetImageryMetadata(struct soap *soap, const char *tag, _ns12__GetImageryMetadata **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns12__GetImageryMetadata **)soap_malloc(soap, sizeof(_ns12__GetImageryMetadata *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns12__GetImageryMetadata *)soap_instantiate__ns12__GetImageryMetadata(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns12__GetImageryMetadata ** p = (_ns12__GetImageryMetadata **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns12__GetImageryMetadata, sizeof(_ns12__GetImageryMetadata), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns9__ReverseGeocodeResponse(struct soap *soap, _ns9__ReverseGeocodeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns9__ReverseGeocodeResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns9__ReverseGeocodeResponse(struct soap *soap, _ns9__ReverseGeocodeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns9__ReverseGeocodeResponse);
	if (soap_out_PointerTo_ns9__ReverseGeocodeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns9__ReverseGeocodeResponse(struct soap *soap, const char *tag, int id, _ns9__ReverseGeocodeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns9__ReverseGeocodeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns9__ReverseGeocodeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns9__ReverseGeocodeResponse(struct soap *soap, _ns9__ReverseGeocodeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns9__ReverseGeocodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns9__ReverseGeocodeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns9__ReverseGeocodeResponse(struct soap *soap, const char *tag, _ns9__ReverseGeocodeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns9__ReverseGeocodeResponse **)soap_malloc(soap, sizeof(_ns9__ReverseGeocodeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns9__ReverseGeocodeResponse *)soap_instantiate__ns9__ReverseGeocodeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns9__ReverseGeocodeResponse ** p = (_ns9__ReverseGeocodeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns9__ReverseGeocodeResponse, sizeof(_ns9__ReverseGeocodeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns9__ReverseGeocode(struct soap *soap, _ns9__ReverseGeocode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns9__ReverseGeocode))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns9__ReverseGeocode(struct soap *soap, _ns9__ReverseGeocode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns9__ReverseGeocode);
	if (soap_out_PointerTo_ns9__ReverseGeocode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns9__ReverseGeocode(struct soap *soap, const char *tag, int id, _ns9__ReverseGeocode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns9__ReverseGeocode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns9__ReverseGeocode ** SOAP_FMAC4 soap_get_PointerTo_ns9__ReverseGeocode(struct soap *soap, _ns9__ReverseGeocode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns9__ReverseGeocode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns9__ReverseGeocode ** SOAP_FMAC4 soap_in_PointerTo_ns9__ReverseGeocode(struct soap *soap, const char *tag, _ns9__ReverseGeocode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns9__ReverseGeocode **)soap_malloc(soap, sizeof(_ns9__ReverseGeocode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns9__ReverseGeocode *)soap_instantiate__ns9__ReverseGeocode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns9__ReverseGeocode ** p = (_ns9__ReverseGeocode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns9__ReverseGeocode, sizeof(_ns9__ReverseGeocode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns9__GeocodeResponse(struct soap *soap, _ns9__GeocodeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns9__GeocodeResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns9__GeocodeResponse(struct soap *soap, _ns9__GeocodeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns9__GeocodeResponse);
	if (soap_out_PointerTo_ns9__GeocodeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns9__GeocodeResponse(struct soap *soap, const char *tag, int id, _ns9__GeocodeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns9__GeocodeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns9__GeocodeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns9__GeocodeResponse(struct soap *soap, _ns9__GeocodeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns9__GeocodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns9__GeocodeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns9__GeocodeResponse(struct soap *soap, const char *tag, _ns9__GeocodeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns9__GeocodeResponse **)soap_malloc(soap, sizeof(_ns9__GeocodeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns9__GeocodeResponse *)soap_instantiate__ns9__GeocodeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns9__GeocodeResponse ** p = (_ns9__GeocodeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns9__GeocodeResponse, sizeof(_ns9__GeocodeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns9__Geocode(struct soap *soap, _ns9__Geocode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns9__Geocode))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns9__Geocode(struct soap *soap, _ns9__Geocode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns9__Geocode);
	if (soap_out_PointerTo_ns9__Geocode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns9__Geocode(struct soap *soap, const char *tag, int id, _ns9__Geocode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns9__Geocode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns9__Geocode ** SOAP_FMAC4 soap_get_PointerTo_ns9__Geocode(struct soap *soap, _ns9__Geocode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns9__Geocode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns9__Geocode ** SOAP_FMAC4 soap_in_PointerTo_ns9__Geocode(struct soap *soap, const char *tag, _ns9__Geocode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns9__Geocode **)soap_malloc(soap, sizeof(_ns9__Geocode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns9__Geocode *)soap_instantiate__ns9__Geocode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns9__Geocode ** p = (_ns9__Geocode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns9__Geocode, sizeof(_ns9__Geocode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetClientTokenResponse(struct soap *soap, _ns1__GetClientTokenResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetClientTokenResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetClientTokenResponse(struct soap *soap, _ns1__GetClientTokenResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetClientTokenResponse);
	if (soap_out_PointerTo_ns1__GetClientTokenResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetClientTokenResponse(struct soap *soap, const char *tag, int id, _ns1__GetClientTokenResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetClientTokenResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetClientTokenResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetClientTokenResponse(struct soap *soap, _ns1__GetClientTokenResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetClientTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetClientTokenResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetClientTokenResponse(struct soap *soap, const char *tag, _ns1__GetClientTokenResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetClientTokenResponse **)soap_malloc(soap, sizeof(_ns1__GetClientTokenResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetClientTokenResponse *)soap_instantiate__ns1__GetClientTokenResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetClientTokenResponse ** p = (_ns1__GetClientTokenResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetClientTokenResponse, sizeof(_ns1__GetClientTokenResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetClientToken(struct soap *soap, _ns1__GetClientToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetClientToken))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetClientToken(struct soap *soap, _ns1__GetClientToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetClientToken);
	if (soap_out_PointerTo_ns1__GetClientToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetClientToken(struct soap *soap, const char *tag, int id, _ns1__GetClientToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetClientToken);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetClientToken ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetClientToken(struct soap *soap, _ns1__GetClientToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetClientToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetClientToken ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetClientToken(struct soap *soap, const char *tag, _ns1__GetClientToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetClientToken **)soap_malloc(soap, sizeof(_ns1__GetClientToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetClientToken *)soap_instantiate__ns1__GetClientToken(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetClientToken ** p = (_ns1__GetClientToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetClientToken, sizeof(_ns1__GetClientToken), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetGreatCircleDistancesResponse(struct soap *soap, _ns1__GetGreatCircleDistancesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetGreatCircleDistancesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetGreatCircleDistancesResponse(struct soap *soap, _ns1__GetGreatCircleDistancesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetGreatCircleDistancesResponse);
	if (soap_out_PointerTo_ns1__GetGreatCircleDistancesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetGreatCircleDistancesResponse(struct soap *soap, const char *tag, int id, _ns1__GetGreatCircleDistancesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetGreatCircleDistancesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetGreatCircleDistancesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetGreatCircleDistancesResponse(struct soap *soap, _ns1__GetGreatCircleDistancesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetGreatCircleDistancesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetGreatCircleDistancesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetGreatCircleDistancesResponse(struct soap *soap, const char *tag, _ns1__GetGreatCircleDistancesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetGreatCircleDistancesResponse **)soap_malloc(soap, sizeof(_ns1__GetGreatCircleDistancesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetGreatCircleDistancesResponse *)soap_instantiate__ns1__GetGreatCircleDistancesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetGreatCircleDistancesResponse ** p = (_ns1__GetGreatCircleDistancesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetGreatCircleDistancesResponse, sizeof(_ns1__GetGreatCircleDistancesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetGreatCircleDistances(struct soap *soap, _ns1__GetGreatCircleDistances *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetGreatCircleDistances))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetGreatCircleDistances(struct soap *soap, _ns1__GetGreatCircleDistances *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetGreatCircleDistances);
	if (soap_out_PointerTo_ns1__GetGreatCircleDistances(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetGreatCircleDistances(struct soap *soap, const char *tag, int id, _ns1__GetGreatCircleDistances *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetGreatCircleDistances);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetGreatCircleDistances ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetGreatCircleDistances(struct soap *soap, _ns1__GetGreatCircleDistances **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetGreatCircleDistances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetGreatCircleDistances ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetGreatCircleDistances(struct soap *soap, const char *tag, _ns1__GetGreatCircleDistances **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetGreatCircleDistances **)soap_malloc(soap, sizeof(_ns1__GetGreatCircleDistances *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetGreatCircleDistances *)soap_instantiate__ns1__GetGreatCircleDistances(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetGreatCircleDistances ** p = (_ns1__GetGreatCircleDistances **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetGreatCircleDistances, sizeof(_ns1__GetGreatCircleDistances), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDataSourceInfoResponse(struct soap *soap, _ns1__GetDataSourceInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDataSourceInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDataSourceInfoResponse(struct soap *soap, _ns1__GetDataSourceInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetDataSourceInfoResponse);
	if (soap_out_PointerTo_ns1__GetDataSourceInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDataSourceInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetDataSourceInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDataSourceInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetDataSourceInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDataSourceInfoResponse(struct soap *soap, _ns1__GetDataSourceInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDataSourceInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetDataSourceInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDataSourceInfoResponse(struct soap *soap, const char *tag, _ns1__GetDataSourceInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDataSourceInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetDataSourceInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDataSourceInfoResponse *)soap_instantiate__ns1__GetDataSourceInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetDataSourceInfoResponse ** p = (_ns1__GetDataSourceInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDataSourceInfoResponse, sizeof(_ns1__GetDataSourceInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDataSourceInfo(struct soap *soap, _ns1__GetDataSourceInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDataSourceInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDataSourceInfo(struct soap *soap, _ns1__GetDataSourceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetDataSourceInfo);
	if (soap_out_PointerTo_ns1__GetDataSourceInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDataSourceInfo(struct soap *soap, const char *tag, int id, _ns1__GetDataSourceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDataSourceInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetDataSourceInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDataSourceInfo(struct soap *soap, _ns1__GetDataSourceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDataSourceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetDataSourceInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDataSourceInfo(struct soap *soap, const char *tag, _ns1__GetDataSourceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDataSourceInfo **)soap_malloc(soap, sizeof(_ns1__GetDataSourceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDataSourceInfo *)soap_instantiate__ns1__GetDataSourceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetDataSourceInfo ** p = (_ns1__GetDataSourceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDataSourceInfo, sizeof(_ns1__GetDataSourceInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetEntityTypesResponse(struct soap *soap, _ns1__GetEntityTypesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetEntityTypesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetEntityTypesResponse(struct soap *soap, _ns1__GetEntityTypesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetEntityTypesResponse);
	if (soap_out_PointerTo_ns1__GetEntityTypesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetEntityTypesResponse(struct soap *soap, const char *tag, int id, _ns1__GetEntityTypesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetEntityTypesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetEntityTypesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetEntityTypesResponse(struct soap *soap, _ns1__GetEntityTypesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetEntityTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetEntityTypesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetEntityTypesResponse(struct soap *soap, const char *tag, _ns1__GetEntityTypesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetEntityTypesResponse **)soap_malloc(soap, sizeof(_ns1__GetEntityTypesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetEntityTypesResponse *)soap_instantiate__ns1__GetEntityTypesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetEntityTypesResponse ** p = (_ns1__GetEntityTypesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetEntityTypesResponse, sizeof(_ns1__GetEntityTypesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetEntityTypes(struct soap *soap, _ns1__GetEntityTypes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetEntityTypes))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetEntityTypes(struct soap *soap, _ns1__GetEntityTypes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetEntityTypes);
	if (soap_out_PointerTo_ns1__GetEntityTypes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetEntityTypes(struct soap *soap, const char *tag, int id, _ns1__GetEntityTypes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetEntityTypes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetEntityTypes ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetEntityTypes(struct soap *soap, _ns1__GetEntityTypes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetEntityTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetEntityTypes ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetEntityTypes(struct soap *soap, const char *tag, _ns1__GetEntityTypes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetEntityTypes **)soap_malloc(soap, sizeof(_ns1__GetEntityTypes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetEntityTypes *)soap_instantiate__ns1__GetEntityTypes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetEntityTypes ** p = (_ns1__GetEntityTypes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetEntityTypes, sizeof(_ns1__GetEntityTypes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetCountryRegionInfoResponse(struct soap *soap, _ns1__GetCountryRegionInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetCountryRegionInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetCountryRegionInfoResponse(struct soap *soap, _ns1__GetCountryRegionInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetCountryRegionInfoResponse);
	if (soap_out_PointerTo_ns1__GetCountryRegionInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetCountryRegionInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetCountryRegionInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetCountryRegionInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetCountryRegionInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetCountryRegionInfoResponse(struct soap *soap, _ns1__GetCountryRegionInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetCountryRegionInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetCountryRegionInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetCountryRegionInfoResponse(struct soap *soap, const char *tag, _ns1__GetCountryRegionInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetCountryRegionInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetCountryRegionInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetCountryRegionInfoResponse *)soap_instantiate__ns1__GetCountryRegionInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetCountryRegionInfoResponse ** p = (_ns1__GetCountryRegionInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetCountryRegionInfoResponse, sizeof(_ns1__GetCountryRegionInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetCountryRegionInfo(struct soap *soap, _ns1__GetCountryRegionInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetCountryRegionInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetCountryRegionInfo(struct soap *soap, _ns1__GetCountryRegionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetCountryRegionInfo);
	if (soap_out_PointerTo_ns1__GetCountryRegionInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetCountryRegionInfo(struct soap *soap, const char *tag, int id, _ns1__GetCountryRegionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetCountryRegionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetCountryRegionInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetCountryRegionInfo(struct soap *soap, _ns1__GetCountryRegionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetCountryRegionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetCountryRegionInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetCountryRegionInfo(struct soap *soap, const char *tag, _ns1__GetCountryRegionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetCountryRegionInfo **)soap_malloc(soap, sizeof(_ns1__GetCountryRegionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetCountryRegionInfo *)soap_instantiate__ns1__GetCountryRegionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetCountryRegionInfo ** p = (_ns1__GetCountryRegionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetCountryRegionInfo, sizeof(_ns1__GetCountryRegionInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetVersionInfoResponse(struct soap *soap, _ns1__GetVersionInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetVersionInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetVersionInfoResponse(struct soap *soap, _ns1__GetVersionInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetVersionInfoResponse);
	if (soap_out_PointerTo_ns1__GetVersionInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetVersionInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetVersionInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetVersionInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetVersionInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetVersionInfoResponse(struct soap *soap, _ns1__GetVersionInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetVersionInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetVersionInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetVersionInfoResponse(struct soap *soap, const char *tag, _ns1__GetVersionInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetVersionInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetVersionInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetVersionInfoResponse *)soap_instantiate__ns1__GetVersionInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetVersionInfoResponse ** p = (_ns1__GetVersionInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetVersionInfoResponse, sizeof(_ns1__GetVersionInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetVersionInfo(struct soap *soap, _ns1__GetVersionInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetVersionInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetVersionInfo(struct soap *soap, _ns1__GetVersionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetVersionInfo);
	if (soap_out_PointerTo_ns1__GetVersionInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetVersionInfo(struct soap *soap, const char *tag, int id, _ns1__GetVersionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetVersionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetVersionInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetVersionInfo(struct soap *soap, _ns1__GetVersionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetVersionInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetVersionInfo(struct soap *soap, const char *tag, _ns1__GetVersionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetVersionInfo **)soap_malloc(soap, sizeof(_ns1__GetVersionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetVersionInfo *)soap_instantiate__ns1__GetVersionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetVersionInfo ** p = (_ns1__GetVersionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetVersionInfo, sizeof(_ns1__GetVersionInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UserInfoHeader(struct soap *soap, ns1__UserInfoHeader *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UserInfoHeader))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UserInfoHeader(struct soap *soap, ns1__UserInfoHeader *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UserInfoHeader);
	if (soap_out_PointerTons1__UserInfoHeader(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UserInfoHeader(struct soap *soap, const char *tag, int id, ns1__UserInfoHeader *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UserInfoHeader);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UserInfoHeader ** SOAP_FMAC4 soap_get_PointerTons1__UserInfoHeader(struct soap *soap, ns1__UserInfoHeader **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UserInfoHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__UserInfoHeader ** SOAP_FMAC4 soap_in_PointerTons1__UserInfoHeader(struct soap *soap, const char *tag, ns1__UserInfoHeader **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UserInfoHeader **)soap_malloc(soap, sizeof(ns1__UserInfoHeader *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UserInfoHeader *)soap_instantiate_ns1__UserInfoHeader(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UserInfoHeader ** p = (ns1__UserInfoHeader **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UserInfoHeader, sizeof(ns1__UserInfoHeader), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CustomerInfoHeader(struct soap *soap, ns1__CustomerInfoHeader *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CustomerInfoHeader))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CustomerInfoHeader(struct soap *soap, ns1__CustomerInfoHeader *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CustomerInfoHeader);
	if (soap_out_PointerTons1__CustomerInfoHeader(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CustomerInfoHeader(struct soap *soap, const char *tag, int id, ns1__CustomerInfoHeader *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CustomerInfoHeader);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CustomerInfoHeader ** SOAP_FMAC4 soap_get_PointerTons1__CustomerInfoHeader(struct soap *soap, ns1__CustomerInfoHeader **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CustomerInfoHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__CustomerInfoHeader ** SOAP_FMAC4 soap_in_PointerTons1__CustomerInfoHeader(struct soap *soap, const char *tag, ns1__CustomerInfoHeader **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CustomerInfoHeader **)soap_malloc(soap, sizeof(ns1__CustomerInfoHeader *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CustomerInfoHeader *)soap_instantiate_ns1__CustomerInfoHeader(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CustomerInfoHeader ** p = (ns1__CustomerInfoHeader **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CustomerInfoHeader, sizeof(ns1__CustomerInfoHeader), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__ArrayOfRouteResult(struct soap *soap, ns16__ArrayOfRouteResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__ArrayOfRouteResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__ArrayOfRouteResult(struct soap *soap, ns16__ArrayOfRouteResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__ArrayOfRouteResult);
	if (soap_out_PointerTons16__ArrayOfRouteResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__ArrayOfRouteResult(struct soap *soap, const char *tag, int id, ns16__ArrayOfRouteResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__ArrayOfRouteResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__ArrayOfRouteResult ** SOAP_FMAC4 soap_get_PointerTons16__ArrayOfRouteResult(struct soap *soap, ns16__ArrayOfRouteResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__ArrayOfRouteResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__ArrayOfRouteResult ** SOAP_FMAC4 soap_in_PointerTons16__ArrayOfRouteResult(struct soap *soap, const char *tag, ns16__ArrayOfRouteResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__ArrayOfRouteResult **)soap_malloc(soap, sizeof(ns16__ArrayOfRouteResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__ArrayOfRouteResult *)soap_instantiate_ns16__ArrayOfRouteResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__ArrayOfRouteResult ** p = (ns16__ArrayOfRouteResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ArrayOfRouteResult, sizeof(ns16__ArrayOfRouteResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__MajorRoutesOptions(struct soap *soap, ns16__MajorRoutesOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__MajorRoutesOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__MajorRoutesOptions(struct soap *soap, ns16__MajorRoutesOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__MajorRoutesOptions);
	if (soap_out_PointerTons16__MajorRoutesOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__MajorRoutesOptions(struct soap *soap, const char *tag, int id, ns16__MajorRoutesOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__MajorRoutesOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__MajorRoutesOptions ** SOAP_FMAC4 soap_get_PointerTons16__MajorRoutesOptions(struct soap *soap, ns16__MajorRoutesOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__MajorRoutesOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__MajorRoutesOptions ** SOAP_FMAC4 soap_in_PointerTons16__MajorRoutesOptions(struct soap *soap, const char *tag, ns16__MajorRoutesOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__MajorRoutesOptions **)soap_malloc(soap, sizeof(ns16__MajorRoutesOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__MajorRoutesOptions *)soap_instantiate_ns16__MajorRoutesOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__MajorRoutesOptions ** p = (ns16__MajorRoutesOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__MajorRoutesOptions, sizeof(ns16__MajorRoutesOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__ArrayOfWaypoint(struct soap *soap, ns16__ArrayOfWaypoint *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__ArrayOfWaypoint))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__ArrayOfWaypoint(struct soap *soap, ns16__ArrayOfWaypoint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__ArrayOfWaypoint);
	if (soap_out_PointerTons16__ArrayOfWaypoint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__ArrayOfWaypoint(struct soap *soap, const char *tag, int id, ns16__ArrayOfWaypoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__ArrayOfWaypoint);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__ArrayOfWaypoint ** SOAP_FMAC4 soap_get_PointerTons16__ArrayOfWaypoint(struct soap *soap, ns16__ArrayOfWaypoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__ArrayOfWaypoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__ArrayOfWaypoint ** SOAP_FMAC4 soap_in_PointerTons16__ArrayOfWaypoint(struct soap *soap, const char *tag, ns16__ArrayOfWaypoint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__ArrayOfWaypoint **)soap_malloc(soap, sizeof(ns16__ArrayOfWaypoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__ArrayOfWaypoint *)soap_instantiate_ns16__ArrayOfWaypoint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__ArrayOfWaypoint ** p = (ns16__ArrayOfWaypoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ArrayOfWaypoint, sizeof(ns16__ArrayOfWaypoint), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__RouteOptions(struct soap *soap, ns16__RouteOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__RouteOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__RouteOptions(struct soap *soap, ns16__RouteOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__RouteOptions);
	if (soap_out_PointerTons16__RouteOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__RouteOptions(struct soap *soap, const char *tag, int id, ns16__RouteOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__RouteOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__RouteOptions ** SOAP_FMAC4 soap_get_PointerTons16__RouteOptions(struct soap *soap, ns16__RouteOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__RouteOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__RouteOptions ** SOAP_FMAC4 soap_in_PointerTons16__RouteOptions(struct soap *soap, const char *tag, ns16__RouteOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__RouteOptions **)soap_malloc(soap, sizeof(ns16__RouteOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__RouteOptions *)soap_instantiate_ns16__RouteOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__RouteOptions ** p = (ns16__RouteOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RouteOptions, sizeof(ns16__RouteOptions), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns16__RouteOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__MajorRoutesOptions, sizeof(ns16__MajorRoutesOptions), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfPushpin(struct soap *soap, ns4__ArrayOfPushpin *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfPushpin))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfPushpin(struct soap *soap, ns4__ArrayOfPushpin *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfPushpin);
	if (soap_out_PointerTons4__ArrayOfPushpin(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfPushpin(struct soap *soap, const char *tag, int id, ns4__ArrayOfPushpin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfPushpin);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfPushpin ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfPushpin(struct soap *soap, ns4__ArrayOfPushpin **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfPushpin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__ArrayOfPushpin ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfPushpin(struct soap *soap, const char *tag, ns4__ArrayOfPushpin **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfPushpin **)soap_malloc(soap, sizeof(ns4__ArrayOfPushpin *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfPushpin *)soap_instantiate_ns4__ArrayOfPushpin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__ArrayOfPushpin ** p = (ns4__ArrayOfPushpin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfPushpin, sizeof(ns4__ArrayOfPushpin), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons13__MapUriOptions(struct soap *soap, ns13__MapUriOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns13__MapUriOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons13__MapUriOptions(struct soap *soap, ns13__MapUriOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons13__MapUriOptions);
	if (soap_out_PointerTons13__MapUriOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons13__MapUriOptions(struct soap *soap, const char *tag, int id, ns13__MapUriOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns13__MapUriOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns13__MapUriOptions ** SOAP_FMAC4 soap_get_PointerTons13__MapUriOptions(struct soap *soap, ns13__MapUriOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons13__MapUriOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__MapUriOptions ** SOAP_FMAC4 soap_in_PointerTons13__MapUriOptions(struct soap *soap, const char *tag, ns13__MapUriOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__MapUriOptions **)soap_malloc(soap, sizeof(ns13__MapUriOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns13__MapUriOptions *)soap_instantiate_ns13__MapUriOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns13__MapUriOptions ** p = (ns13__MapUriOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__MapUriOptions, sizeof(ns13__MapUriOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons13__ArrayOfImageryMetadataResult(struct soap *soap, ns13__ArrayOfImageryMetadataResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns13__ArrayOfImageryMetadataResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons13__ArrayOfImageryMetadataResult(struct soap *soap, ns13__ArrayOfImageryMetadataResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons13__ArrayOfImageryMetadataResult);
	if (soap_out_PointerTons13__ArrayOfImageryMetadataResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons13__ArrayOfImageryMetadataResult(struct soap *soap, const char *tag, int id, ns13__ArrayOfImageryMetadataResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns13__ArrayOfImageryMetadataResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns13__ArrayOfImageryMetadataResult ** SOAP_FMAC4 soap_get_PointerTons13__ArrayOfImageryMetadataResult(struct soap *soap, ns13__ArrayOfImageryMetadataResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons13__ArrayOfImageryMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__ArrayOfImageryMetadataResult ** SOAP_FMAC4 soap_in_PointerTons13__ArrayOfImageryMetadataResult(struct soap *soap, const char *tag, ns13__ArrayOfImageryMetadataResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__ArrayOfImageryMetadataResult **)soap_malloc(soap, sizeof(ns13__ArrayOfImageryMetadataResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns13__ArrayOfImageryMetadataResult *)soap_instantiate_ns13__ArrayOfImageryMetadataResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns13__ArrayOfImageryMetadataResult ** p = (ns13__ArrayOfImageryMetadataResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ArrayOfImageryMetadataResult, sizeof(ns13__ArrayOfImageryMetadataResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons13__ImageryMetadataOptions(struct soap *soap, ns13__ImageryMetadataOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns13__ImageryMetadataOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons13__ImageryMetadataOptions(struct soap *soap, ns13__ImageryMetadataOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons13__ImageryMetadataOptions);
	if (soap_out_PointerTons13__ImageryMetadataOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons13__ImageryMetadataOptions(struct soap *soap, const char *tag, int id, ns13__ImageryMetadataOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns13__ImageryMetadataOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns13__ImageryMetadataOptions ** SOAP_FMAC4 soap_get_PointerTons13__ImageryMetadataOptions(struct soap *soap, ns13__ImageryMetadataOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons13__ImageryMetadataOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__ImageryMetadataOptions ** SOAP_FMAC4 soap_in_PointerTons13__ImageryMetadataOptions(struct soap *soap, const char *tag, ns13__ImageryMetadataOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__ImageryMetadataOptions **)soap_malloc(soap, sizeof(ns13__ImageryMetadataOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns13__ImageryMetadataOptions *)soap_instantiate_ns13__ImageryMetadataOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns13__ImageryMetadataOptions ** p = (ns13__ImageryMetadataOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ImageryMetadataOptions, sizeof(ns13__ImageryMetadataOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfGeocodeResult(struct soap *soap, ns4__ArrayOfGeocodeResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfGeocodeResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfGeocodeResult(struct soap *soap, ns4__ArrayOfGeocodeResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfGeocodeResult);
	if (soap_out_PointerTons4__ArrayOfGeocodeResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfGeocodeResult(struct soap *soap, const char *tag, int id, ns4__ArrayOfGeocodeResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfGeocodeResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfGeocodeResult ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfGeocodeResult(struct soap *soap, ns4__ArrayOfGeocodeResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfGeocodeResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__ArrayOfGeocodeResult ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfGeocodeResult(struct soap *soap, const char *tag, ns4__ArrayOfGeocodeResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfGeocodeResult **)soap_malloc(soap, sizeof(ns4__ArrayOfGeocodeResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfGeocodeResult *)soap_instantiate_ns4__ArrayOfGeocodeResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__ArrayOfGeocodeResult ** p = (ns4__ArrayOfGeocodeResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfGeocodeResult, sizeof(ns4__ArrayOfGeocodeResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__GeocodeOptions(struct soap *soap, ns10__GeocodeOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns10__GeocodeOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__GeocodeOptions(struct soap *soap, ns10__GeocodeOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons10__GeocodeOptions);
	if (soap_out_PointerTons10__GeocodeOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__GeocodeOptions(struct soap *soap, const char *tag, int id, ns10__GeocodeOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__GeocodeOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns10__GeocodeOptions ** SOAP_FMAC4 soap_get_PointerTons10__GeocodeOptions(struct soap *soap, ns10__GeocodeOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__GeocodeOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns10__GeocodeOptions ** SOAP_FMAC4 soap_in_PointerTons10__GeocodeOptions(struct soap *soap, const char *tag, ns10__GeocodeOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns10__GeocodeOptions **)soap_malloc(soap, sizeof(ns10__GeocodeOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns10__GeocodeOptions *)soap_instantiate_ns10__GeocodeOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns10__GeocodeOptions ** p = (ns10__GeocodeOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__GeocodeOptions, sizeof(ns10__GeocodeOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ArrayOfNeighborhood(struct soap *soap, ns6__ArrayOfNeighborhood *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ArrayOfNeighborhood))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ArrayOfNeighborhood(struct soap *soap, ns6__ArrayOfNeighborhood *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ArrayOfNeighborhood);
	if (soap_out_PointerTons6__ArrayOfNeighborhood(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ArrayOfNeighborhood(struct soap *soap, const char *tag, int id, ns6__ArrayOfNeighborhood *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ArrayOfNeighborhood);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ArrayOfNeighborhood ** SOAP_FMAC4 soap_get_PointerTons6__ArrayOfNeighborhood(struct soap *soap, ns6__ArrayOfNeighborhood **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ArrayOfNeighborhood(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__ArrayOfNeighborhood ** SOAP_FMAC4 soap_in_PointerTons6__ArrayOfNeighborhood(struct soap *soap, const char *tag, ns6__ArrayOfNeighborhood **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ArrayOfNeighborhood **)soap_malloc(soap, sizeof(ns6__ArrayOfNeighborhood *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ArrayOfNeighborhood *)soap_instantiate_ns6__ArrayOfNeighborhood(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__ArrayOfNeighborhood ** p = (ns6__ArrayOfNeighborhood **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArrayOfNeighborhood, sizeof(ns6__ArrayOfNeighborhood), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
	if (soap_out_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, const char *tag, int id, ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s ** SOAP_FMAC4 soap_get_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s ** SOAP_FMAC4 soap_in_PointerTons7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, const char *tag, ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s **)soap_malloc(soap, sizeof(ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *)soap_instantiate_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s ** p = (ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s, sizeof(ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ArrayOfCategory(struct soap *soap, ns6__ArrayOfCategory *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ArrayOfCategory))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ArrayOfCategory(struct soap *soap, ns6__ArrayOfCategory *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ArrayOfCategory);
	if (soap_out_PointerTons6__ArrayOfCategory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ArrayOfCategory(struct soap *soap, const char *tag, int id, ns6__ArrayOfCategory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ArrayOfCategory);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ArrayOfCategory ** SOAP_FMAC4 soap_get_PointerTons6__ArrayOfCategory(struct soap *soap, ns6__ArrayOfCategory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ArrayOfCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__ArrayOfCategory ** SOAP_FMAC4 soap_in_PointerTons6__ArrayOfCategory(struct soap *soap, const char *tag, ns6__ArrayOfCategory **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ArrayOfCategory **)soap_malloc(soap, sizeof(ns6__ArrayOfCategory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ArrayOfCategory *)soap_instantiate_ns6__ArrayOfCategory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__ArrayOfCategory ** p = (ns6__ArrayOfCategory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArrayOfCategory, sizeof(ns6__ArrayOfCategory), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ArrayOfanyType(struct soap *soap, ns7__ArrayOfanyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__ArrayOfanyType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ArrayOfanyType(struct soap *soap, ns7__ArrayOfanyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ArrayOfanyType);
	if (soap_out_PointerTons7__ArrayOfanyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__ArrayOfanyType(struct soap *soap, const char *tag, int id, ns7__ArrayOfanyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ArrayOfanyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ArrayOfanyType ** SOAP_FMAC4 soap_get_PointerTons7__ArrayOfanyType(struct soap *soap, ns7__ArrayOfanyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__ArrayOfanyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns7__ArrayOfanyType ** SOAP_FMAC4 soap_in_PointerTons7__ArrayOfanyType(struct soap *soap, const char *tag, ns7__ArrayOfanyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__ArrayOfanyType **)soap_malloc(soap, sizeof(ns7__ArrayOfanyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__ArrayOfanyType *)soap_instantiate_ns7__ArrayOfanyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns7__ArrayOfanyType ** p = (ns7__ArrayOfanyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ArrayOfanyType, sizeof(ns7__ArrayOfanyType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ArrayOfSearchResultSet(struct soap *soap, ns6__ArrayOfSearchResultSet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ArrayOfSearchResultSet))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ArrayOfSearchResultSet(struct soap *soap, ns6__ArrayOfSearchResultSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ArrayOfSearchResultSet);
	if (soap_out_PointerTons6__ArrayOfSearchResultSet(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ArrayOfSearchResultSet(struct soap *soap, const char *tag, int id, ns6__ArrayOfSearchResultSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ArrayOfSearchResultSet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ArrayOfSearchResultSet ** SOAP_FMAC4 soap_get_PointerTons6__ArrayOfSearchResultSet(struct soap *soap, ns6__ArrayOfSearchResultSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ArrayOfSearchResultSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__ArrayOfSearchResultSet ** SOAP_FMAC4 soap_in_PointerTons6__ArrayOfSearchResultSet(struct soap *soap, const char *tag, ns6__ArrayOfSearchResultSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ArrayOfSearchResultSet **)soap_malloc(soap, sizeof(ns6__ArrayOfSearchResultSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ArrayOfSearchResultSet *)soap_instantiate_ns6__ArrayOfSearchResultSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__ArrayOfSearchResultSet ** p = (ns6__ArrayOfSearchResultSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArrayOfSearchResultSet, sizeof(ns6__ArrayOfSearchResultSet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__QuerySuggestion(struct soap *soap, ns6__QuerySuggestion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__QuerySuggestion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__QuerySuggestion(struct soap *soap, ns6__QuerySuggestion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__QuerySuggestion);
	if (soap_out_PointerTons6__QuerySuggestion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__QuerySuggestion(struct soap *soap, const char *tag, int id, ns6__QuerySuggestion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__QuerySuggestion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__QuerySuggestion ** SOAP_FMAC4 soap_get_PointerTons6__QuerySuggestion(struct soap *soap, ns6__QuerySuggestion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__QuerySuggestion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__QuerySuggestion ** SOAP_FMAC4 soap_in_PointerTons6__QuerySuggestion(struct soap *soap, const char *tag, ns6__QuerySuggestion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__QuerySuggestion **)soap_malloc(soap, sizeof(ns6__QuerySuggestion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__QuerySuggestion *)soap_instantiate_ns6__QuerySuggestion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__QuerySuggestion ** p = (ns6__QuerySuggestion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__QuerySuggestion, sizeof(ns6__QuerySuggestion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SearchOptions(struct soap *soap, ns6__SearchOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__SearchOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SearchOptions(struct soap *soap, ns6__SearchOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__SearchOptions);
	if (soap_out_PointerTons6__SearchOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__SearchOptions(struct soap *soap, const char *tag, int id, ns6__SearchOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SearchOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__SearchOptions ** SOAP_FMAC4 soap_get_PointerTons6__SearchOptions(struct soap *soap, ns6__SearchOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__SearchOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__SearchOptions ** SOAP_FMAC4 soap_in_PointerTons6__SearchOptions(struct soap *soap, const char *tag, ns6__SearchOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SearchOptions **)soap_malloc(soap, sizeof(ns6__SearchOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__SearchOptions *)soap_instantiate_ns6__SearchOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__SearchOptions ** p = (ns6__SearchOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SearchOptions, sizeof(ns6__SearchOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__LogicalOperator(struct soap *soap, enum ns4__LogicalOperator *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns4__LogicalOperator);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__LogicalOperator(struct soap *soap, enum ns4__LogicalOperator *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__LogicalOperator);
	if (soap_out_PointerTons4__LogicalOperator(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__LogicalOperator(struct soap *soap, const char *tag, int id, enum ns4__LogicalOperator *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__LogicalOperator);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__LogicalOperator(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__LogicalOperator ** SOAP_FMAC4 soap_get_PointerTons4__LogicalOperator(struct soap *soap, enum ns4__LogicalOperator **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__LogicalOperator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns4__LogicalOperator ** SOAP_FMAC4 soap_in_PointerTons4__LogicalOperator(struct soap *soap, const char *tag, enum ns4__LogicalOperator **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__LogicalOperator **)soap_malloc(soap, sizeof(enum ns4__LogicalOperator *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__LogicalOperator(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__LogicalOperator **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__LogicalOperator, sizeof(enum ns4__LogicalOperator), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfFilterExpressionBase(struct soap *soap, ns4__ArrayOfFilterExpressionBase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfFilterExpressionBase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfFilterExpressionBase(struct soap *soap, ns4__ArrayOfFilterExpressionBase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfFilterExpressionBase);
	if (soap_out_PointerTons4__ArrayOfFilterExpressionBase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfFilterExpressionBase(struct soap *soap, const char *tag, int id, ns4__ArrayOfFilterExpressionBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfFilterExpressionBase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfFilterExpressionBase ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfFilterExpressionBase(struct soap *soap, ns4__ArrayOfFilterExpressionBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfFilterExpressionBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__ArrayOfFilterExpressionBase ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfFilterExpressionBase(struct soap *soap, const char *tag, ns4__ArrayOfFilterExpressionBase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfFilterExpressionBase **)soap_malloc(soap, sizeof(ns4__ArrayOfFilterExpressionBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfFilterExpressionBase *)soap_instantiate_ns4__ArrayOfFilterExpressionBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__ArrayOfFilterExpressionBase ** p = (ns4__ArrayOfFilterExpressionBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfFilterExpressionBase, sizeof(ns4__ArrayOfFilterExpressionBase), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__CompareOperator(struct soap *soap, enum ns4__CompareOperator *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns4__CompareOperator);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__CompareOperator(struct soap *soap, enum ns4__CompareOperator *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__CompareOperator);
	if (soap_out_PointerTons4__CompareOperator(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__CompareOperator(struct soap *soap, const char *tag, int id, enum ns4__CompareOperator *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__CompareOperator);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__CompareOperator(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__CompareOperator ** SOAP_FMAC4 soap_get_PointerTons4__CompareOperator(struct soap *soap, enum ns4__CompareOperator **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__CompareOperator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns4__CompareOperator ** SOAP_FMAC4 soap_in_PointerTons4__CompareOperator(struct soap *soap, const char *tag, enum ns4__CompareOperator **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__CompareOperator **)soap_malloc(soap, sizeof(enum ns4__CompareOperator *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__CompareOperator(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__CompareOperator **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__CompareOperator, sizeof(enum ns4__CompareOperator), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons16__RouteResult(struct soap *soap, ns16__RouteResult **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons16__RouteResult))
		soap_serialize_PointerTons16__RouteResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons16__RouteResult(struct soap *soap, ns16__RouteResult **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons16__RouteResult);
	if (soap_out_PointerToPointerTons16__RouteResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons16__RouteResult(struct soap *soap, const char *tag, int id, ns16__RouteResult **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons16__RouteResult);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons16__RouteResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns16__RouteResult *** SOAP_FMAC4 soap_get_PointerToPointerTons16__RouteResult(struct soap *soap, ns16__RouteResult ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons16__RouteResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__RouteResult *** SOAP_FMAC4 soap_in_PointerToPointerTons16__RouteResult(struct soap *soap, const char *tag, ns16__RouteResult ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__RouteResult ***)soap_malloc(soap, sizeof(ns16__RouteResult **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons16__RouteResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns16__RouteResult ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons16__RouteResult, sizeof(ns16__RouteResult *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__RouteResult(struct soap *soap, ns16__RouteResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__RouteResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__RouteResult(struct soap *soap, ns16__RouteResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__RouteResult);
	if (soap_out_PointerTons16__RouteResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__RouteResult(struct soap *soap, const char *tag, int id, ns16__RouteResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__RouteResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__RouteResult ** SOAP_FMAC4 soap_get_PointerTons16__RouteResult(struct soap *soap, ns16__RouteResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__RouteResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__RouteResult ** SOAP_FMAC4 soap_in_PointerTons16__RouteResult(struct soap *soap, const char *tag, ns16__RouteResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__RouteResult **)soap_malloc(soap, sizeof(ns16__RouteResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__RouteResult *)soap_instantiate_ns16__RouteResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__RouteResult ** p = (ns16__RouteResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RouteResult, sizeof(ns16__RouteResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfLocation(struct soap *soap, ns4__ArrayOfLocation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfLocation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfLocation(struct soap *soap, ns4__ArrayOfLocation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfLocation);
	if (soap_out_PointerTons4__ArrayOfLocation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfLocation(struct soap *soap, const char *tag, int id, ns4__ArrayOfLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfLocation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfLocation ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfLocation(struct soap *soap, ns4__ArrayOfLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__ArrayOfLocation ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfLocation(struct soap *soap, const char *tag, ns4__ArrayOfLocation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfLocation **)soap_malloc(soap, sizeof(ns4__ArrayOfLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfLocation *)soap_instantiate_ns4__ArrayOfLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__ArrayOfLocation ** p = (ns4__ArrayOfLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfLocation, sizeof(ns4__ArrayOfLocation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__ItineraryWarningType(struct soap *soap, enum ns16__ItineraryWarningType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns16__ItineraryWarningType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__ItineraryWarningType(struct soap *soap, enum ns16__ItineraryWarningType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__ItineraryWarningType);
	if (soap_out_PointerTons16__ItineraryWarningType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__ItineraryWarningType(struct soap *soap, const char *tag, int id, enum ns16__ItineraryWarningType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__ItineraryWarningType);
	if (id < 0)
		return soap->error;
	return soap_out_ns16__ItineraryWarningType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns16__ItineraryWarningType ** SOAP_FMAC4 soap_get_PointerTons16__ItineraryWarningType(struct soap *soap, enum ns16__ItineraryWarningType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__ItineraryWarningType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns16__ItineraryWarningType ** SOAP_FMAC4 soap_in_PointerTons16__ItineraryWarningType(struct soap *soap, const char *tag, enum ns16__ItineraryWarningType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns16__ItineraryWarningType **)soap_malloc(soap, sizeof(enum ns16__ItineraryWarningType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns16__ItineraryWarningType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns16__ItineraryWarningType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ItineraryWarningType, sizeof(enum ns16__ItineraryWarningType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__ItineraryWarningSeverity(struct soap *soap, enum ns16__ItineraryWarningSeverity *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns16__ItineraryWarningSeverity);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__ItineraryWarningSeverity(struct soap *soap, enum ns16__ItineraryWarningSeverity *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__ItineraryWarningSeverity);
	if (soap_out_PointerTons16__ItineraryWarningSeverity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__ItineraryWarningSeverity(struct soap *soap, const char *tag, int id, enum ns16__ItineraryWarningSeverity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__ItineraryWarningSeverity);
	if (id < 0)
		return soap->error;
	return soap_out_ns16__ItineraryWarningSeverity(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns16__ItineraryWarningSeverity ** SOAP_FMAC4 soap_get_PointerTons16__ItineraryWarningSeverity(struct soap *soap, enum ns16__ItineraryWarningSeverity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__ItineraryWarningSeverity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns16__ItineraryWarningSeverity ** SOAP_FMAC4 soap_in_PointerTons16__ItineraryWarningSeverity(struct soap *soap, const char *tag, enum ns16__ItineraryWarningSeverity **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns16__ItineraryWarningSeverity **)soap_malloc(soap, sizeof(enum ns16__ItineraryWarningSeverity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns16__ItineraryWarningSeverity(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns16__ItineraryWarningSeverity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ItineraryWarningSeverity, sizeof(enum ns16__ItineraryWarningSeverity), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons16__ItineraryItemWarning(struct soap *soap, ns16__ItineraryItemWarning **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons16__ItineraryItemWarning))
		soap_serialize_PointerTons16__ItineraryItemWarning(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons16__ItineraryItemWarning(struct soap *soap, ns16__ItineraryItemWarning **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons16__ItineraryItemWarning);
	if (soap_out_PointerToPointerTons16__ItineraryItemWarning(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons16__ItineraryItemWarning(struct soap *soap, const char *tag, int id, ns16__ItineraryItemWarning **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons16__ItineraryItemWarning);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons16__ItineraryItemWarning(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns16__ItineraryItemWarning *** SOAP_FMAC4 soap_get_PointerToPointerTons16__ItineraryItemWarning(struct soap *soap, ns16__ItineraryItemWarning ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons16__ItineraryItemWarning(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__ItineraryItemWarning *** SOAP_FMAC4 soap_in_PointerToPointerTons16__ItineraryItemWarning(struct soap *soap, const char *tag, ns16__ItineraryItemWarning ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__ItineraryItemWarning ***)soap_malloc(soap, sizeof(ns16__ItineraryItemWarning **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons16__ItineraryItemWarning(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns16__ItineraryItemWarning ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons16__ItineraryItemWarning, sizeof(ns16__ItineraryItemWarning *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__ItineraryItemWarning(struct soap *soap, ns16__ItineraryItemWarning *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__ItineraryItemWarning))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__ItineraryItemWarning(struct soap *soap, ns16__ItineraryItemWarning *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__ItineraryItemWarning);
	if (soap_out_PointerTons16__ItineraryItemWarning(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__ItineraryItemWarning(struct soap *soap, const char *tag, int id, ns16__ItineraryItemWarning *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__ItineraryItemWarning);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__ItineraryItemWarning ** SOAP_FMAC4 soap_get_PointerTons16__ItineraryItemWarning(struct soap *soap, ns16__ItineraryItemWarning **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__ItineraryItemWarning(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__ItineraryItemWarning ** SOAP_FMAC4 soap_in_PointerTons16__ItineraryItemWarning(struct soap *soap, const char *tag, ns16__ItineraryItemWarning **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__ItineraryItemWarning **)soap_malloc(soap, sizeof(ns16__ItineraryItemWarning *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__ItineraryItemWarning *)soap_instantiate_ns16__ItineraryItemWarning(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__ItineraryItemWarning ** p = (ns16__ItineraryItemWarning **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ItineraryItemWarning, sizeof(ns16__ItineraryItemWarning), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__ItineraryItemHintType(struct soap *soap, enum ns16__ItineraryItemHintType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns16__ItineraryItemHintType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__ItineraryItemHintType(struct soap *soap, enum ns16__ItineraryItemHintType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__ItineraryItemHintType);
	if (soap_out_PointerTons16__ItineraryItemHintType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__ItineraryItemHintType(struct soap *soap, const char *tag, int id, enum ns16__ItineraryItemHintType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__ItineraryItemHintType);
	if (id < 0)
		return soap->error;
	return soap_out_ns16__ItineraryItemHintType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns16__ItineraryItemHintType ** SOAP_FMAC4 soap_get_PointerTons16__ItineraryItemHintType(struct soap *soap, enum ns16__ItineraryItemHintType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__ItineraryItemHintType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns16__ItineraryItemHintType ** SOAP_FMAC4 soap_in_PointerTons16__ItineraryItemHintType(struct soap *soap, const char *tag, enum ns16__ItineraryItemHintType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns16__ItineraryItemHintType **)soap_malloc(soap, sizeof(enum ns16__ItineraryItemHintType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns16__ItineraryItemHintType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns16__ItineraryItemHintType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ItineraryItemHintType, sizeof(enum ns16__ItineraryItemHintType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons16__ItineraryItemHint(struct soap *soap, ns16__ItineraryItemHint **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons16__ItineraryItemHint))
		soap_serialize_PointerTons16__ItineraryItemHint(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons16__ItineraryItemHint(struct soap *soap, ns16__ItineraryItemHint **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons16__ItineraryItemHint);
	if (soap_out_PointerToPointerTons16__ItineraryItemHint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons16__ItineraryItemHint(struct soap *soap, const char *tag, int id, ns16__ItineraryItemHint **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons16__ItineraryItemHint);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons16__ItineraryItemHint(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns16__ItineraryItemHint *** SOAP_FMAC4 soap_get_PointerToPointerTons16__ItineraryItemHint(struct soap *soap, ns16__ItineraryItemHint ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons16__ItineraryItemHint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__ItineraryItemHint *** SOAP_FMAC4 soap_in_PointerToPointerTons16__ItineraryItemHint(struct soap *soap, const char *tag, ns16__ItineraryItemHint ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__ItineraryItemHint ***)soap_malloc(soap, sizeof(ns16__ItineraryItemHint **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons16__ItineraryItemHint(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns16__ItineraryItemHint ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons16__ItineraryItemHint, sizeof(ns16__ItineraryItemHint *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__ItineraryItemHint(struct soap *soap, ns16__ItineraryItemHint *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__ItineraryItemHint))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__ItineraryItemHint(struct soap *soap, ns16__ItineraryItemHint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__ItineraryItemHint);
	if (soap_out_PointerTons16__ItineraryItemHint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__ItineraryItemHint(struct soap *soap, const char *tag, int id, ns16__ItineraryItemHint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__ItineraryItemHint);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__ItineraryItemHint ** SOAP_FMAC4 soap_get_PointerTons16__ItineraryItemHint(struct soap *soap, ns16__ItineraryItemHint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__ItineraryItemHint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__ItineraryItemHint ** SOAP_FMAC4 soap_in_PointerTons16__ItineraryItemHint(struct soap *soap, const char *tag, ns16__ItineraryItemHint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__ItineraryItemHint **)soap_malloc(soap, sizeof(ns16__ItineraryItemHint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__ItineraryItemHint *)soap_instantiate_ns16__ItineraryItemHint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__ItineraryItemHint ** p = (ns16__ItineraryItemHint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ItineraryItemHint, sizeof(ns16__ItineraryItemHint), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__ArrayOfItineraryItemWarning(struct soap *soap, ns16__ArrayOfItineraryItemWarning *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__ArrayOfItineraryItemWarning))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__ArrayOfItineraryItemWarning(struct soap *soap, ns16__ArrayOfItineraryItemWarning *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__ArrayOfItineraryItemWarning);
	if (soap_out_PointerTons16__ArrayOfItineraryItemWarning(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__ArrayOfItineraryItemWarning(struct soap *soap, const char *tag, int id, ns16__ArrayOfItineraryItemWarning *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__ArrayOfItineraryItemWarning);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__ArrayOfItineraryItemWarning ** SOAP_FMAC4 soap_get_PointerTons16__ArrayOfItineraryItemWarning(struct soap *soap, ns16__ArrayOfItineraryItemWarning **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__ArrayOfItineraryItemWarning(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__ArrayOfItineraryItemWarning ** SOAP_FMAC4 soap_in_PointerTons16__ArrayOfItineraryItemWarning(struct soap *soap, const char *tag, ns16__ArrayOfItineraryItemWarning **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__ArrayOfItineraryItemWarning **)soap_malloc(soap, sizeof(ns16__ArrayOfItineraryItemWarning *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__ArrayOfItineraryItemWarning *)soap_instantiate_ns16__ArrayOfItineraryItemWarning(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__ArrayOfItineraryItemWarning ** p = (ns16__ArrayOfItineraryItemWarning **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ArrayOfItineraryItemWarning, sizeof(ns16__ArrayOfItineraryItemWarning), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__ManeuverType(struct soap *soap, enum ns16__ManeuverType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns16__ManeuverType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__ManeuverType(struct soap *soap, enum ns16__ManeuverType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__ManeuverType);
	if (soap_out_PointerTons16__ManeuverType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__ManeuverType(struct soap *soap, const char *tag, int id, enum ns16__ManeuverType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__ManeuverType);
	if (id < 0)
		return soap->error;
	return soap_out_ns16__ManeuverType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns16__ManeuverType ** SOAP_FMAC4 soap_get_PointerTons16__ManeuverType(struct soap *soap, enum ns16__ManeuverType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__ManeuverType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns16__ManeuverType ** SOAP_FMAC4 soap_in_PointerTons16__ManeuverType(struct soap *soap, const char *tag, enum ns16__ManeuverType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns16__ManeuverType **)soap_malloc(soap, sizeof(enum ns16__ManeuverType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns16__ManeuverType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns16__ManeuverType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ManeuverType, sizeof(enum ns16__ManeuverType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__ArrayOfItineraryItemHint(struct soap *soap, ns16__ArrayOfItineraryItemHint *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__ArrayOfItineraryItemHint))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__ArrayOfItineraryItemHint(struct soap *soap, ns16__ArrayOfItineraryItemHint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__ArrayOfItineraryItemHint);
	if (soap_out_PointerTons16__ArrayOfItineraryItemHint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__ArrayOfItineraryItemHint(struct soap *soap, const char *tag, int id, ns16__ArrayOfItineraryItemHint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__ArrayOfItineraryItemHint);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__ArrayOfItineraryItemHint ** SOAP_FMAC4 soap_get_PointerTons16__ArrayOfItineraryItemHint(struct soap *soap, ns16__ArrayOfItineraryItemHint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__ArrayOfItineraryItemHint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__ArrayOfItineraryItemHint ** SOAP_FMAC4 soap_in_PointerTons16__ArrayOfItineraryItemHint(struct soap *soap, const char *tag, ns16__ArrayOfItineraryItemHint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__ArrayOfItineraryItemHint **)soap_malloc(soap, sizeof(ns16__ArrayOfItineraryItemHint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__ArrayOfItineraryItemHint *)soap_instantiate_ns16__ArrayOfItineraryItemHint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__ArrayOfItineraryItemHint ** p = (ns16__ArrayOfItineraryItemHint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ArrayOfItineraryItemHint, sizeof(ns16__ArrayOfItineraryItemHint), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons16__ItineraryItem(struct soap *soap, ns16__ItineraryItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons16__ItineraryItem))
		soap_serialize_PointerTons16__ItineraryItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons16__ItineraryItem(struct soap *soap, ns16__ItineraryItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons16__ItineraryItem);
	if (soap_out_PointerToPointerTons16__ItineraryItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons16__ItineraryItem(struct soap *soap, const char *tag, int id, ns16__ItineraryItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons16__ItineraryItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons16__ItineraryItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns16__ItineraryItem *** SOAP_FMAC4 soap_get_PointerToPointerTons16__ItineraryItem(struct soap *soap, ns16__ItineraryItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons16__ItineraryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__ItineraryItem *** SOAP_FMAC4 soap_in_PointerToPointerTons16__ItineraryItem(struct soap *soap, const char *tag, ns16__ItineraryItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__ItineraryItem ***)soap_malloc(soap, sizeof(ns16__ItineraryItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons16__ItineraryItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns16__ItineraryItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons16__ItineraryItem, sizeof(ns16__ItineraryItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__ItineraryItem(struct soap *soap, ns16__ItineraryItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__ItineraryItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__ItineraryItem(struct soap *soap, ns16__ItineraryItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__ItineraryItem);
	if (soap_out_PointerTons16__ItineraryItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__ItineraryItem(struct soap *soap, const char *tag, int id, ns16__ItineraryItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__ItineraryItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__ItineraryItem ** SOAP_FMAC4 soap_get_PointerTons16__ItineraryItem(struct soap *soap, ns16__ItineraryItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__ItineraryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__ItineraryItem ** SOAP_FMAC4 soap_in_PointerTons16__ItineraryItem(struct soap *soap, const char *tag, ns16__ItineraryItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__ItineraryItem **)soap_malloc(soap, sizeof(ns16__ItineraryItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__ItineraryItem *)soap_instantiate_ns16__ItineraryItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__ItineraryItem ** p = (ns16__ItineraryItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ItineraryItem, sizeof(ns16__ItineraryItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__ArrayOfItineraryItem(struct soap *soap, ns16__ArrayOfItineraryItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__ArrayOfItineraryItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__ArrayOfItineraryItem(struct soap *soap, ns16__ArrayOfItineraryItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__ArrayOfItineraryItem);
	if (soap_out_PointerTons16__ArrayOfItineraryItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__ArrayOfItineraryItem(struct soap *soap, const char *tag, int id, ns16__ArrayOfItineraryItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__ArrayOfItineraryItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__ArrayOfItineraryItem ** SOAP_FMAC4 soap_get_PointerTons16__ArrayOfItineraryItem(struct soap *soap, ns16__ArrayOfItineraryItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__ArrayOfItineraryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__ArrayOfItineraryItem ** SOAP_FMAC4 soap_in_PointerTons16__ArrayOfItineraryItem(struct soap *soap, const char *tag, ns16__ArrayOfItineraryItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__ArrayOfItineraryItem **)soap_malloc(soap, sizeof(ns16__ArrayOfItineraryItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__ArrayOfItineraryItem *)soap_instantiate_ns16__ArrayOfItineraryItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__ArrayOfItineraryItem ** p = (ns16__ArrayOfItineraryItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ArrayOfItineraryItem, sizeof(ns16__ArrayOfItineraryItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons16__RouteLeg(struct soap *soap, ns16__RouteLeg **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons16__RouteLeg))
		soap_serialize_PointerTons16__RouteLeg(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons16__RouteLeg(struct soap *soap, ns16__RouteLeg **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons16__RouteLeg);
	if (soap_out_PointerToPointerTons16__RouteLeg(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons16__RouteLeg(struct soap *soap, const char *tag, int id, ns16__RouteLeg **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons16__RouteLeg);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons16__RouteLeg(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns16__RouteLeg *** SOAP_FMAC4 soap_get_PointerToPointerTons16__RouteLeg(struct soap *soap, ns16__RouteLeg ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons16__RouteLeg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__RouteLeg *** SOAP_FMAC4 soap_in_PointerToPointerTons16__RouteLeg(struct soap *soap, const char *tag, ns16__RouteLeg ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__RouteLeg ***)soap_malloc(soap, sizeof(ns16__RouteLeg **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons16__RouteLeg(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns16__RouteLeg ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons16__RouteLeg, sizeof(ns16__RouteLeg *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__RouteLeg(struct soap *soap, ns16__RouteLeg *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__RouteLeg))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__RouteLeg(struct soap *soap, ns16__RouteLeg *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__RouteLeg);
	if (soap_out_PointerTons16__RouteLeg(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__RouteLeg(struct soap *soap, const char *tag, int id, ns16__RouteLeg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__RouteLeg);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__RouteLeg ** SOAP_FMAC4 soap_get_PointerTons16__RouteLeg(struct soap *soap, ns16__RouteLeg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__RouteLeg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__RouteLeg ** SOAP_FMAC4 soap_in_PointerTons16__RouteLeg(struct soap *soap, const char *tag, ns16__RouteLeg **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__RouteLeg **)soap_malloc(soap, sizeof(ns16__RouteLeg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__RouteLeg *)soap_instantiate_ns16__RouteLeg(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__RouteLeg ** p = (ns16__RouteLeg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RouteLeg, sizeof(ns16__RouteLeg), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__RouteSummary(struct soap *soap, ns16__RouteSummary *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__RouteSummary))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__RouteSummary(struct soap *soap, ns16__RouteSummary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__RouteSummary);
	if (soap_out_PointerTons16__RouteSummary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__RouteSummary(struct soap *soap, const char *tag, int id, ns16__RouteSummary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__RouteSummary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__RouteSummary ** SOAP_FMAC4 soap_get_PointerTons16__RouteSummary(struct soap *soap, ns16__RouteSummary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__RouteSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__RouteSummary ** SOAP_FMAC4 soap_in_PointerTons16__RouteSummary(struct soap *soap, const char *tag, ns16__RouteSummary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__RouteSummary **)soap_malloc(soap, sizeof(ns16__RouteSummary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__RouteSummary *)soap_instantiate_ns16__RouteSummary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__RouteSummary ** p = (ns16__RouteSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RouteSummary, sizeof(ns16__RouteSummary), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__RoutePath(struct soap *soap, ns16__RoutePath *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__RoutePath))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__RoutePath(struct soap *soap, ns16__RoutePath *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__RoutePath);
	if (soap_out_PointerTons16__RoutePath(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__RoutePath(struct soap *soap, const char *tag, int id, ns16__RoutePath *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__RoutePath);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__RoutePath ** SOAP_FMAC4 soap_get_PointerTons16__RoutePath(struct soap *soap, ns16__RoutePath **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__RoutePath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__RoutePath ** SOAP_FMAC4 soap_in_PointerTons16__RoutePath(struct soap *soap, const char *tag, ns16__RoutePath **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__RoutePath **)soap_malloc(soap, sizeof(ns16__RoutePath *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__RoutePath *)soap_instantiate_ns16__RoutePath(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__RoutePath ** p = (ns16__RoutePath **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RoutePath, sizeof(ns16__RoutePath), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__ArrayOfRouteLeg(struct soap *soap, ns16__ArrayOfRouteLeg *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__ArrayOfRouteLeg))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__ArrayOfRouteLeg(struct soap *soap, ns16__ArrayOfRouteLeg *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__ArrayOfRouteLeg);
	if (soap_out_PointerTons16__ArrayOfRouteLeg(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__ArrayOfRouteLeg(struct soap *soap, const char *tag, int id, ns16__ArrayOfRouteLeg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__ArrayOfRouteLeg);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__ArrayOfRouteLeg ** SOAP_FMAC4 soap_get_PointerTons16__ArrayOfRouteLeg(struct soap *soap, ns16__ArrayOfRouteLeg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__ArrayOfRouteLeg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__ArrayOfRouteLeg ** SOAP_FMAC4 soap_in_PointerTons16__ArrayOfRouteLeg(struct soap *soap, const char *tag, ns16__ArrayOfRouteLeg **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__ArrayOfRouteLeg **)soap_malloc(soap, sizeof(ns16__ArrayOfRouteLeg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__ArrayOfRouteLeg *)soap_instantiate_ns16__ArrayOfRouteLeg(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__ArrayOfRouteLeg ** p = (ns16__ArrayOfRouteLeg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ArrayOfRouteLeg, sizeof(ns16__ArrayOfRouteLeg), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons16__Waypoint(struct soap *soap, ns16__Waypoint **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons16__Waypoint))
		soap_serialize_PointerTons16__Waypoint(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons16__Waypoint(struct soap *soap, ns16__Waypoint **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons16__Waypoint);
	if (soap_out_PointerToPointerTons16__Waypoint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons16__Waypoint(struct soap *soap, const char *tag, int id, ns16__Waypoint **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons16__Waypoint);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons16__Waypoint(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns16__Waypoint *** SOAP_FMAC4 soap_get_PointerToPointerTons16__Waypoint(struct soap *soap, ns16__Waypoint ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons16__Waypoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__Waypoint *** SOAP_FMAC4 soap_in_PointerToPointerTons16__Waypoint(struct soap *soap, const char *tag, ns16__Waypoint ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__Waypoint ***)soap_malloc(soap, sizeof(ns16__Waypoint **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons16__Waypoint(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns16__Waypoint ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons16__Waypoint, sizeof(ns16__Waypoint *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__Waypoint(struct soap *soap, ns16__Waypoint *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__Waypoint))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__Waypoint(struct soap *soap, ns16__Waypoint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__Waypoint);
	if (soap_out_PointerTons16__Waypoint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__Waypoint(struct soap *soap, const char *tag, int id, ns16__Waypoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__Waypoint);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__Waypoint ** SOAP_FMAC4 soap_get_PointerTons16__Waypoint(struct soap *soap, ns16__Waypoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__Waypoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__Waypoint ** SOAP_FMAC4 soap_in_PointerTons16__Waypoint(struct soap *soap, const char *tag, ns16__Waypoint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__Waypoint **)soap_malloc(soap, sizeof(ns16__Waypoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__Waypoint *)soap_instantiate_ns16__Waypoint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__Waypoint ** p = (ns16__Waypoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__Waypoint, sizeof(ns16__Waypoint), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__TrafficUsage(struct soap *soap, enum ns16__TrafficUsage *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns16__TrafficUsage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__TrafficUsage(struct soap *soap, enum ns16__TrafficUsage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__TrafficUsage);
	if (soap_out_PointerTons16__TrafficUsage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__TrafficUsage(struct soap *soap, const char *tag, int id, enum ns16__TrafficUsage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__TrafficUsage);
	if (id < 0)
		return soap->error;
	return soap_out_ns16__TrafficUsage(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns16__TrafficUsage ** SOAP_FMAC4 soap_get_PointerTons16__TrafficUsage(struct soap *soap, enum ns16__TrafficUsage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__TrafficUsage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns16__TrafficUsage ** SOAP_FMAC4 soap_in_PointerTons16__TrafficUsage(struct soap *soap, const char *tag, enum ns16__TrafficUsage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns16__TrafficUsage **)soap_malloc(soap, sizeof(enum ns16__TrafficUsage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns16__TrafficUsage(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns16__TrafficUsage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__TrafficUsage, sizeof(enum ns16__TrafficUsage), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__RoutePathType(struct soap *soap, enum ns16__RoutePathType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns16__RoutePathType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__RoutePathType(struct soap *soap, enum ns16__RoutePathType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__RoutePathType);
	if (soap_out_PointerTons16__RoutePathType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__RoutePathType(struct soap *soap, const char *tag, int id, enum ns16__RoutePathType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__RoutePathType);
	if (id < 0)
		return soap->error;
	return soap_out_ns16__RoutePathType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns16__RoutePathType ** SOAP_FMAC4 soap_get_PointerTons16__RoutePathType(struct soap *soap, enum ns16__RoutePathType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__RoutePathType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns16__RoutePathType ** SOAP_FMAC4 soap_in_PointerTons16__RoutePathType(struct soap *soap, const char *tag, enum ns16__RoutePathType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns16__RoutePathType **)soap_malloc(soap, sizeof(enum ns16__RoutePathType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns16__RoutePathType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns16__RoutePathType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RoutePathType, sizeof(enum ns16__RoutePathType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__RouteOptimization(struct soap *soap, enum ns16__RouteOptimization *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns16__RouteOptimization);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__RouteOptimization(struct soap *soap, enum ns16__RouteOptimization *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__RouteOptimization);
	if (soap_out_PointerTons16__RouteOptimization(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__RouteOptimization(struct soap *soap, const char *tag, int id, enum ns16__RouteOptimization *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__RouteOptimization);
	if (id < 0)
		return soap->error;
	return soap_out_ns16__RouteOptimization(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns16__RouteOptimization ** SOAP_FMAC4 soap_get_PointerTons16__RouteOptimization(struct soap *soap, enum ns16__RouteOptimization **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__RouteOptimization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns16__RouteOptimization ** SOAP_FMAC4 soap_in_PointerTons16__RouteOptimization(struct soap *soap, const char *tag, enum ns16__RouteOptimization **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns16__RouteOptimization **)soap_malloc(soap, sizeof(enum ns16__RouteOptimization *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns16__RouteOptimization(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns16__RouteOptimization **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RouteOptimization, sizeof(enum ns16__RouteOptimization), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__TravelMode(struct soap *soap, enum ns16__TravelMode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns16__TravelMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__TravelMode(struct soap *soap, enum ns16__TravelMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__TravelMode);
	if (soap_out_PointerTons16__TravelMode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__TravelMode(struct soap *soap, const char *tag, int id, enum ns16__TravelMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__TravelMode);
	if (id < 0)
		return soap->error;
	return soap_out_ns16__TravelMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns16__TravelMode ** SOAP_FMAC4 soap_get_PointerTons16__TravelMode(struct soap *soap, enum ns16__TravelMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__TravelMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns16__TravelMode ** SOAP_FMAC4 soap_in_PointerTons16__TravelMode(struct soap *soap, const char *tag, enum ns16__TravelMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns16__TravelMode **)soap_malloc(soap, sizeof(enum ns16__TravelMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns16__TravelMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns16__TravelMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__TravelMode, sizeof(enum ns16__TravelMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__MajorRoutesResponse(struct soap *soap, ns16__MajorRoutesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__MajorRoutesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__MajorRoutesResponse(struct soap *soap, ns16__MajorRoutesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__MajorRoutesResponse);
	if (soap_out_PointerTons16__MajorRoutesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__MajorRoutesResponse(struct soap *soap, const char *tag, int id, ns16__MajorRoutesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__MajorRoutesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__MajorRoutesResponse ** SOAP_FMAC4 soap_get_PointerTons16__MajorRoutesResponse(struct soap *soap, ns16__MajorRoutesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__MajorRoutesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__MajorRoutesResponse ** SOAP_FMAC4 soap_in_PointerTons16__MajorRoutesResponse(struct soap *soap, const char *tag, ns16__MajorRoutesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__MajorRoutesResponse **)soap_malloc(soap, sizeof(ns16__MajorRoutesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__MajorRoutesResponse *)soap_instantiate_ns16__MajorRoutesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__MajorRoutesResponse ** p = (ns16__MajorRoutesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__MajorRoutesResponse, sizeof(ns16__MajorRoutesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__MajorRoutesRequest(struct soap *soap, ns16__MajorRoutesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__MajorRoutesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__MajorRoutesRequest(struct soap *soap, ns16__MajorRoutesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__MajorRoutesRequest);
	if (soap_out_PointerTons16__MajorRoutesRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__MajorRoutesRequest(struct soap *soap, const char *tag, int id, ns16__MajorRoutesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__MajorRoutesRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__MajorRoutesRequest ** SOAP_FMAC4 soap_get_PointerTons16__MajorRoutesRequest(struct soap *soap, ns16__MajorRoutesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__MajorRoutesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__MajorRoutesRequest ** SOAP_FMAC4 soap_in_PointerTons16__MajorRoutesRequest(struct soap *soap, const char *tag, ns16__MajorRoutesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__MajorRoutesRequest **)soap_malloc(soap, sizeof(ns16__MajorRoutesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__MajorRoutesRequest *)soap_instantiate_ns16__MajorRoutesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__MajorRoutesRequest ** p = (ns16__MajorRoutesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__MajorRoutesRequest, sizeof(ns16__MajorRoutesRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__RouteResponse(struct soap *soap, ns16__RouteResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__RouteResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__RouteResponse(struct soap *soap, ns16__RouteResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__RouteResponse);
	if (soap_out_PointerTons16__RouteResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__RouteResponse(struct soap *soap, const char *tag, int id, ns16__RouteResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__RouteResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__RouteResponse ** SOAP_FMAC4 soap_get_PointerTons16__RouteResponse(struct soap *soap, ns16__RouteResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__RouteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__RouteResponse ** SOAP_FMAC4 soap_in_PointerTons16__RouteResponse(struct soap *soap, const char *tag, ns16__RouteResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__RouteResponse **)soap_malloc(soap, sizeof(ns16__RouteResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__RouteResponse *)soap_instantiate_ns16__RouteResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__RouteResponse ** p = (ns16__RouteResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RouteResponse, sizeof(ns16__RouteResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__RouteRequest(struct soap *soap, ns16__RouteRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__RouteRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__RouteRequest(struct soap *soap, ns16__RouteRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__RouteRequest);
	if (soap_out_PointerTons16__RouteRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__RouteRequest(struct soap *soap, const char *tag, int id, ns16__RouteRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__RouteRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__RouteRequest ** SOAP_FMAC4 soap_get_PointerTons16__RouteRequest(struct soap *soap, ns16__RouteRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__RouteRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns16__RouteRequest ** SOAP_FMAC4 soap_in_PointerTons16__RouteRequest(struct soap *soap, const char *tag, ns16__RouteRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__RouteRequest **)soap_malloc(soap, sizeof(ns16__RouteRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__RouteRequest *)soap_instantiate_ns16__RouteRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns16__RouteRequest ** p = (ns16__RouteRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RouteRequest, sizeof(ns16__RouteRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__MapStyle(struct soap *soap, enum ns4__MapStyle *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns4__MapStyle);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__MapStyle(struct soap *soap, enum ns4__MapStyle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__MapStyle);
	if (soap_out_PointerTons4__MapStyle(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__MapStyle(struct soap *soap, const char *tag, int id, enum ns4__MapStyle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__MapStyle);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__MapStyle(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__MapStyle ** SOAP_FMAC4 soap_get_PointerTons4__MapStyle(struct soap *soap, enum ns4__MapStyle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__MapStyle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns4__MapStyle ** SOAP_FMAC4 soap_in_PointerTons4__MapStyle(struct soap *soap, const char *tag, enum ns4__MapStyle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__MapStyle **)soap_malloc(soap, sizeof(enum ns4__MapStyle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__MapStyle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__MapStyle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__MapStyle, sizeof(enum ns4__MapStyle), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ImageType(struct soap *soap, enum ns4__ImageType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns4__ImageType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ImageType(struct soap *soap, enum ns4__ImageType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ImageType);
	if (soap_out_PointerTons4__ImageType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ImageType(struct soap *soap, const char *tag, int id, enum ns4__ImageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ImageType);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__ImageType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__ImageType ** SOAP_FMAC4 soap_get_PointerTons4__ImageType(struct soap *soap, enum ns4__ImageType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ImageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns4__ImageType ** SOAP_FMAC4 soap_in_PointerTons4__ImageType(struct soap *soap, const char *tag, enum ns4__ImageType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__ImageType **)soap_malloc(soap, sizeof(enum ns4__ImageType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__ImageType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__ImageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ImageType, sizeof(enum ns4__ImageType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons13__CoverageArea(struct soap *soap, ns13__CoverageArea **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons13__CoverageArea))
		soap_serialize_PointerTons13__CoverageArea(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons13__CoverageArea(struct soap *soap, ns13__CoverageArea **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons13__CoverageArea);
	if (soap_out_PointerToPointerTons13__CoverageArea(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons13__CoverageArea(struct soap *soap, const char *tag, int id, ns13__CoverageArea **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons13__CoverageArea);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons13__CoverageArea(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns13__CoverageArea *** SOAP_FMAC4 soap_get_PointerToPointerTons13__CoverageArea(struct soap *soap, ns13__CoverageArea ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons13__CoverageArea(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__CoverageArea *** SOAP_FMAC4 soap_in_PointerToPointerTons13__CoverageArea(struct soap *soap, const char *tag, ns13__CoverageArea ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__CoverageArea ***)soap_malloc(soap, sizeof(ns13__CoverageArea **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons13__CoverageArea(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns13__CoverageArea ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons13__CoverageArea, sizeof(ns13__CoverageArea *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons13__CoverageArea(struct soap *soap, ns13__CoverageArea *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns13__CoverageArea))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons13__CoverageArea(struct soap *soap, ns13__CoverageArea *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons13__CoverageArea);
	if (soap_out_PointerTons13__CoverageArea(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons13__CoverageArea(struct soap *soap, const char *tag, int id, ns13__CoverageArea *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns13__CoverageArea);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns13__CoverageArea ** SOAP_FMAC4 soap_get_PointerTons13__CoverageArea(struct soap *soap, ns13__CoverageArea **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons13__CoverageArea(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__CoverageArea ** SOAP_FMAC4 soap_in_PointerTons13__CoverageArea(struct soap *soap, const char *tag, ns13__CoverageArea **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__CoverageArea **)soap_malloc(soap, sizeof(ns13__CoverageArea *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns13__CoverageArea *)soap_instantiate_ns13__CoverageArea(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns13__CoverageArea ** p = (ns13__CoverageArea **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__CoverageArea, sizeof(ns13__CoverageArea), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons13__ArrayOfCoverageArea(struct soap *soap, ns13__ArrayOfCoverageArea *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns13__ArrayOfCoverageArea))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons13__ArrayOfCoverageArea(struct soap *soap, ns13__ArrayOfCoverageArea *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons13__ArrayOfCoverageArea);
	if (soap_out_PointerTons13__ArrayOfCoverageArea(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons13__ArrayOfCoverageArea(struct soap *soap, const char *tag, int id, ns13__ArrayOfCoverageArea *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns13__ArrayOfCoverageArea);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns13__ArrayOfCoverageArea ** SOAP_FMAC4 soap_get_PointerTons13__ArrayOfCoverageArea(struct soap *soap, ns13__ArrayOfCoverageArea **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons13__ArrayOfCoverageArea(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__ArrayOfCoverageArea ** SOAP_FMAC4 soap_in_PointerTons13__ArrayOfCoverageArea(struct soap *soap, const char *tag, ns13__ArrayOfCoverageArea **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__ArrayOfCoverageArea **)soap_malloc(soap, sizeof(ns13__ArrayOfCoverageArea *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns13__ArrayOfCoverageArea *)soap_instantiate_ns13__ArrayOfCoverageArea(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns13__ArrayOfCoverageArea ** p = (ns13__ArrayOfCoverageArea **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ArrayOfCoverageArea, sizeof(ns13__ArrayOfCoverageArea), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons13__ImageryProvider(struct soap *soap, ns13__ImageryProvider **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons13__ImageryProvider))
		soap_serialize_PointerTons13__ImageryProvider(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons13__ImageryProvider(struct soap *soap, ns13__ImageryProvider **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons13__ImageryProvider);
	if (soap_out_PointerToPointerTons13__ImageryProvider(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons13__ImageryProvider(struct soap *soap, const char *tag, int id, ns13__ImageryProvider **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons13__ImageryProvider);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons13__ImageryProvider(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns13__ImageryProvider *** SOAP_FMAC4 soap_get_PointerToPointerTons13__ImageryProvider(struct soap *soap, ns13__ImageryProvider ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons13__ImageryProvider(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__ImageryProvider *** SOAP_FMAC4 soap_in_PointerToPointerTons13__ImageryProvider(struct soap *soap, const char *tag, ns13__ImageryProvider ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__ImageryProvider ***)soap_malloc(soap, sizeof(ns13__ImageryProvider **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons13__ImageryProvider(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns13__ImageryProvider ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons13__ImageryProvider, sizeof(ns13__ImageryProvider *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons13__ImageryProvider(struct soap *soap, ns13__ImageryProvider *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns13__ImageryProvider))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons13__ImageryProvider(struct soap *soap, ns13__ImageryProvider *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons13__ImageryProvider);
	if (soap_out_PointerTons13__ImageryProvider(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons13__ImageryProvider(struct soap *soap, const char *tag, int id, ns13__ImageryProvider *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns13__ImageryProvider);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns13__ImageryProvider ** SOAP_FMAC4 soap_get_PointerTons13__ImageryProvider(struct soap *soap, ns13__ImageryProvider **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons13__ImageryProvider(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__ImageryProvider ** SOAP_FMAC4 soap_in_PointerTons13__ImageryProvider(struct soap *soap, const char *tag, ns13__ImageryProvider **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__ImageryProvider **)soap_malloc(soap, sizeof(ns13__ImageryProvider *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns13__ImageryProvider *)soap_instantiate_ns13__ImageryProvider(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns13__ImageryProvider ** p = (ns13__ImageryProvider **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ImageryProvider, sizeof(ns13__ImageryProvider), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__RangeOfint(struct soap *soap, ns4__RangeOfint *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__RangeOfint))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__RangeOfint(struct soap *soap, ns4__RangeOfint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__RangeOfint);
	if (soap_out_PointerTons4__RangeOfint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__RangeOfint(struct soap *soap, const char *tag, int id, ns4__RangeOfint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__RangeOfint);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__RangeOfint ** SOAP_FMAC4 soap_get_PointerTons4__RangeOfint(struct soap *soap, ns4__RangeOfint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__RangeOfint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__RangeOfint ** SOAP_FMAC4 soap_in_PointerTons4__RangeOfint(struct soap *soap, const char *tag, ns4__RangeOfint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__RangeOfint **)soap_malloc(soap, sizeof(ns4__RangeOfint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__RangeOfint *)soap_instantiate_ns4__RangeOfint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__RangeOfint ** p = (ns4__RangeOfint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__RangeOfint, sizeof(ns4__RangeOfint), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__RangeOfdateTime(struct soap *soap, ns4__RangeOfdateTime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__RangeOfdateTime))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__RangeOfdateTime(struct soap *soap, ns4__RangeOfdateTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__RangeOfdateTime);
	if (soap_out_PointerTons4__RangeOfdateTime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__RangeOfdateTime(struct soap *soap, const char *tag, int id, ns4__RangeOfdateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__RangeOfdateTime);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__RangeOfdateTime ** SOAP_FMAC4 soap_get_PointerTons4__RangeOfdateTime(struct soap *soap, ns4__RangeOfdateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__RangeOfdateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__RangeOfdateTime ** SOAP_FMAC4 soap_in_PointerTons4__RangeOfdateTime(struct soap *soap, const char *tag, ns4__RangeOfdateTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__RangeOfdateTime **)soap_malloc(soap, sizeof(ns4__RangeOfdateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__RangeOfdateTime *)soap_instantiate_ns4__RangeOfdateTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__RangeOfdateTime ** p = (ns4__RangeOfdateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__RangeOfdateTime, sizeof(ns4__RangeOfdateTime), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons13__ArrayOfImageryProvider(struct soap *soap, ns13__ArrayOfImageryProvider *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns13__ArrayOfImageryProvider))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons13__ArrayOfImageryProvider(struct soap *soap, ns13__ArrayOfImageryProvider *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons13__ArrayOfImageryProvider);
	if (soap_out_PointerTons13__ArrayOfImageryProvider(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons13__ArrayOfImageryProvider(struct soap *soap, const char *tag, int id, ns13__ArrayOfImageryProvider *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns13__ArrayOfImageryProvider);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns13__ArrayOfImageryProvider ** SOAP_FMAC4 soap_get_PointerTons13__ArrayOfImageryProvider(struct soap *soap, ns13__ArrayOfImageryProvider **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons13__ArrayOfImageryProvider(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__ArrayOfImageryProvider ** SOAP_FMAC4 soap_in_PointerTons13__ArrayOfImageryProvider(struct soap *soap, const char *tag, ns13__ArrayOfImageryProvider **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__ArrayOfImageryProvider **)soap_malloc(soap, sizeof(ns13__ArrayOfImageryProvider *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns13__ArrayOfImageryProvider *)soap_instantiate_ns13__ArrayOfImageryProvider(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns13__ArrayOfImageryProvider ** p = (ns13__ArrayOfImageryProvider **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ArrayOfImageryProvider, sizeof(ns13__ArrayOfImageryProvider), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons13__ImageryMetadataResult(struct soap *soap, ns13__ImageryMetadataResult **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons13__ImageryMetadataResult))
		soap_serialize_PointerTons13__ImageryMetadataResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons13__ImageryMetadataResult(struct soap *soap, ns13__ImageryMetadataResult **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons13__ImageryMetadataResult);
	if (soap_out_PointerToPointerTons13__ImageryMetadataResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons13__ImageryMetadataResult(struct soap *soap, const char *tag, int id, ns13__ImageryMetadataResult **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons13__ImageryMetadataResult);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons13__ImageryMetadataResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns13__ImageryMetadataResult *** SOAP_FMAC4 soap_get_PointerToPointerTons13__ImageryMetadataResult(struct soap *soap, ns13__ImageryMetadataResult ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons13__ImageryMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__ImageryMetadataResult *** SOAP_FMAC4 soap_in_PointerToPointerTons13__ImageryMetadataResult(struct soap *soap, const char *tag, ns13__ImageryMetadataResult ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__ImageryMetadataResult ***)soap_malloc(soap, sizeof(ns13__ImageryMetadataResult **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons13__ImageryMetadataResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns13__ImageryMetadataResult ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons13__ImageryMetadataResult, sizeof(ns13__ImageryMetadataResult *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons13__ImageryMetadataResult(struct soap *soap, ns13__ImageryMetadataResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns13__ImageryMetadataResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons13__ImageryMetadataResult(struct soap *soap, ns13__ImageryMetadataResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons13__ImageryMetadataResult);
	if (soap_out_PointerTons13__ImageryMetadataResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons13__ImageryMetadataResult(struct soap *soap, const char *tag, int id, ns13__ImageryMetadataResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns13__ImageryMetadataResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns13__ImageryMetadataResult ** SOAP_FMAC4 soap_get_PointerTons13__ImageryMetadataResult(struct soap *soap, ns13__ImageryMetadataResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons13__ImageryMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__ImageryMetadataResult ** SOAP_FMAC4 soap_in_PointerTons13__ImageryMetadataResult(struct soap *soap, const char *tag, ns13__ImageryMetadataResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__ImageryMetadataResult **)soap_malloc(soap, sizeof(ns13__ImageryMetadataResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns13__ImageryMetadataResult *)soap_instantiate_ns13__ImageryMetadataResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns13__ImageryMetadataResult ** p = (ns13__ImageryMetadataResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ImageryMetadataResult, sizeof(ns13__ImageryMetadataResult), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns13__ImageryMetadataResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult, sizeof(ns13__ImageryMetadataBirdseyeResult), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__UriScheme(struct soap *soap, enum ns4__UriScheme *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns4__UriScheme);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__UriScheme(struct soap *soap, enum ns4__UriScheme *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__UriScheme);
	if (soap_out_PointerTons4__UriScheme(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__UriScheme(struct soap *soap, const char *tag, int id, enum ns4__UriScheme *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__UriScheme);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__UriScheme(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__UriScheme ** SOAP_FMAC4 soap_get_PointerTons4__UriScheme(struct soap *soap, enum ns4__UriScheme **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__UriScheme(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns4__UriScheme ** SOAP_FMAC4 soap_in_PointerTons4__UriScheme(struct soap *soap, const char *tag, enum ns4__UriScheme **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__UriScheme **)soap_malloc(soap, sizeof(enum ns4__UriScheme *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__UriScheme(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__UriScheme **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__UriScheme, sizeof(enum ns4__UriScheme), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons13__MapUriResponse(struct soap *soap, ns13__MapUriResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns13__MapUriResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons13__MapUriResponse(struct soap *soap, ns13__MapUriResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons13__MapUriResponse);
	if (soap_out_PointerTons13__MapUriResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons13__MapUriResponse(struct soap *soap, const char *tag, int id, ns13__MapUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns13__MapUriResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns13__MapUriResponse ** SOAP_FMAC4 soap_get_PointerTons13__MapUriResponse(struct soap *soap, ns13__MapUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons13__MapUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__MapUriResponse ** SOAP_FMAC4 soap_in_PointerTons13__MapUriResponse(struct soap *soap, const char *tag, ns13__MapUriResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__MapUriResponse **)soap_malloc(soap, sizeof(ns13__MapUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns13__MapUriResponse *)soap_instantiate_ns13__MapUriResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns13__MapUriResponse ** p = (ns13__MapUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__MapUriResponse, sizeof(ns13__MapUriResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons13__MapUriRequest(struct soap *soap, ns13__MapUriRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns13__MapUriRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons13__MapUriRequest(struct soap *soap, ns13__MapUriRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons13__MapUriRequest);
	if (soap_out_PointerTons13__MapUriRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons13__MapUriRequest(struct soap *soap, const char *tag, int id, ns13__MapUriRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns13__MapUriRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns13__MapUriRequest ** SOAP_FMAC4 soap_get_PointerTons13__MapUriRequest(struct soap *soap, ns13__MapUriRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons13__MapUriRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__MapUriRequest ** SOAP_FMAC4 soap_in_PointerTons13__MapUriRequest(struct soap *soap, const char *tag, ns13__MapUriRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__MapUriRequest **)soap_malloc(soap, sizeof(ns13__MapUriRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns13__MapUriRequest *)soap_instantiate_ns13__MapUriRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns13__MapUriRequest ** p = (ns13__MapUriRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__MapUriRequest, sizeof(ns13__MapUriRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons13__ImageryMetadataResponse(struct soap *soap, ns13__ImageryMetadataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns13__ImageryMetadataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons13__ImageryMetadataResponse(struct soap *soap, ns13__ImageryMetadataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons13__ImageryMetadataResponse);
	if (soap_out_PointerTons13__ImageryMetadataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons13__ImageryMetadataResponse(struct soap *soap, const char *tag, int id, ns13__ImageryMetadataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns13__ImageryMetadataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns13__ImageryMetadataResponse ** SOAP_FMAC4 soap_get_PointerTons13__ImageryMetadataResponse(struct soap *soap, ns13__ImageryMetadataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons13__ImageryMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__ImageryMetadataResponse ** SOAP_FMAC4 soap_in_PointerTons13__ImageryMetadataResponse(struct soap *soap, const char *tag, ns13__ImageryMetadataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__ImageryMetadataResponse **)soap_malloc(soap, sizeof(ns13__ImageryMetadataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns13__ImageryMetadataResponse *)soap_instantiate_ns13__ImageryMetadataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns13__ImageryMetadataResponse ** p = (ns13__ImageryMetadataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ImageryMetadataResponse, sizeof(ns13__ImageryMetadataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons13__ImageryMetadataRequest(struct soap *soap, ns13__ImageryMetadataRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns13__ImageryMetadataRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons13__ImageryMetadataRequest(struct soap *soap, ns13__ImageryMetadataRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons13__ImageryMetadataRequest);
	if (soap_out_PointerTons13__ImageryMetadataRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons13__ImageryMetadataRequest(struct soap *soap, const char *tag, int id, ns13__ImageryMetadataRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns13__ImageryMetadataRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns13__ImageryMetadataRequest ** SOAP_FMAC4 soap_get_PointerTons13__ImageryMetadataRequest(struct soap *soap, ns13__ImageryMetadataRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons13__ImageryMetadataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns13__ImageryMetadataRequest ** SOAP_FMAC4 soap_in_PointerTons13__ImageryMetadataRequest(struct soap *soap, const char *tag, ns13__ImageryMetadataRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__ImageryMetadataRequest **)soap_malloc(soap, sizeof(ns13__ImageryMetadataRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns13__ImageryMetadataRequest *)soap_instantiate_ns13__ImageryMetadataRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns13__ImageryMetadataRequest ** p = (ns13__ImageryMetadataRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ImageryMetadataRequest, sizeof(ns13__ImageryMetadataRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons10__FilterBase(struct soap *soap, ns10__FilterBase **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons10__FilterBase))
		soap_serialize_PointerTons10__FilterBase(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons10__FilterBase(struct soap *soap, ns10__FilterBase **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons10__FilterBase);
	if (soap_out_PointerToPointerTons10__FilterBase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons10__FilterBase(struct soap *soap, const char *tag, int id, ns10__FilterBase **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons10__FilterBase);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons10__FilterBase(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns10__FilterBase *** SOAP_FMAC4 soap_get_PointerToPointerTons10__FilterBase(struct soap *soap, ns10__FilterBase ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons10__FilterBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns10__FilterBase *** SOAP_FMAC4 soap_in_PointerToPointerTons10__FilterBase(struct soap *soap, const char *tag, ns10__FilterBase ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns10__FilterBase ***)soap_malloc(soap, sizeof(ns10__FilterBase **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons10__FilterBase(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns10__FilterBase ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons10__FilterBase, sizeof(ns10__FilterBase *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__FilterBase(struct soap *soap, ns10__FilterBase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns10__FilterBase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__FilterBase(struct soap *soap, ns10__FilterBase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons10__FilterBase);
	if (soap_out_PointerTons10__FilterBase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__FilterBase(struct soap *soap, const char *tag, int id, ns10__FilterBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__FilterBase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns10__FilterBase ** SOAP_FMAC4 soap_get_PointerTons10__FilterBase(struct soap *soap, ns10__FilterBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__FilterBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns10__FilterBase ** SOAP_FMAC4 soap_in_PointerTons10__FilterBase(struct soap *soap, const char *tag, ns10__FilterBase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns10__FilterBase **)soap_malloc(soap, sizeof(ns10__FilterBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns10__FilterBase *)soap_instantiate_ns10__FilterBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns10__FilterBase ** p = (ns10__FilterBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__FilterBase, sizeof(ns10__FilterBase), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns10__FilterBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__ConfidenceFilter, sizeof(ns10__ConfidenceFilter), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__ArrayOfFilterBase(struct soap *soap, ns10__ArrayOfFilterBase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns10__ArrayOfFilterBase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__ArrayOfFilterBase(struct soap *soap, ns10__ArrayOfFilterBase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons10__ArrayOfFilterBase);
	if (soap_out_PointerTons10__ArrayOfFilterBase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__ArrayOfFilterBase(struct soap *soap, const char *tag, int id, ns10__ArrayOfFilterBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__ArrayOfFilterBase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns10__ArrayOfFilterBase ** SOAP_FMAC4 soap_get_PointerTons10__ArrayOfFilterBase(struct soap *soap, ns10__ArrayOfFilterBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__ArrayOfFilterBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns10__ArrayOfFilterBase ** SOAP_FMAC4 soap_in_PointerTons10__ArrayOfFilterBase(struct soap *soap, const char *tag, ns10__ArrayOfFilterBase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns10__ArrayOfFilterBase **)soap_malloc(soap, sizeof(ns10__ArrayOfFilterBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns10__ArrayOfFilterBase *)soap_instantiate_ns10__ArrayOfFilterBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns10__ArrayOfFilterBase ** p = (ns10__ArrayOfFilterBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__ArrayOfFilterBase, sizeof(ns10__ArrayOfFilterBase), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__ReverseGeocodeRequest(struct soap *soap, ns10__ReverseGeocodeRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns10__ReverseGeocodeRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__ReverseGeocodeRequest(struct soap *soap, ns10__ReverseGeocodeRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons10__ReverseGeocodeRequest);
	if (soap_out_PointerTons10__ReverseGeocodeRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__ReverseGeocodeRequest(struct soap *soap, const char *tag, int id, ns10__ReverseGeocodeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__ReverseGeocodeRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns10__ReverseGeocodeRequest ** SOAP_FMAC4 soap_get_PointerTons10__ReverseGeocodeRequest(struct soap *soap, ns10__ReverseGeocodeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__ReverseGeocodeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns10__ReverseGeocodeRequest ** SOAP_FMAC4 soap_in_PointerTons10__ReverseGeocodeRequest(struct soap *soap, const char *tag, ns10__ReverseGeocodeRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns10__ReverseGeocodeRequest **)soap_malloc(soap, sizeof(ns10__ReverseGeocodeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns10__ReverseGeocodeRequest *)soap_instantiate_ns10__ReverseGeocodeRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns10__ReverseGeocodeRequest ** p = (ns10__ReverseGeocodeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__ReverseGeocodeRequest, sizeof(ns10__ReverseGeocodeRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__GeocodeResponse(struct soap *soap, ns10__GeocodeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns10__GeocodeResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__GeocodeResponse(struct soap *soap, ns10__GeocodeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons10__GeocodeResponse);
	if (soap_out_PointerTons10__GeocodeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__GeocodeResponse(struct soap *soap, const char *tag, int id, ns10__GeocodeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__GeocodeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns10__GeocodeResponse ** SOAP_FMAC4 soap_get_PointerTons10__GeocodeResponse(struct soap *soap, ns10__GeocodeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__GeocodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns10__GeocodeResponse ** SOAP_FMAC4 soap_in_PointerTons10__GeocodeResponse(struct soap *soap, const char *tag, ns10__GeocodeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns10__GeocodeResponse **)soap_malloc(soap, sizeof(ns10__GeocodeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns10__GeocodeResponse *)soap_instantiate_ns10__GeocodeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns10__GeocodeResponse ** p = (ns10__GeocodeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__GeocodeResponse, sizeof(ns10__GeocodeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__GeocodeRequest(struct soap *soap, ns10__GeocodeRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns10__GeocodeRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__GeocodeRequest(struct soap *soap, ns10__GeocodeRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons10__GeocodeRequest);
	if (soap_out_PointerTons10__GeocodeRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__GeocodeRequest(struct soap *soap, const char *tag, int id, ns10__GeocodeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__GeocodeRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns10__GeocodeRequest ** SOAP_FMAC4 soap_get_PointerTons10__GeocodeRequest(struct soap *soap, ns10__GeocodeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__GeocodeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns10__GeocodeRequest ** SOAP_FMAC4 soap_in_PointerTons10__GeocodeRequest(struct soap *soap, const char *tag, ns10__GeocodeRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns10__GeocodeRequest **)soap_malloc(soap, sizeof(ns10__GeocodeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns10__GeocodeRequest *)soap_instantiate_ns10__GeocodeRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns10__GeocodeRequest ** p = (ns10__GeocodeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__GeocodeRequest, sizeof(ns10__GeocodeRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
	if (soap_out_PointerTo_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, const char *tag, int id, _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s ** SOAP_FMAC4 soap_get_PointerTo_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s ** SOAP_FMAC4 soap_in_PointerTo_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(struct soap *soap, const char *tag, _ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s **)soap_malloc(soap, sizeof(_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s *)soap_instantiate__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s ** p = (_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s, sizeof(_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s_KeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__CategorySpecificPropertySet(struct soap *soap, ns6__CategorySpecificPropertySet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__CategorySpecificPropertySet))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__CategorySpecificPropertySet(struct soap *soap, ns6__CategorySpecificPropertySet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__CategorySpecificPropertySet);
	if (soap_out_PointerTons6__CategorySpecificPropertySet(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__CategorySpecificPropertySet(struct soap *soap, const char *tag, int id, ns6__CategorySpecificPropertySet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__CategorySpecificPropertySet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__CategorySpecificPropertySet ** SOAP_FMAC4 soap_get_PointerTons6__CategorySpecificPropertySet(struct soap *soap, ns6__CategorySpecificPropertySet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__CategorySpecificPropertySet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__CategorySpecificPropertySet ** SOAP_FMAC4 soap_in_PointerTons6__CategorySpecificPropertySet(struct soap *soap, const char *tag, ns6__CategorySpecificPropertySet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__CategorySpecificPropertySet **)soap_malloc(soap, sizeof(ns6__CategorySpecificPropertySet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__CategorySpecificPropertySet *)soap_instantiate_ns6__CategorySpecificPropertySet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__CategorySpecificPropertySet ** p = (ns6__CategorySpecificPropertySet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CategorySpecificPropertySet, sizeof(ns6__CategorySpecificPropertySet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(struct soap *soap, _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(struct soap *soap, _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType);
	if (soap_out_PointerTo_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(struct soap *soap, const char *tag, int id, _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType ** SOAP_FMAC4 soap_get_PointerTo_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(struct soap *soap, _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType ** SOAP_FMAC4 soap_in_PointerTo_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(struct soap *soap, const char *tag, _ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType **)soap_malloc(soap, sizeof(_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType *)soap_instantiate__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType ** p = (_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType, sizeof(_ns7__ArrayOfKeyValueOfstringanyType_KeyValueOfstringanyType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6);
	if (soap_out_PointerTo_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, const char *tag, int id, _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 ** SOAP_FMAC4 soap_get_PointerTo_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 ** SOAP_FMAC4 soap_in_PointerTo_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, const char *tag, _ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 **)soap_malloc(soap, sizeof(_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 *)soap_instantiate__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 ** p = (_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6, sizeof(_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6_KeyValueOfNeighborhoodintkC8b0tr6), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToxsd__anyType(struct soap *soap, xsd__anyType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToxsd__anyType))
		soap_serialize_PointerToxsd__anyType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToxsd__anyType(struct soap *soap, xsd__anyType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToxsd__anyType);
	if (soap_out_PointerToPointerToxsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToxsd__anyType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToxsd__anyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 xsd__anyType *** SOAP_FMAC4 soap_get_PointerToPointerToxsd__anyType(struct soap *soap, xsd__anyType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToxsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__anyType *** SOAP_FMAC4 soap_in_PointerToPointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType ***)soap_malloc(soap, sizeof(xsd__anyType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToxsd__anyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (xsd__anyType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToxsd__anyType, sizeof(xsd__anyType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, xsd__anyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__anyType *)soap_instantiate_xsd__anyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__anyType ** p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__QName, sizeof(xsd__QName), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI_, sizeof(xsd__anyURI_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary_, sizeof(xsd__base64Binary_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__byte_, sizeof(xsd__byte_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__decimal_, sizeof(xsd__decimal_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__double, sizeof(xsd__double), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration_, sizeof(xsd__duration_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__float, sizeof(xsd__float), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__int, sizeof(xsd__int), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__long, sizeof(xsd__long), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__short, sizeof(xsd__short), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__string, sizeof(xsd__string), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__unsignedByte_, sizeof(xsd__unsignedByte_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__unsignedInt, sizeof(xsd__unsignedInt), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__unsignedLong, sizeof(xsd__unsignedLong), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__unsignedShort, sizeof(xsd__unsignedShort), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DataSourceCapability_, sizeof(ns1__DataSourceCapability_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DistanceUnit_, sizeof(ns1__DistanceUnit_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Confidence_, sizeof(ns4__Confidence_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DeviceType_, sizeof(ns4__DeviceType_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DistanceUnit_, sizeof(ns4__DistanceUnit_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__CompareOperator_, sizeof(ns4__CompareOperator_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__LogicalOperator_, sizeof(ns4__LogicalOperator_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__AuthenticationResultCode_, sizeof(ns4__AuthenticationResultCode_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ResponseStatusCode_, sizeof(ns4__ResponseStatusCode_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__UriScheme_, sizeof(ns4__UriScheme_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__MapStyle_, sizeof(ns4__MapStyle_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ImageType_, sizeof(ns4__ImageType_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__char__, sizeof(ns5__char__), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__duration__, sizeof(ns5__duration__), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__guid__, sizeof(ns5__guid__), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ListingType_, sizeof(ns6__ListingType_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SortOrder_, sizeof(ns6__SortOrder_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__TravelMode_, sizeof(ns16__TravelMode_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RouteOptimization_, sizeof(ns16__RouteOptimization_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RoutePathType_, sizeof(ns16__RoutePathType_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__TrafficUsage_, sizeof(ns16__TrafficUsage_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ItineraryItemHintType_, sizeof(ns16__ItineraryItemHintType_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ManeuverType_, sizeof(ns16__ManeuverType_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ItineraryWarningSeverity_, sizeof(ns16__ItineraryWarningSeverity_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ItineraryWarningType_, sizeof(ns16__ItineraryWarningType_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfVersionInfo, sizeof(ns1__ArrayOfVersionInfo), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VersionInfo, sizeof(ns1__VersionInfo), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CustomerInfoHeader, sizeof(ns1__CustomerInfoHeader), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UserInfoHeader, sizeof(ns1__UserInfoHeader), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CultureInfo, sizeof(ns1__CultureInfo), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CountryRegionContext, sizeof(ns1__CountryRegionContext), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfInt, sizeof(ns1__ArrayOfInt), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfCountryRegionInfo, sizeof(ns1__ArrayOfCountryRegionInfo), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CountryRegionInfo, sizeof(ns1__CountryRegionInfo), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LatLong, sizeof(ns1__LatLong), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfEntityType, sizeof(ns1__ArrayOfEntityType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EntityType, sizeof(ns1__EntityType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfEntityProperty, sizeof(ns1__ArrayOfEntityProperty), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EntityProperty, sizeof(ns1__EntityProperty), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDataSource, sizeof(ns1__ArrayOfDataSource), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DataSource, sizeof(ns1__DataSource), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfLatLong, sizeof(ns1__ArrayOfLatLong), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDouble, sizeof(ns1__ArrayOfDouble), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TokenSpecification, sizeof(ns1__TokenSpecification), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__RequestBase, sizeof(ns4__RequestBase), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Credentials, sizeof(ns4__Credentials), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ExecutionOptions, sizeof(ns4__ExecutionOptions), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__UserProfile, sizeof(ns4__UserProfile), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Heading, sizeof(ns4__Heading), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Location, sizeof(ns4__Location), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ShapeBase, sizeof(ns4__ShapeBase), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfLocation, sizeof(ns4__ArrayOfLocation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__SizeOfint, sizeof(ns4__SizeOfint), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__FilterExpressionBase, sizeof(ns4__FilterExpressionBase), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfFilterExpressionBase, sizeof(ns4__ArrayOfFilterExpressionBase), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ResponseBase, sizeof(ns4__ResponseBase), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ResponseSummary, sizeof(ns4__ResponseSummary), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GeocodeResult, sizeof(ns4__GeocodeResult), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Address, sizeof(ns4__Address), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfGeocodeLocation, sizeof(ns4__ArrayOfGeocodeLocation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfGeocodeResult, sizeof(ns4__ArrayOfGeocodeResult), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__RangeOfint, sizeof(ns4__RangeOfint), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__RangeOfdateTime, sizeof(ns4__RangeOfdateTime), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfPushpin, sizeof(ns4__ArrayOfPushpin), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Pushpin, sizeof(ns4__Pushpin), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SearchOptions, sizeof(ns6__SearchOptions), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__StructuredSearchQuery, sizeof(ns6__StructuredSearchQuery), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__QuerySuggestion, sizeof(ns6__QuerySuggestion), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArrayOfSearchResultSet, sizeof(ns6__ArrayOfSearchResultSet), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SearchResultSet, sizeof(ns6__SearchResultSet), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArrayOfSearchRegion, sizeof(ns6__ArrayOfSearchRegion), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SearchRegion, sizeof(ns6__SearchRegion), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArrayOfAvailableFilter, sizeof(ns6__ArrayOfAvailableFilter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__AvailableFilter, sizeof(ns6__AvailableFilter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Neighborhood, sizeof(ns6__Neighborhood), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Category, sizeof(ns6__Category), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__FilterValue, sizeof(ns6__FilterValue), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArrayOfCategoryCount, sizeof(ns6__ArrayOfCategoryCount), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CategoryCount, sizeof(ns6__CategoryCount), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Parse, sizeof(ns6__Parse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArrayOfSearchResultBase, sizeof(ns6__ArrayOfSearchResultBase), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SearchResultBase, sizeof(ns6__SearchResultBase), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__LocationData, sizeof(ns6__LocationData), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArrayOfCategory, sizeof(ns6__ArrayOfCategory), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CategorySpecificPropertySet, sizeof(ns6__CategorySpecificPropertySet), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArrayOfNeighborhood, sizeof(ns6__ArrayOfNeighborhood), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ArrayOfstring, sizeof(ns7__ArrayOfstring), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ArrayOfanyType, sizeof(ns7__ArrayOfanyType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6, sizeof(ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType, sizeof(ns7__ArrayOfKeyValueOfstringanyType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s, sizeof(ns7__ArrayOfKeyValueOfintCategorySpecificPropertySetn6Q9q_USCOREP9s), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__GeocodeOptions, sizeof(ns10__GeocodeOptions), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__ArrayOfFilterBase, sizeof(ns10__ArrayOfFilterBase), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__FilterBase, sizeof(ns10__FilterBase), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ImageryMetadataOptions, sizeof(ns13__ImageryMetadataOptions), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ArrayOfImageryMetadataResult, sizeof(ns13__ArrayOfImageryMetadataResult), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ImageryMetadataResult, sizeof(ns13__ImageryMetadataResult), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ArrayOfImageryProvider, sizeof(ns13__ArrayOfImageryProvider), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ImageryProvider, sizeof(ns13__ImageryProvider), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ArrayOfCoverageArea, sizeof(ns13__ArrayOfCoverageArea), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__CoverageArea, sizeof(ns13__CoverageArea), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__MapUriOptions, sizeof(ns13__MapUriOptions), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RouteOptions, sizeof(ns16__RouteOptions), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ArrayOfWaypoint, sizeof(ns16__ArrayOfWaypoint), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__Waypoint, sizeof(ns16__Waypoint), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RouteResult, sizeof(ns16__RouteResult), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ArrayOfRouteLeg, sizeof(ns16__ArrayOfRouteLeg), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RouteLeg, sizeof(ns16__RouteLeg), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ArrayOfItineraryItem, sizeof(ns16__ArrayOfItineraryItem), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ItineraryItem, sizeof(ns16__ItineraryItem), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ArrayOfItineraryItemHint, sizeof(ns16__ArrayOfItineraryItemHint), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ItineraryItemHint, sizeof(ns16__ItineraryItemHint), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RouteSummary, sizeof(ns16__RouteSummary), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ArrayOfItineraryItemWarning, sizeof(ns16__ArrayOfItineraryItemWarning), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ItineraryItemWarning, sizeof(ns16__ItineraryItemWarning), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RoutePath, sizeof(ns16__RoutePath), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__ArrayOfRouteResult, sizeof(ns16__ArrayOfRouteResult), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__UserLocation, sizeof(ns4__UserLocation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GeocodeLocation, sizeof(ns4__GeocodeLocation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Rectangle, sizeof(ns4__Rectangle), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Circle, sizeof(ns4__Circle), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Polygon, sizeof(ns4__Polygon), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__FilterExpression, sizeof(ns4__FilterExpression), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__FilterExpressionClause, sizeof(ns4__FilterExpressionClause), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SearchRequest, sizeof(ns6__SearchRequest), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SearchResponse, sizeof(ns6__SearchResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RangeFilter, sizeof(ns6__RangeFilter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ValueListFilter, sizeof(ns6__ValueListFilter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CommunityContentSearchResult, sizeof(ns6__CommunityContentSearchResult), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__BusinessSearchResult, sizeof(ns6__BusinessSearchResult), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__PersonSearchResult, sizeof(ns6__PersonSearchResult), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SearchPoint, sizeof(ns6__SearchPoint), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__GeocodeRequest, sizeof(ns10__GeocodeRequest), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__ConfidenceFilter, sizeof(ns10__ConfidenceFilter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__GeocodeResponse, sizeof(ns10__GeocodeResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__ReverseGeocodeRequest, sizeof(ns10__ReverseGeocodeRequest), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ImageryMetadataRequest, sizeof(ns13__ImageryMetadataRequest), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ImageryMetadataResponse, sizeof(ns13__ImageryMetadataResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__ImageryMetadataBirdseyeResult, sizeof(ns13__ImageryMetadataBirdseyeResult), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__MapUriRequest, sizeof(ns13__MapUriRequest), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__MapUriResponse, sizeof(ns13__MapUriResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RouteRequest, sizeof(ns16__RouteRequest), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__RouteResponse, sizeof(ns16__RouteResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__MajorRoutesRequest, sizeof(ns16__MajorRoutesRequest), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__MajorRoutesOptions, sizeof(ns16__MajorRoutesOptions), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__MajorRoutesResponse, sizeof(ns16__MajorRoutesResponse), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__Neighborhood(struct soap *soap, ns6__Neighborhood **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__Neighborhood))
		soap_serialize_PointerTons6__Neighborhood(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__Neighborhood(struct soap *soap, ns6__Neighborhood **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__Neighborhood);
	if (soap_out_PointerToPointerTons6__Neighborhood(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons6__Neighborhood(struct soap *soap, const char *tag, int id, ns6__Neighborhood **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__Neighborhood);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons6__Neighborhood(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__Neighborhood *** SOAP_FMAC4 soap_get_PointerToPointerTons6__Neighborhood(struct soap *soap, ns6__Neighborhood ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons6__Neighborhood(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__Neighborhood *** SOAP_FMAC4 soap_in_PointerToPointerTons6__Neighborhood(struct soap *soap, const char *tag, ns6__Neighborhood ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__Neighborhood ***)soap_malloc(soap, sizeof(ns6__Neighborhood **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons6__Neighborhood(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns6__Neighborhood ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__Neighborhood, sizeof(ns6__Neighborhood *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Neighborhood(struct soap *soap, ns6__Neighborhood *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__Neighborhood))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Neighborhood(struct soap *soap, ns6__Neighborhood *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Neighborhood);
	if (soap_out_PointerTons6__Neighborhood(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__Neighborhood(struct soap *soap, const char *tag, int id, ns6__Neighborhood *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Neighborhood);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Neighborhood ** SOAP_FMAC4 soap_get_PointerTons6__Neighborhood(struct soap *soap, ns6__Neighborhood **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__Neighborhood(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__Neighborhood ** SOAP_FMAC4 soap_in_PointerTons6__Neighborhood(struct soap *soap, const char *tag, ns6__Neighborhood **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__Neighborhood **)soap_malloc(soap, sizeof(ns6__Neighborhood *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__Neighborhood *)soap_instantiate_ns6__Neighborhood(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__Neighborhood ** p = (ns6__Neighborhood **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Neighborhood, sizeof(ns6__Neighborhood), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ArrayOfKeyValueOfstringanyType(struct soap *soap, ns7__ArrayOfKeyValueOfstringanyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ArrayOfKeyValueOfstringanyType(struct soap *soap, ns7__ArrayOfKeyValueOfstringanyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ArrayOfKeyValueOfstringanyType);
	if (soap_out_PointerTons7__ArrayOfKeyValueOfstringanyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__ArrayOfKeyValueOfstringanyType(struct soap *soap, const char *tag, int id, ns7__ArrayOfKeyValueOfstringanyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfstringanyType ** SOAP_FMAC4 soap_get_PointerTons7__ArrayOfKeyValueOfstringanyType(struct soap *soap, ns7__ArrayOfKeyValueOfstringanyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__ArrayOfKeyValueOfstringanyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfstringanyType ** SOAP_FMAC4 soap_in_PointerTons7__ArrayOfKeyValueOfstringanyType(struct soap *soap, const char *tag, ns7__ArrayOfKeyValueOfstringanyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__ArrayOfKeyValueOfstringanyType **)soap_malloc(soap, sizeof(ns7__ArrayOfKeyValueOfstringanyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__ArrayOfKeyValueOfstringanyType *)soap_instantiate_ns7__ArrayOfKeyValueOfstringanyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns7__ArrayOfKeyValueOfstringanyType ** p = (ns7__ArrayOfKeyValueOfstringanyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ArrayOfKeyValueOfstringanyType, sizeof(ns7__ArrayOfKeyValueOfstringanyType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__Category(struct soap *soap, ns6__Category **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__Category))
		soap_serialize_PointerTons6__Category(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__Category(struct soap *soap, ns6__Category **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__Category);
	if (soap_out_PointerToPointerTons6__Category(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons6__Category(struct soap *soap, const char *tag, int id, ns6__Category **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__Category);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons6__Category(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__Category *** SOAP_FMAC4 soap_get_PointerToPointerTons6__Category(struct soap *soap, ns6__Category ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons6__Category(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__Category *** SOAP_FMAC4 soap_in_PointerToPointerTons6__Category(struct soap *soap, const char *tag, ns6__Category ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__Category ***)soap_malloc(soap, sizeof(ns6__Category **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons6__Category(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns6__Category ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__Category, sizeof(ns6__Category *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__LocationData(struct soap *soap, ns6__LocationData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__LocationData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__LocationData(struct soap *soap, ns6__LocationData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__LocationData);
	if (soap_out_PointerTons6__LocationData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__LocationData(struct soap *soap, const char *tag, int id, ns6__LocationData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__LocationData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__LocationData ** SOAP_FMAC4 soap_get_PointerTons6__LocationData(struct soap *soap, ns6__LocationData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__LocationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__LocationData ** SOAP_FMAC4 soap_in_PointerTons6__LocationData(struct soap *soap, const char *tag, ns6__LocationData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__LocationData **)soap_malloc(soap, sizeof(ns6__LocationData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__LocationData *)soap_instantiate_ns6__LocationData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__LocationData ** p = (ns6__LocationData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__LocationData, sizeof(ns6__LocationData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__SearchResultBase(struct soap *soap, ns6__SearchResultBase **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__SearchResultBase))
		soap_serialize_PointerTons6__SearchResultBase(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__SearchResultBase(struct soap *soap, ns6__SearchResultBase **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__SearchResultBase);
	if (soap_out_PointerToPointerTons6__SearchResultBase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons6__SearchResultBase(struct soap *soap, const char *tag, int id, ns6__SearchResultBase **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__SearchResultBase);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons6__SearchResultBase(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__SearchResultBase *** SOAP_FMAC4 soap_get_PointerToPointerTons6__SearchResultBase(struct soap *soap, ns6__SearchResultBase ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons6__SearchResultBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__SearchResultBase *** SOAP_FMAC4 soap_in_PointerToPointerTons6__SearchResultBase(struct soap *soap, const char *tag, ns6__SearchResultBase ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SearchResultBase ***)soap_malloc(soap, sizeof(ns6__SearchResultBase **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons6__SearchResultBase(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns6__SearchResultBase ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__SearchResultBase, sizeof(ns6__SearchResultBase *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SearchResultBase(struct soap *soap, ns6__SearchResultBase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__SearchResultBase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SearchResultBase(struct soap *soap, ns6__SearchResultBase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__SearchResultBase);
	if (soap_out_PointerTons6__SearchResultBase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__SearchResultBase(struct soap *soap, const char *tag, int id, ns6__SearchResultBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SearchResultBase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__SearchResultBase ** SOAP_FMAC4 soap_get_PointerTons6__SearchResultBase(struct soap *soap, ns6__SearchResultBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__SearchResultBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__SearchResultBase ** SOAP_FMAC4 soap_in_PointerTons6__SearchResultBase(struct soap *soap, const char *tag, ns6__SearchResultBase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SearchResultBase **)soap_malloc(soap, sizeof(ns6__SearchResultBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__SearchResultBase *)soap_instantiate_ns6__SearchResultBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__SearchResultBase ** p = (ns6__SearchResultBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SearchResultBase, sizeof(ns6__SearchResultBase), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns6__SearchResultBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CommunityContentSearchResult, sizeof(ns6__CommunityContentSearchResult), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns6__SearchResultBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__BusinessSearchResult, sizeof(ns6__BusinessSearchResult), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns6__SearchResultBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__PersonSearchResult, sizeof(ns6__PersonSearchResult), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6);
	if (soap_out_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, const char *tag, int id, ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 ** SOAP_FMAC4 soap_get_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 ** SOAP_FMAC4 soap_in_PointerTons7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(struct soap *soap, const char *tag, ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 **)soap_malloc(soap, sizeof(ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 *)soap_instantiate_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 ** p = (ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6, sizeof(ns7__ArrayOfKeyValueOfNeighborhoodintkC8b0tr6), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Category(struct soap *soap, ns6__Category *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__Category))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Category(struct soap *soap, ns6__Category *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Category);
	if (soap_out_PointerTons6__Category(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__Category(struct soap *soap, const char *tag, int id, ns6__Category *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Category);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Category ** SOAP_FMAC4 soap_get_PointerTons6__Category(struct soap *soap, ns6__Category **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__Category(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__Category ** SOAP_FMAC4 soap_in_PointerTons6__Category(struct soap *soap, const char *tag, ns6__Category **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__Category **)soap_malloc(soap, sizeof(ns6__Category *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__Category *)soap_instantiate_ns6__Category(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__Category ** p = (ns6__Category **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Category, sizeof(ns6__Category), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__CategoryCount(struct soap *soap, ns6__CategoryCount **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__CategoryCount))
		soap_serialize_PointerTons6__CategoryCount(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__CategoryCount(struct soap *soap, ns6__CategoryCount **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__CategoryCount);
	if (soap_out_PointerToPointerTons6__CategoryCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons6__CategoryCount(struct soap *soap, const char *tag, int id, ns6__CategoryCount **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__CategoryCount);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons6__CategoryCount(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__CategoryCount *** SOAP_FMAC4 soap_get_PointerToPointerTons6__CategoryCount(struct soap *soap, ns6__CategoryCount ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons6__CategoryCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__CategoryCount *** SOAP_FMAC4 soap_in_PointerToPointerTons6__CategoryCount(struct soap *soap, const char *tag, ns6__CategoryCount ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__CategoryCount ***)soap_malloc(soap, sizeof(ns6__CategoryCount **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons6__CategoryCount(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns6__CategoryCount ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__CategoryCount, sizeof(ns6__CategoryCount *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__CategoryCount(struct soap *soap, ns6__CategoryCount *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__CategoryCount))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__CategoryCount(struct soap *soap, ns6__CategoryCount *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__CategoryCount);
	if (soap_out_PointerTons6__CategoryCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__CategoryCount(struct soap *soap, const char *tag, int id, ns6__CategoryCount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__CategoryCount);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__CategoryCount ** SOAP_FMAC4 soap_get_PointerTons6__CategoryCount(struct soap *soap, ns6__CategoryCount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__CategoryCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__CategoryCount ** SOAP_FMAC4 soap_in_PointerTons6__CategoryCount(struct soap *soap, const char *tag, ns6__CategoryCount **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__CategoryCount **)soap_malloc(soap, sizeof(ns6__CategoryCount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__CategoryCount *)soap_instantiate_ns6__CategoryCount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__CategoryCount ** p = (ns6__CategoryCount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CategoryCount, sizeof(ns6__CategoryCount), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__AvailableFilter(struct soap *soap, ns6__AvailableFilter **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__AvailableFilter))
		soap_serialize_PointerTons6__AvailableFilter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__AvailableFilter(struct soap *soap, ns6__AvailableFilter **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__AvailableFilter);
	if (soap_out_PointerToPointerTons6__AvailableFilter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons6__AvailableFilter(struct soap *soap, const char *tag, int id, ns6__AvailableFilter **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__AvailableFilter);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons6__AvailableFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__AvailableFilter *** SOAP_FMAC4 soap_get_PointerToPointerTons6__AvailableFilter(struct soap *soap, ns6__AvailableFilter ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons6__AvailableFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__AvailableFilter *** SOAP_FMAC4 soap_in_PointerToPointerTons6__AvailableFilter(struct soap *soap, const char *tag, ns6__AvailableFilter ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__AvailableFilter ***)soap_malloc(soap, sizeof(ns6__AvailableFilter **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons6__AvailableFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns6__AvailableFilter ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__AvailableFilter, sizeof(ns6__AvailableFilter *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__AvailableFilter(struct soap *soap, ns6__AvailableFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__AvailableFilter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__AvailableFilter(struct soap *soap, ns6__AvailableFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__AvailableFilter);
	if (soap_out_PointerTons6__AvailableFilter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__AvailableFilter(struct soap *soap, const char *tag, int id, ns6__AvailableFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__AvailableFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__AvailableFilter ** SOAP_FMAC4 soap_get_PointerTons6__AvailableFilter(struct soap *soap, ns6__AvailableFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__AvailableFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__AvailableFilter ** SOAP_FMAC4 soap_in_PointerTons6__AvailableFilter(struct soap *soap, const char *tag, ns6__AvailableFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__AvailableFilter **)soap_malloc(soap, sizeof(ns6__AvailableFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__AvailableFilter *)soap_instantiate_ns6__AvailableFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__AvailableFilter ** p = (ns6__AvailableFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__AvailableFilter, sizeof(ns6__AvailableFilter), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns6__AvailableFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RangeFilter, sizeof(ns6__RangeFilter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns6__AvailableFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ValueListFilter, sizeof(ns6__ValueListFilter), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__SearchRegion(struct soap *soap, ns6__SearchRegion **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__SearchRegion))
		soap_serialize_PointerTons6__SearchRegion(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__SearchRegion(struct soap *soap, ns6__SearchRegion **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__SearchRegion);
	if (soap_out_PointerToPointerTons6__SearchRegion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons6__SearchRegion(struct soap *soap, const char *tag, int id, ns6__SearchRegion **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__SearchRegion);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons6__SearchRegion(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__SearchRegion *** SOAP_FMAC4 soap_get_PointerToPointerTons6__SearchRegion(struct soap *soap, ns6__SearchRegion ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons6__SearchRegion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__SearchRegion *** SOAP_FMAC4 soap_in_PointerToPointerTons6__SearchRegion(struct soap *soap, const char *tag, ns6__SearchRegion ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SearchRegion ***)soap_malloc(soap, sizeof(ns6__SearchRegion **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons6__SearchRegion(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns6__SearchRegion ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__SearchRegion, sizeof(ns6__SearchRegion *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SearchRegion(struct soap *soap, ns6__SearchRegion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__SearchRegion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SearchRegion(struct soap *soap, ns6__SearchRegion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__SearchRegion);
	if (soap_out_PointerTons6__SearchRegion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__SearchRegion(struct soap *soap, const char *tag, int id, ns6__SearchRegion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SearchRegion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__SearchRegion ** SOAP_FMAC4 soap_get_PointerTons6__SearchRegion(struct soap *soap, ns6__SearchRegion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__SearchRegion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__SearchRegion ** SOAP_FMAC4 soap_in_PointerTons6__SearchRegion(struct soap *soap, const char *tag, ns6__SearchRegion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SearchRegion **)soap_malloc(soap, sizeof(ns6__SearchRegion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__SearchRegion *)soap_instantiate_ns6__SearchRegion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__SearchRegion ** p = (ns6__SearchRegion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SearchRegion, sizeof(ns6__SearchRegion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ArrayOfSearchResultBase(struct soap *soap, ns6__ArrayOfSearchResultBase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ArrayOfSearchResultBase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ArrayOfSearchResultBase(struct soap *soap, ns6__ArrayOfSearchResultBase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ArrayOfSearchResultBase);
	if (soap_out_PointerTons6__ArrayOfSearchResultBase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ArrayOfSearchResultBase(struct soap *soap, const char *tag, int id, ns6__ArrayOfSearchResultBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ArrayOfSearchResultBase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ArrayOfSearchResultBase ** SOAP_FMAC4 soap_get_PointerTons6__ArrayOfSearchResultBase(struct soap *soap, ns6__ArrayOfSearchResultBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ArrayOfSearchResultBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__ArrayOfSearchResultBase ** SOAP_FMAC4 soap_in_PointerTons6__ArrayOfSearchResultBase(struct soap *soap, const char *tag, ns6__ArrayOfSearchResultBase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ArrayOfSearchResultBase **)soap_malloc(soap, sizeof(ns6__ArrayOfSearchResultBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ArrayOfSearchResultBase *)soap_instantiate_ns6__ArrayOfSearchResultBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__ArrayOfSearchResultBase ** p = (ns6__ArrayOfSearchResultBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArrayOfSearchResultBase, sizeof(ns6__ArrayOfSearchResultBase), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Parse(struct soap *soap, ns6__Parse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__Parse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Parse(struct soap *soap, ns6__Parse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Parse);
	if (soap_out_PointerTons6__Parse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__Parse(struct soap *soap, const char *tag, int id, ns6__Parse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Parse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Parse ** SOAP_FMAC4 soap_get_PointerTons6__Parse(struct soap *soap, ns6__Parse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__Parse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__Parse ** SOAP_FMAC4 soap_in_PointerTons6__Parse(struct soap *soap, const char *tag, ns6__Parse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__Parse **)soap_malloc(soap, sizeof(ns6__Parse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__Parse *)soap_instantiate_ns6__Parse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__Parse ** p = (ns6__Parse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Parse, sizeof(ns6__Parse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ArrayOfCategoryCount(struct soap *soap, ns6__ArrayOfCategoryCount *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ArrayOfCategoryCount))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ArrayOfCategoryCount(struct soap *soap, ns6__ArrayOfCategoryCount *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ArrayOfCategoryCount);
	if (soap_out_PointerTons6__ArrayOfCategoryCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ArrayOfCategoryCount(struct soap *soap, const char *tag, int id, ns6__ArrayOfCategoryCount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ArrayOfCategoryCount);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ArrayOfCategoryCount ** SOAP_FMAC4 soap_get_PointerTons6__ArrayOfCategoryCount(struct soap *soap, ns6__ArrayOfCategoryCount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ArrayOfCategoryCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__ArrayOfCategoryCount ** SOAP_FMAC4 soap_in_PointerTons6__ArrayOfCategoryCount(struct soap *soap, const char *tag, ns6__ArrayOfCategoryCount **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ArrayOfCategoryCount **)soap_malloc(soap, sizeof(ns6__ArrayOfCategoryCount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ArrayOfCategoryCount *)soap_instantiate_ns6__ArrayOfCategoryCount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__ArrayOfCategoryCount ** p = (ns6__ArrayOfCategoryCount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArrayOfCategoryCount, sizeof(ns6__ArrayOfCategoryCount), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ArrayOfAvailableFilter(struct soap *soap, ns6__ArrayOfAvailableFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ArrayOfAvailableFilter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ArrayOfAvailableFilter(struct soap *soap, ns6__ArrayOfAvailableFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ArrayOfAvailableFilter);
	if (soap_out_PointerTons6__ArrayOfAvailableFilter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ArrayOfAvailableFilter(struct soap *soap, const char *tag, int id, ns6__ArrayOfAvailableFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ArrayOfAvailableFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ArrayOfAvailableFilter ** SOAP_FMAC4 soap_get_PointerTons6__ArrayOfAvailableFilter(struct soap *soap, ns6__ArrayOfAvailableFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ArrayOfAvailableFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__ArrayOfAvailableFilter ** SOAP_FMAC4 soap_in_PointerTons6__ArrayOfAvailableFilter(struct soap *soap, const char *tag, ns6__ArrayOfAvailableFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ArrayOfAvailableFilter **)soap_malloc(soap, sizeof(ns6__ArrayOfAvailableFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ArrayOfAvailableFilter *)soap_instantiate_ns6__ArrayOfAvailableFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__ArrayOfAvailableFilter ** p = (ns6__ArrayOfAvailableFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArrayOfAvailableFilter, sizeof(ns6__ArrayOfAvailableFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ArrayOfSearchRegion(struct soap *soap, ns6__ArrayOfSearchRegion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ArrayOfSearchRegion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ArrayOfSearchRegion(struct soap *soap, ns6__ArrayOfSearchRegion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ArrayOfSearchRegion);
	if (soap_out_PointerTons6__ArrayOfSearchRegion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ArrayOfSearchRegion(struct soap *soap, const char *tag, int id, ns6__ArrayOfSearchRegion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ArrayOfSearchRegion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ArrayOfSearchRegion ** SOAP_FMAC4 soap_get_PointerTons6__ArrayOfSearchRegion(struct soap *soap, ns6__ArrayOfSearchRegion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ArrayOfSearchRegion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__ArrayOfSearchRegion ** SOAP_FMAC4 soap_in_PointerTons6__ArrayOfSearchRegion(struct soap *soap, const char *tag, ns6__ArrayOfSearchRegion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ArrayOfSearchRegion **)soap_malloc(soap, sizeof(ns6__ArrayOfSearchRegion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ArrayOfSearchRegion *)soap_instantiate_ns6__ArrayOfSearchRegion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__ArrayOfSearchRegion ** p = (ns6__ArrayOfSearchRegion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArrayOfSearchRegion, sizeof(ns6__ArrayOfSearchRegion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__SearchResultSet(struct soap *soap, ns6__SearchResultSet **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__SearchResultSet))
		soap_serialize_PointerTons6__SearchResultSet(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__SearchResultSet(struct soap *soap, ns6__SearchResultSet **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__SearchResultSet);
	if (soap_out_PointerToPointerTons6__SearchResultSet(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons6__SearchResultSet(struct soap *soap, const char *tag, int id, ns6__SearchResultSet **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__SearchResultSet);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons6__SearchResultSet(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__SearchResultSet *** SOAP_FMAC4 soap_get_PointerToPointerTons6__SearchResultSet(struct soap *soap, ns6__SearchResultSet ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons6__SearchResultSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__SearchResultSet *** SOAP_FMAC4 soap_in_PointerToPointerTons6__SearchResultSet(struct soap *soap, const char *tag, ns6__SearchResultSet ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SearchResultSet ***)soap_malloc(soap, sizeof(ns6__SearchResultSet **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons6__SearchResultSet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns6__SearchResultSet ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__SearchResultSet, sizeof(ns6__SearchResultSet *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SearchResultSet(struct soap *soap, ns6__SearchResultSet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__SearchResultSet))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SearchResultSet(struct soap *soap, ns6__SearchResultSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__SearchResultSet);
	if (soap_out_PointerTons6__SearchResultSet(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__SearchResultSet(struct soap *soap, const char *tag, int id, ns6__SearchResultSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SearchResultSet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__SearchResultSet ** SOAP_FMAC4 soap_get_PointerTons6__SearchResultSet(struct soap *soap, ns6__SearchResultSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__SearchResultSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__SearchResultSet ** SOAP_FMAC4 soap_in_PointerTons6__SearchResultSet(struct soap *soap, const char *tag, ns6__SearchResultSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SearchResultSet **)soap_malloc(soap, sizeof(ns6__SearchResultSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__SearchResultSet *)soap_instantiate_ns6__SearchResultSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__SearchResultSet ** p = (ns6__SearchResultSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SearchResultSet, sizeof(ns6__SearchResultSet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__StructuredSearchQuery(struct soap *soap, ns6__StructuredSearchQuery *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__StructuredSearchQuery))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__StructuredSearchQuery(struct soap *soap, ns6__StructuredSearchQuery *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__StructuredSearchQuery);
	if (soap_out_PointerTons6__StructuredSearchQuery(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__StructuredSearchQuery(struct soap *soap, const char *tag, int id, ns6__StructuredSearchQuery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__StructuredSearchQuery);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__StructuredSearchQuery ** SOAP_FMAC4 soap_get_PointerTons6__StructuredSearchQuery(struct soap *soap, ns6__StructuredSearchQuery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__StructuredSearchQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__StructuredSearchQuery ** SOAP_FMAC4 soap_in_PointerTons6__StructuredSearchQuery(struct soap *soap, const char *tag, ns6__StructuredSearchQuery **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__StructuredSearchQuery **)soap_malloc(soap, sizeof(ns6__StructuredSearchQuery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__StructuredSearchQuery *)soap_instantiate_ns6__StructuredSearchQuery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__StructuredSearchQuery ** p = (ns6__StructuredSearchQuery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__StructuredSearchQuery, sizeof(ns6__StructuredSearchQuery), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SortOrder(struct soap *soap, enum ns6__SortOrder *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__SortOrder);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SortOrder(struct soap *soap, enum ns6__SortOrder *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__SortOrder);
	if (soap_out_PointerTons6__SortOrder(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__SortOrder(struct soap *soap, const char *tag, int id, enum ns6__SortOrder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SortOrder);
	if (id < 0)
		return soap->error;
	return soap_out_ns6__SortOrder(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns6__SortOrder ** SOAP_FMAC4 soap_get_PointerTons6__SortOrder(struct soap *soap, enum ns6__SortOrder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__SortOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns6__SortOrder ** SOAP_FMAC4 soap_in_PointerTons6__SortOrder(struct soap *soap, const char *tag, enum ns6__SortOrder **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns6__SortOrder **)soap_malloc(soap, sizeof(enum ns6__SortOrder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns6__SortOrder(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns6__SortOrder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SortOrder, sizeof(enum ns6__SortOrder), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ListingType(struct soap *soap, enum ns6__ListingType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__ListingType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ListingType(struct soap *soap, enum ns6__ListingType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ListingType);
	if (soap_out_PointerTons6__ListingType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ListingType(struct soap *soap, const char *tag, int id, enum ns6__ListingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ListingType);
	if (id < 0)
		return soap->error;
	return soap_out_ns6__ListingType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns6__ListingType ** SOAP_FMAC4 soap_get_PointerTons6__ListingType(struct soap *soap, enum ns6__ListingType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ListingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns6__ListingType ** SOAP_FMAC4 soap_in_PointerTons6__ListingType(struct soap *soap, const char *tag, enum ns6__ListingType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns6__ListingType **)soap_malloc(soap, sizeof(enum ns6__ListingType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns6__ListingType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns6__ListingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ListingType, sizeof(enum ns6__ListingType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__Pushpin(struct soap *soap, ns4__Pushpin **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__Pushpin))
		soap_serialize_PointerTons4__Pushpin(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__Pushpin(struct soap *soap, ns4__Pushpin **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__Pushpin);
	if (soap_out_PointerToPointerTons4__Pushpin(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__Pushpin(struct soap *soap, const char *tag, int id, ns4__Pushpin **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__Pushpin);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__Pushpin(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns4__Pushpin *** SOAP_FMAC4 soap_get_PointerToPointerTons4__Pushpin(struct soap *soap, ns4__Pushpin ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__Pushpin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__Pushpin *** SOAP_FMAC4 soap_in_PointerToPointerTons4__Pushpin(struct soap *soap, const char *tag, ns4__Pushpin ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Pushpin ***)soap_malloc(soap, sizeof(ns4__Pushpin **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__Pushpin(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns4__Pushpin ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__Pushpin, sizeof(ns4__Pushpin *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Pushpin(struct soap *soap, ns4__Pushpin *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Pushpin))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Pushpin(struct soap *soap, ns4__Pushpin *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Pushpin);
	if (soap_out_PointerTons4__Pushpin(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Pushpin(struct soap *soap, const char *tag, int id, ns4__Pushpin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Pushpin);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Pushpin ** SOAP_FMAC4 soap_get_PointerTons4__Pushpin(struct soap *soap, ns4__Pushpin **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Pushpin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__Pushpin ** SOAP_FMAC4 soap_in_PointerTons4__Pushpin(struct soap *soap, const char *tag, ns4__Pushpin **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Pushpin **)soap_malloc(soap, sizeof(ns4__Pushpin *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Pushpin *)soap_instantiate_ns4__Pushpin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Pushpin ** p = (ns4__Pushpin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Pushpin, sizeof(ns4__Pushpin), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__GeocodeResult(struct soap *soap, ns4__GeocodeResult **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__GeocodeResult))
		soap_serialize_PointerTons4__GeocodeResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__GeocodeResult(struct soap *soap, ns4__GeocodeResult **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__GeocodeResult);
	if (soap_out_PointerToPointerTons4__GeocodeResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__GeocodeResult(struct soap *soap, const char *tag, int id, ns4__GeocodeResult **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__GeocodeResult);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__GeocodeResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns4__GeocodeResult *** SOAP_FMAC4 soap_get_PointerToPointerTons4__GeocodeResult(struct soap *soap, ns4__GeocodeResult ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__GeocodeResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__GeocodeResult *** SOAP_FMAC4 soap_in_PointerToPointerTons4__GeocodeResult(struct soap *soap, const char *tag, ns4__GeocodeResult ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__GeocodeResult ***)soap_malloc(soap, sizeof(ns4__GeocodeResult **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__GeocodeResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns4__GeocodeResult ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__GeocodeResult, sizeof(ns4__GeocodeResult *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GeocodeResult(struct soap *soap, ns4__GeocodeResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GeocodeResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GeocodeResult(struct soap *soap, ns4__GeocodeResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GeocodeResult);
	if (soap_out_PointerTons4__GeocodeResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GeocodeResult(struct soap *soap, const char *tag, int id, ns4__GeocodeResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GeocodeResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__GeocodeResult ** SOAP_FMAC4 soap_get_PointerTons4__GeocodeResult(struct soap *soap, ns4__GeocodeResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GeocodeResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__GeocodeResult ** SOAP_FMAC4 soap_in_PointerTons4__GeocodeResult(struct soap *soap, const char *tag, ns4__GeocodeResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__GeocodeResult **)soap_malloc(soap, sizeof(ns4__GeocodeResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__GeocodeResult *)soap_instantiate_ns4__GeocodeResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__GeocodeResult ** p = (ns4__GeocodeResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GeocodeResult, sizeof(ns4__GeocodeResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__GeocodeLocation(struct soap *soap, ns4__GeocodeLocation **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__GeocodeLocation))
		soap_serialize_PointerTons4__GeocodeLocation(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__GeocodeLocation(struct soap *soap, ns4__GeocodeLocation **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__GeocodeLocation);
	if (soap_out_PointerToPointerTons4__GeocodeLocation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__GeocodeLocation(struct soap *soap, const char *tag, int id, ns4__GeocodeLocation **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__GeocodeLocation);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__GeocodeLocation(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns4__GeocodeLocation *** SOAP_FMAC4 soap_get_PointerToPointerTons4__GeocodeLocation(struct soap *soap, ns4__GeocodeLocation ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__GeocodeLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__GeocodeLocation *** SOAP_FMAC4 soap_in_PointerToPointerTons4__GeocodeLocation(struct soap *soap, const char *tag, ns4__GeocodeLocation ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__GeocodeLocation ***)soap_malloc(soap, sizeof(ns4__GeocodeLocation **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__GeocodeLocation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns4__GeocodeLocation ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__GeocodeLocation, sizeof(ns4__GeocodeLocation *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GeocodeLocation(struct soap *soap, ns4__GeocodeLocation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GeocodeLocation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GeocodeLocation(struct soap *soap, ns4__GeocodeLocation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GeocodeLocation);
	if (soap_out_PointerTons4__GeocodeLocation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GeocodeLocation(struct soap *soap, const char *tag, int id, ns4__GeocodeLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GeocodeLocation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__GeocodeLocation ** SOAP_FMAC4 soap_get_PointerTons4__GeocodeLocation(struct soap *soap, ns4__GeocodeLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GeocodeLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__GeocodeLocation ** SOAP_FMAC4 soap_in_PointerTons4__GeocodeLocation(struct soap *soap, const char *tag, ns4__GeocodeLocation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__GeocodeLocation **)soap_malloc(soap, sizeof(ns4__GeocodeLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__GeocodeLocation *)soap_instantiate_ns4__GeocodeLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__GeocodeLocation ** p = (ns4__GeocodeLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GeocodeLocation, sizeof(ns4__GeocodeLocation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ArrayOfstring(struct soap *soap, ns7__ArrayOfstring *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__ArrayOfstring))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ArrayOfstring(struct soap *soap, ns7__ArrayOfstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ArrayOfstring);
	if (soap_out_PointerTons7__ArrayOfstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__ArrayOfstring(struct soap *soap, const char *tag, int id, ns7__ArrayOfstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ArrayOfstring);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ArrayOfstring ** SOAP_FMAC4 soap_get_PointerTons7__ArrayOfstring(struct soap *soap, ns7__ArrayOfstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns7__ArrayOfstring ** SOAP_FMAC4 soap_in_PointerTons7__ArrayOfstring(struct soap *soap, const char *tag, ns7__ArrayOfstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__ArrayOfstring **)soap_malloc(soap, sizeof(ns7__ArrayOfstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__ArrayOfstring *)soap_instantiate_ns7__ArrayOfstring(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns7__ArrayOfstring ** p = (ns7__ArrayOfstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ArrayOfstring, sizeof(ns7__ArrayOfstring), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfGeocodeLocation(struct soap *soap, ns4__ArrayOfGeocodeLocation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfGeocodeLocation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfGeocodeLocation(struct soap *soap, ns4__ArrayOfGeocodeLocation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfGeocodeLocation);
	if (soap_out_PointerTons4__ArrayOfGeocodeLocation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfGeocodeLocation(struct soap *soap, const char *tag, int id, ns4__ArrayOfGeocodeLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfGeocodeLocation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfGeocodeLocation ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfGeocodeLocation(struct soap *soap, ns4__ArrayOfGeocodeLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfGeocodeLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__ArrayOfGeocodeLocation ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfGeocodeLocation(struct soap *soap, const char *tag, ns4__ArrayOfGeocodeLocation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfGeocodeLocation **)soap_malloc(soap, sizeof(ns4__ArrayOfGeocodeLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfGeocodeLocation *)soap_instantiate_ns4__ArrayOfGeocodeLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__ArrayOfGeocodeLocation ** p = (ns4__ArrayOfGeocodeLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfGeocodeLocation, sizeof(ns4__ArrayOfGeocodeLocation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Confidence(struct soap *soap, enum ns4__Confidence *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns4__Confidence);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Confidence(struct soap *soap, enum ns4__Confidence *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Confidence);
	if (soap_out_PointerTons4__Confidence(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Confidence(struct soap *soap, const char *tag, int id, enum ns4__Confidence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Confidence);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__Confidence(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__Confidence ** SOAP_FMAC4 soap_get_PointerTons4__Confidence(struct soap *soap, enum ns4__Confidence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Confidence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns4__Confidence ** SOAP_FMAC4 soap_in_PointerTons4__Confidence(struct soap *soap, const char *tag, enum ns4__Confidence **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__Confidence **)soap_malloc(soap, sizeof(enum ns4__Confidence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__Confidence(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__Confidence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Confidence, sizeof(enum ns4__Confidence), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Rectangle(struct soap *soap, ns4__Rectangle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Rectangle))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Rectangle(struct soap *soap, ns4__Rectangle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Rectangle);
	if (soap_out_PointerTons4__Rectangle(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Rectangle(struct soap *soap, const char *tag, int id, ns4__Rectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Rectangle);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Rectangle ** SOAP_FMAC4 soap_get_PointerTons4__Rectangle(struct soap *soap, ns4__Rectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__Rectangle ** SOAP_FMAC4 soap_in_PointerTons4__Rectangle(struct soap *soap, const char *tag, ns4__Rectangle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Rectangle **)soap_malloc(soap, sizeof(ns4__Rectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Rectangle *)soap_instantiate_ns4__Rectangle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Rectangle ** p = (ns4__Rectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Rectangle, sizeof(ns4__Rectangle), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Address(struct soap *soap, ns4__Address *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Address))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Address(struct soap *soap, ns4__Address *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Address);
	if (soap_out_PointerTons4__Address(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Address(struct soap *soap, const char *tag, int id, ns4__Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Address);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Address ** SOAP_FMAC4 soap_get_PointerTons4__Address(struct soap *soap, ns4__Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__Address ** SOAP_FMAC4 soap_in_PointerTons4__Address(struct soap *soap, const char *tag, ns4__Address **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Address **)soap_malloc(soap, sizeof(ns4__Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Address *)soap_instantiate_ns4__Address(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Address ** p = (ns4__Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Address, sizeof(ns4__Address), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ResponseStatusCode(struct soap *soap, enum ns4__ResponseStatusCode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns4__ResponseStatusCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ResponseStatusCode(struct soap *soap, enum ns4__ResponseStatusCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ResponseStatusCode);
	if (soap_out_PointerTons4__ResponseStatusCode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ResponseStatusCode(struct soap *soap, const char *tag, int id, enum ns4__ResponseStatusCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ResponseStatusCode);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__ResponseStatusCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__ResponseStatusCode ** SOAP_FMAC4 soap_get_PointerTons4__ResponseStatusCode(struct soap *soap, enum ns4__ResponseStatusCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ResponseStatusCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns4__ResponseStatusCode ** SOAP_FMAC4 soap_in_PointerTons4__ResponseStatusCode(struct soap *soap, const char *tag, enum ns4__ResponseStatusCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__ResponseStatusCode **)soap_malloc(soap, sizeof(enum ns4__ResponseStatusCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__ResponseStatusCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__ResponseStatusCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ResponseStatusCode, sizeof(enum ns4__ResponseStatusCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__AuthenticationResultCode(struct soap *soap, enum ns4__AuthenticationResultCode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns4__AuthenticationResultCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__AuthenticationResultCode(struct soap *soap, enum ns4__AuthenticationResultCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__AuthenticationResultCode);
	if (soap_out_PointerTons4__AuthenticationResultCode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__AuthenticationResultCode(struct soap *soap, const char *tag, int id, enum ns4__AuthenticationResultCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__AuthenticationResultCode);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__AuthenticationResultCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__AuthenticationResultCode ** SOAP_FMAC4 soap_get_PointerTons4__AuthenticationResultCode(struct soap *soap, enum ns4__AuthenticationResultCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__AuthenticationResultCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns4__AuthenticationResultCode ** SOAP_FMAC4 soap_in_PointerTons4__AuthenticationResultCode(struct soap *soap, const char *tag, enum ns4__AuthenticationResultCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__AuthenticationResultCode **)soap_malloc(soap, sizeof(enum ns4__AuthenticationResultCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__AuthenticationResultCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__AuthenticationResultCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__AuthenticationResultCode, sizeof(enum ns4__AuthenticationResultCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ResponseSummary(struct soap *soap, ns4__ResponseSummary *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ResponseSummary))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ResponseSummary(struct soap *soap, ns4__ResponseSummary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ResponseSummary);
	if (soap_out_PointerTons4__ResponseSummary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ResponseSummary(struct soap *soap, const char *tag, int id, ns4__ResponseSummary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ResponseSummary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ResponseSummary ** SOAP_FMAC4 soap_get_PointerTons4__ResponseSummary(struct soap *soap, ns4__ResponseSummary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ResponseSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__ResponseSummary ** SOAP_FMAC4 soap_in_PointerTons4__ResponseSummary(struct soap *soap, const char *tag, ns4__ResponseSummary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ResponseSummary **)soap_malloc(soap, sizeof(ns4__ResponseSummary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ResponseSummary *)soap_instantiate_ns4__ResponseSummary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__ResponseSummary ** p = (ns4__ResponseSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ResponseSummary, sizeof(ns4__ResponseSummary), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__FilterExpressionBase(struct soap *soap, ns4__FilterExpressionBase **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__FilterExpressionBase))
		soap_serialize_PointerTons4__FilterExpressionBase(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__FilterExpressionBase(struct soap *soap, ns4__FilterExpressionBase **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__FilterExpressionBase);
	if (soap_out_PointerToPointerTons4__FilterExpressionBase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__FilterExpressionBase(struct soap *soap, const char *tag, int id, ns4__FilterExpressionBase **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__FilterExpressionBase);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__FilterExpressionBase(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns4__FilterExpressionBase *** SOAP_FMAC4 soap_get_PointerToPointerTons4__FilterExpressionBase(struct soap *soap, ns4__FilterExpressionBase ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__FilterExpressionBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__FilterExpressionBase *** SOAP_FMAC4 soap_in_PointerToPointerTons4__FilterExpressionBase(struct soap *soap, const char *tag, ns4__FilterExpressionBase ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__FilterExpressionBase ***)soap_malloc(soap, sizeof(ns4__FilterExpressionBase **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__FilterExpressionBase(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns4__FilterExpressionBase ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__FilterExpressionBase, sizeof(ns4__FilterExpressionBase *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__FilterExpressionBase(struct soap *soap, ns4__FilterExpressionBase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__FilterExpressionBase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__FilterExpressionBase(struct soap *soap, ns4__FilterExpressionBase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__FilterExpressionBase);
	if (soap_out_PointerTons4__FilterExpressionBase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__FilterExpressionBase(struct soap *soap, const char *tag, int id, ns4__FilterExpressionBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__FilterExpressionBase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__FilterExpressionBase ** SOAP_FMAC4 soap_get_PointerTons4__FilterExpressionBase(struct soap *soap, ns4__FilterExpressionBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__FilterExpressionBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__FilterExpressionBase ** SOAP_FMAC4 soap_in_PointerTons4__FilterExpressionBase(struct soap *soap, const char *tag, ns4__FilterExpressionBase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__FilterExpressionBase **)soap_malloc(soap, sizeof(ns4__FilterExpressionBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__FilterExpressionBase *)soap_instantiate_ns4__FilterExpressionBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__FilterExpressionBase ** p = (ns4__FilterExpressionBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__FilterExpressionBase, sizeof(ns4__FilterExpressionBase), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns4__FilterExpressionBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__FilterExpression, sizeof(ns4__FilterExpression), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns4__FilterExpressionBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__FilterExpressionClause, sizeof(ns4__FilterExpressionClause), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__Location(struct soap *soap, ns4__Location **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__Location))
		soap_serialize_PointerTons4__Location(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__Location(struct soap *soap, ns4__Location **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__Location);
	if (soap_out_PointerToPointerTons4__Location(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__Location(struct soap *soap, const char *tag, int id, ns4__Location **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__Location);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__Location(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns4__Location *** SOAP_FMAC4 soap_get_PointerToPointerTons4__Location(struct soap *soap, ns4__Location ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__Location(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__Location *** SOAP_FMAC4 soap_in_PointerToPointerTons4__Location(struct soap *soap, const char *tag, ns4__Location ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Location ***)soap_malloc(soap, sizeof(ns4__Location **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__Location(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns4__Location ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__Location, sizeof(ns4__Location *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Location(struct soap *soap, ns4__Location *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Location))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Location(struct soap *soap, ns4__Location *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Location);
	if (soap_out_PointerTons4__Location(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Location(struct soap *soap, const char *tag, int id, ns4__Location *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Location);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Location ** SOAP_FMAC4 soap_get_PointerTons4__Location(struct soap *soap, ns4__Location **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Location(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__Location ** SOAP_FMAC4 soap_in_PointerTons4__Location(struct soap *soap, const char *tag, ns4__Location **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Location **)soap_malloc(soap, sizeof(ns4__Location *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Location *)soap_instantiate_ns4__Location(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Location ** p = (ns4__Location **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Location, sizeof(ns4__Location), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns4__Location **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__UserLocation, sizeof(ns4__UserLocation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns4__Location **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GeocodeLocation, sizeof(ns4__GeocodeLocation), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__SizeOfint(struct soap *soap, ns4__SizeOfint *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__SizeOfint))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__SizeOfint(struct soap *soap, ns4__SizeOfint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__SizeOfint);
	if (soap_out_PointerTons4__SizeOfint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__SizeOfint(struct soap *soap, const char *tag, int id, ns4__SizeOfint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__SizeOfint);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__SizeOfint ** SOAP_FMAC4 soap_get_PointerTons4__SizeOfint(struct soap *soap, ns4__SizeOfint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__SizeOfint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__SizeOfint ** SOAP_FMAC4 soap_in_PointerTons4__SizeOfint(struct soap *soap, const char *tag, ns4__SizeOfint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__SizeOfint **)soap_malloc(soap, sizeof(ns4__SizeOfint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__SizeOfint *)soap_instantiate_ns4__SizeOfint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__SizeOfint ** p = (ns4__SizeOfint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__SizeOfint, sizeof(ns4__SizeOfint), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ShapeBase(struct soap *soap, ns4__ShapeBase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ShapeBase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ShapeBase(struct soap *soap, ns4__ShapeBase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ShapeBase);
	if (soap_out_PointerTons4__ShapeBase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ShapeBase(struct soap *soap, const char *tag, int id, ns4__ShapeBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ShapeBase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ShapeBase ** SOAP_FMAC4 soap_get_PointerTons4__ShapeBase(struct soap *soap, ns4__ShapeBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ShapeBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__ShapeBase ** SOAP_FMAC4 soap_in_PointerTons4__ShapeBase(struct soap *soap, const char *tag, ns4__ShapeBase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ShapeBase **)soap_malloc(soap, sizeof(ns4__ShapeBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ShapeBase *)soap_instantiate_ns4__ShapeBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__ShapeBase ** p = (ns4__ShapeBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ShapeBase, sizeof(ns4__ShapeBase), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns4__ShapeBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Rectangle, sizeof(ns4__Rectangle), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns4__ShapeBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Circle, sizeof(ns4__Circle), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns4__ShapeBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Polygon, sizeof(ns4__Polygon), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns4__ShapeBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SearchPoint, sizeof(ns6__SearchPoint), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__DistanceUnit(struct soap *soap, enum ns4__DistanceUnit *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns4__DistanceUnit);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__DistanceUnit(struct soap *soap, enum ns4__DistanceUnit *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__DistanceUnit);
	if (soap_out_PointerTons4__DistanceUnit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__DistanceUnit(struct soap *soap, const char *tag, int id, enum ns4__DistanceUnit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__DistanceUnit);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__DistanceUnit(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__DistanceUnit ** SOAP_FMAC4 soap_get_PointerTons4__DistanceUnit(struct soap *soap, enum ns4__DistanceUnit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__DistanceUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns4__DistanceUnit ** SOAP_FMAC4 soap_in_PointerTons4__DistanceUnit(struct soap *soap, const char *tag, enum ns4__DistanceUnit **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__DistanceUnit **)soap_malloc(soap, sizeof(enum ns4__DistanceUnit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__DistanceUnit(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__DistanceUnit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DistanceUnit, sizeof(enum ns4__DistanceUnit), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__DeviceType(struct soap *soap, enum ns4__DeviceType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns4__DeviceType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__DeviceType(struct soap *soap, enum ns4__DeviceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__DeviceType);
	if (soap_out_PointerTons4__DeviceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__DeviceType(struct soap *soap, const char *tag, int id, enum ns4__DeviceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__DeviceType);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__DeviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__DeviceType ** SOAP_FMAC4 soap_get_PointerTons4__DeviceType(struct soap *soap, enum ns4__DeviceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__DeviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns4__DeviceType ** SOAP_FMAC4 soap_in_PointerTons4__DeviceType(struct soap *soap, const char *tag, enum ns4__DeviceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__DeviceType **)soap_malloc(soap, sizeof(enum ns4__DeviceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__DeviceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__DeviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DeviceType, sizeof(enum ns4__DeviceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__UserLocation(struct soap *soap, ns4__UserLocation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__UserLocation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__UserLocation(struct soap *soap, ns4__UserLocation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__UserLocation);
	if (soap_out_PointerTons4__UserLocation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__UserLocation(struct soap *soap, const char *tag, int id, ns4__UserLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__UserLocation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__UserLocation ** SOAP_FMAC4 soap_get_PointerTons4__UserLocation(struct soap *soap, ns4__UserLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__UserLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__UserLocation ** SOAP_FMAC4 soap_in_PointerTons4__UserLocation(struct soap *soap, const char *tag, ns4__UserLocation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__UserLocation **)soap_malloc(soap, sizeof(ns4__UserLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__UserLocation *)soap_instantiate_ns4__UserLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__UserLocation ** p = (ns4__UserLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__UserLocation, sizeof(ns4__UserLocation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Heading(struct soap *soap, ns4__Heading *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Heading))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Heading(struct soap *soap, ns4__Heading *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Heading);
	if (soap_out_PointerTons4__Heading(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Heading(struct soap *soap, const char *tag, int id, ns4__Heading *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Heading);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Heading ** SOAP_FMAC4 soap_get_PointerTons4__Heading(struct soap *soap, ns4__Heading **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Heading(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__Heading ** SOAP_FMAC4 soap_in_PointerTons4__Heading(struct soap *soap, const char *tag, ns4__Heading **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Heading **)soap_malloc(soap, sizeof(ns4__Heading *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Heading *)soap_instantiate_ns4__Heading(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Heading ** p = (ns4__Heading **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Heading, sizeof(ns4__Heading), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__UserProfile(struct soap *soap, ns4__UserProfile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__UserProfile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__UserProfile(struct soap *soap, ns4__UserProfile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__UserProfile);
	if (soap_out_PointerTons4__UserProfile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__UserProfile(struct soap *soap, const char *tag, int id, ns4__UserProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__UserProfile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__UserProfile ** SOAP_FMAC4 soap_get_PointerTons4__UserProfile(struct soap *soap, ns4__UserProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__UserProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__UserProfile ** SOAP_FMAC4 soap_in_PointerTons4__UserProfile(struct soap *soap, const char *tag, ns4__UserProfile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__UserProfile **)soap_malloc(soap, sizeof(ns4__UserProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__UserProfile *)soap_instantiate_ns4__UserProfile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__UserProfile ** p = (ns4__UserProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__UserProfile, sizeof(ns4__UserProfile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ExecutionOptions(struct soap *soap, ns4__ExecutionOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ExecutionOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ExecutionOptions(struct soap *soap, ns4__ExecutionOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ExecutionOptions);
	if (soap_out_PointerTons4__ExecutionOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ExecutionOptions(struct soap *soap, const char *tag, int id, ns4__ExecutionOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ExecutionOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ExecutionOptions ** SOAP_FMAC4 soap_get_PointerTons4__ExecutionOptions(struct soap *soap, ns4__ExecutionOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ExecutionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__ExecutionOptions ** SOAP_FMAC4 soap_in_PointerTons4__ExecutionOptions(struct soap *soap, const char *tag, ns4__ExecutionOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ExecutionOptions **)soap_malloc(soap, sizeof(ns4__ExecutionOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ExecutionOptions *)soap_instantiate_ns4__ExecutionOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__ExecutionOptions ** p = (ns4__ExecutionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ExecutionOptions, sizeof(ns4__ExecutionOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Credentials(struct soap *soap, ns4__Credentials *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__Credentials))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Credentials(struct soap *soap, ns4__Credentials *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Credentials);
	if (soap_out_PointerTons4__Credentials(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__Credentials(struct soap *soap, const char *tag, int id, ns4__Credentials *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Credentials);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Credentials ** SOAP_FMAC4 soap_get_PointerTons4__Credentials(struct soap *soap, ns4__Credentials **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__Credentials(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__Credentials ** SOAP_FMAC4 soap_in_PointerTons4__Credentials(struct soap *soap, const char *tag, ns4__Credentials **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__Credentials **)soap_malloc(soap, sizeof(ns4__Credentials *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__Credentials *)soap_instantiate_ns4__Credentials(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__Credentials ** p = (ns4__Credentials **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Credentials, sizeof(ns4__Credentials), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SearchResponse(struct soap *soap, ns6__SearchResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__SearchResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SearchResponse(struct soap *soap, ns6__SearchResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__SearchResponse);
	if (soap_out_PointerTons6__SearchResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__SearchResponse(struct soap *soap, const char *tag, int id, ns6__SearchResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SearchResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__SearchResponse ** SOAP_FMAC4 soap_get_PointerTons6__SearchResponse(struct soap *soap, ns6__SearchResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__SearchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__SearchResponse ** SOAP_FMAC4 soap_in_PointerTons6__SearchResponse(struct soap *soap, const char *tag, ns6__SearchResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SearchResponse **)soap_malloc(soap, sizeof(ns6__SearchResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__SearchResponse *)soap_instantiate_ns6__SearchResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__SearchResponse ** p = (ns6__SearchResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SearchResponse, sizeof(ns6__SearchResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SearchRequest(struct soap *soap, ns6__SearchRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__SearchRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SearchRequest(struct soap *soap, ns6__SearchRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__SearchRequest);
	if (soap_out_PointerTons6__SearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__SearchRequest(struct soap *soap, const char *tag, int id, ns6__SearchRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SearchRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__SearchRequest ** SOAP_FMAC4 soap_get_PointerTons6__SearchRequest(struct soap *soap, ns6__SearchRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__SearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__SearchRequest ** SOAP_FMAC4 soap_in_PointerTons6__SearchRequest(struct soap *soap, const char *tag, ns6__SearchRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SearchRequest **)soap_malloc(soap, sizeof(ns6__SearchRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__SearchRequest *)soap_instantiate_ns6__SearchRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__SearchRequest ** p = (ns6__SearchRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SearchRequest, sizeof(ns6__SearchRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TokenSpecification(struct soap *soap, ns1__TokenSpecification *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TokenSpecification))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TokenSpecification(struct soap *soap, ns1__TokenSpecification *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TokenSpecification);
	if (soap_out_PointerTons1__TokenSpecification(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TokenSpecification(struct soap *soap, const char *tag, int id, ns1__TokenSpecification *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TokenSpecification);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TokenSpecification ** SOAP_FMAC4 soap_get_PointerTons1__TokenSpecification(struct soap *soap, ns1__TokenSpecification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TokenSpecification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__TokenSpecification ** SOAP_FMAC4 soap_in_PointerTons1__TokenSpecification(struct soap *soap, const char *tag, ns1__TokenSpecification **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TokenSpecification **)soap_malloc(soap, sizeof(ns1__TokenSpecification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TokenSpecification *)soap_instantiate_ns1__TokenSpecification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__TokenSpecification ** p = (ns1__TokenSpecification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TokenSpecification, sizeof(ns1__TokenSpecification), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDouble(struct soap *soap, ns1__ArrayOfDouble *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfDouble))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDouble(struct soap *soap, ns1__ArrayOfDouble *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfDouble);
	if (soap_out_PointerTons1__ArrayOfDouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDouble(struct soap *soap, const char *tag, int id, ns1__ArrayOfDouble *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfDouble);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfDouble ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDouble(struct soap *soap, ns1__ArrayOfDouble **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ArrayOfDouble ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDouble(struct soap *soap, const char *tag, ns1__ArrayOfDouble **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfDouble **)soap_malloc(soap, sizeof(ns1__ArrayOfDouble *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfDouble *)soap_instantiate_ns1__ArrayOfDouble(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfDouble ** p = (ns1__ArrayOfDouble **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDouble, sizeof(ns1__ArrayOfDouble), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfLatLong(struct soap *soap, ns1__ArrayOfLatLong *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfLatLong))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfLatLong(struct soap *soap, ns1__ArrayOfLatLong *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfLatLong);
	if (soap_out_PointerTons1__ArrayOfLatLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfLatLong(struct soap *soap, const char *tag, int id, ns1__ArrayOfLatLong *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfLatLong);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfLatLong ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfLatLong(struct soap *soap, ns1__ArrayOfLatLong **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfLatLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ArrayOfLatLong ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfLatLong(struct soap *soap, const char *tag, ns1__ArrayOfLatLong **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfLatLong **)soap_malloc(soap, sizeof(ns1__ArrayOfLatLong *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfLatLong *)soap_instantiate_ns1__ArrayOfLatLong(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfLatLong ** p = (ns1__ArrayOfLatLong **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfLatLong, sizeof(ns1__ArrayOfLatLong), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDataSource(struct soap *soap, ns1__ArrayOfDataSource *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfDataSource))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDataSource(struct soap *soap, ns1__ArrayOfDataSource *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfDataSource);
	if (soap_out_PointerTons1__ArrayOfDataSource(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDataSource(struct soap *soap, const char *tag, int id, ns1__ArrayOfDataSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfDataSource);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfDataSource ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDataSource(struct soap *soap, ns1__ArrayOfDataSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDataSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ArrayOfDataSource ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDataSource(struct soap *soap, const char *tag, ns1__ArrayOfDataSource **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfDataSource **)soap_malloc(soap, sizeof(ns1__ArrayOfDataSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfDataSource *)soap_instantiate_ns1__ArrayOfDataSource(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfDataSource ** p = (ns1__ArrayOfDataSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDataSource, sizeof(ns1__ArrayOfDataSource), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfString))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfString);
	if (soap_out_PointerTons1__ArrayOfString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, int id, ns1__ArrayOfString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfString);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfString ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ArrayOfString ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfString **)soap_malloc(soap, sizeof(ns1__ArrayOfString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfString *)soap_instantiate_ns1__ArrayOfString(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfString ** p = (ns1__ArrayOfString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfEntityType(struct soap *soap, ns1__ArrayOfEntityType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfEntityType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfEntityType(struct soap *soap, ns1__ArrayOfEntityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfEntityType);
	if (soap_out_PointerTons1__ArrayOfEntityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfEntityType(struct soap *soap, const char *tag, int id, ns1__ArrayOfEntityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfEntityType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfEntityType ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfEntityType(struct soap *soap, ns1__ArrayOfEntityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfEntityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ArrayOfEntityType ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfEntityType(struct soap *soap, const char *tag, ns1__ArrayOfEntityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfEntityType **)soap_malloc(soap, sizeof(ns1__ArrayOfEntityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfEntityType *)soap_instantiate_ns1__ArrayOfEntityType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfEntityType ** p = (ns1__ArrayOfEntityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfEntityType, sizeof(ns1__ArrayOfEntityType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfCountryRegionInfo(struct soap *soap, ns1__ArrayOfCountryRegionInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfCountryRegionInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfCountryRegionInfo(struct soap *soap, ns1__ArrayOfCountryRegionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfCountryRegionInfo);
	if (soap_out_PointerTons1__ArrayOfCountryRegionInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfCountryRegionInfo(struct soap *soap, const char *tag, int id, ns1__ArrayOfCountryRegionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfCountryRegionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfCountryRegionInfo ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfCountryRegionInfo(struct soap *soap, ns1__ArrayOfCountryRegionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfCountryRegionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ArrayOfCountryRegionInfo ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfCountryRegionInfo(struct soap *soap, const char *tag, ns1__ArrayOfCountryRegionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfCountryRegionInfo **)soap_malloc(soap, sizeof(ns1__ArrayOfCountryRegionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfCountryRegionInfo *)soap_instantiate_ns1__ArrayOfCountryRegionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfCountryRegionInfo ** p = (ns1__ArrayOfCountryRegionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfCountryRegionInfo, sizeof(ns1__ArrayOfCountryRegionInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfVersionInfo(struct soap *soap, ns1__ArrayOfVersionInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfVersionInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfVersionInfo(struct soap *soap, ns1__ArrayOfVersionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfVersionInfo);
	if (soap_out_PointerTons1__ArrayOfVersionInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfVersionInfo(struct soap *soap, const char *tag, int id, ns1__ArrayOfVersionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfVersionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfVersionInfo ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfVersionInfo(struct soap *soap, ns1__ArrayOfVersionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ArrayOfVersionInfo ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfVersionInfo(struct soap *soap, const char *tag, ns1__ArrayOfVersionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfVersionInfo **)soap_malloc(soap, sizeof(ns1__ArrayOfVersionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfVersionInfo *)soap_instantiate_ns1__ArrayOfVersionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfVersionInfo ** p = (ns1__ArrayOfVersionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfVersionInfo, sizeof(ns1__ArrayOfVersionInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__LatLong(struct soap *soap, ns1__LatLong **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__LatLong))
		soap_serialize_PointerTons1__LatLong(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__LatLong(struct soap *soap, ns1__LatLong **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__LatLong);
	if (soap_out_PointerToPointerTons1__LatLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__LatLong(struct soap *soap, const char *tag, int id, ns1__LatLong **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__LatLong);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__LatLong(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__LatLong *** SOAP_FMAC4 soap_get_PointerToPointerTons1__LatLong(struct soap *soap, ns1__LatLong ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__LatLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__LatLong *** SOAP_FMAC4 soap_in_PointerToPointerTons1__LatLong(struct soap *soap, const char *tag, ns1__LatLong ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LatLong ***)soap_malloc(soap, sizeof(ns1__LatLong **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__LatLong(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__LatLong ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__LatLong, sizeof(ns1__LatLong *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfInt(struct soap *soap, ns1__ArrayOfInt *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfInt))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfInt(struct soap *soap, ns1__ArrayOfInt *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfInt);
	if (soap_out_PointerTons1__ArrayOfInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfInt(struct soap *soap, const char *tag, int id, ns1__ArrayOfInt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfInt);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfInt ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfInt(struct soap *soap, ns1__ArrayOfInt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ArrayOfInt ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfInt(struct soap *soap, const char *tag, ns1__ArrayOfInt **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfInt **)soap_malloc(soap, sizeof(ns1__ArrayOfInt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfInt *)soap_instantiate_ns1__ArrayOfInt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfInt ** p = (ns1__ArrayOfInt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfInt, sizeof(ns1__ArrayOfInt), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__DataSource(struct soap *soap, ns1__DataSource **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__DataSource))
		soap_serialize_PointerTons1__DataSource(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__DataSource(struct soap *soap, ns1__DataSource **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__DataSource);
	if (soap_out_PointerToPointerTons1__DataSource(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__DataSource(struct soap *soap, const char *tag, int id, ns1__DataSource **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__DataSource);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__DataSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__DataSource *** SOAP_FMAC4 soap_get_PointerToPointerTons1__DataSource(struct soap *soap, ns1__DataSource ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__DataSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__DataSource *** SOAP_FMAC4 soap_in_PointerToPointerTons1__DataSource(struct soap *soap, const char *tag, ns1__DataSource ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DataSource ***)soap_malloc(soap, sizeof(ns1__DataSource **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__DataSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__DataSource ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__DataSource, sizeof(ns1__DataSource *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DataSource(struct soap *soap, ns1__DataSource *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DataSource))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DataSource(struct soap *soap, ns1__DataSource *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DataSource);
	if (soap_out_PointerTons1__DataSource(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DataSource(struct soap *soap, const char *tag, int id, ns1__DataSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DataSource);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__DataSource ** SOAP_FMAC4 soap_get_PointerTons1__DataSource(struct soap *soap, ns1__DataSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DataSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__DataSource ** SOAP_FMAC4 soap_in_PointerTons1__DataSource(struct soap *soap, const char *tag, ns1__DataSource **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DataSource **)soap_malloc(soap, sizeof(ns1__DataSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DataSource *)soap_instantiate_ns1__DataSource(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__DataSource ** p = (ns1__DataSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DataSource, sizeof(ns1__DataSource), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__EntityProperty(struct soap *soap, ns1__EntityProperty **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__EntityProperty))
		soap_serialize_PointerTons1__EntityProperty(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__EntityProperty(struct soap *soap, ns1__EntityProperty **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__EntityProperty);
	if (soap_out_PointerToPointerTons1__EntityProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__EntityProperty(struct soap *soap, const char *tag, int id, ns1__EntityProperty **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__EntityProperty);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__EntityProperty(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__EntityProperty *** SOAP_FMAC4 soap_get_PointerToPointerTons1__EntityProperty(struct soap *soap, ns1__EntityProperty ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__EntityProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__EntityProperty *** SOAP_FMAC4 soap_in_PointerToPointerTons1__EntityProperty(struct soap *soap, const char *tag, ns1__EntityProperty ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EntityProperty ***)soap_malloc(soap, sizeof(ns1__EntityProperty **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__EntityProperty(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__EntityProperty ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__EntityProperty, sizeof(ns1__EntityProperty *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EntityProperty(struct soap *soap, ns1__EntityProperty *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EntityProperty))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EntityProperty(struct soap *soap, ns1__EntityProperty *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__EntityProperty);
	if (soap_out_PointerTons1__EntityProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EntityProperty(struct soap *soap, const char *tag, int id, ns1__EntityProperty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EntityProperty);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__EntityProperty ** SOAP_FMAC4 soap_get_PointerTons1__EntityProperty(struct soap *soap, ns1__EntityProperty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EntityProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__EntityProperty ** SOAP_FMAC4 soap_in_PointerTons1__EntityProperty(struct soap *soap, const char *tag, ns1__EntityProperty **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EntityProperty **)soap_malloc(soap, sizeof(ns1__EntityProperty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__EntityProperty *)soap_instantiate_ns1__EntityProperty(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__EntityProperty ** p = (ns1__EntityProperty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EntityProperty, sizeof(ns1__EntityProperty), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfEntityProperty(struct soap *soap, ns1__ArrayOfEntityProperty *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfEntityProperty))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfEntityProperty(struct soap *soap, ns1__ArrayOfEntityProperty *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfEntityProperty);
	if (soap_out_PointerTons1__ArrayOfEntityProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfEntityProperty(struct soap *soap, const char *tag, int id, ns1__ArrayOfEntityProperty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfEntityProperty);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfEntityProperty ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfEntityProperty(struct soap *soap, ns1__ArrayOfEntityProperty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfEntityProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ArrayOfEntityProperty ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfEntityProperty(struct soap *soap, const char *tag, ns1__ArrayOfEntityProperty **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfEntityProperty **)soap_malloc(soap, sizeof(ns1__ArrayOfEntityProperty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfEntityProperty *)soap_instantiate_ns1__ArrayOfEntityProperty(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfEntityProperty ** p = (ns1__ArrayOfEntityProperty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfEntityProperty, sizeof(ns1__ArrayOfEntityProperty), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__EntityType(struct soap *soap, ns1__EntityType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__EntityType))
		soap_serialize_PointerTons1__EntityType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__EntityType(struct soap *soap, ns1__EntityType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__EntityType);
	if (soap_out_PointerToPointerTons1__EntityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__EntityType(struct soap *soap, const char *tag, int id, ns1__EntityType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__EntityType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__EntityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__EntityType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__EntityType(struct soap *soap, ns1__EntityType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__EntityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__EntityType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__EntityType(struct soap *soap, const char *tag, ns1__EntityType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EntityType ***)soap_malloc(soap, sizeof(ns1__EntityType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__EntityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__EntityType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__EntityType, sizeof(ns1__EntityType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EntityType(struct soap *soap, ns1__EntityType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EntityType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EntityType(struct soap *soap, ns1__EntityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__EntityType);
	if (soap_out_PointerTons1__EntityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EntityType(struct soap *soap, const char *tag, int id, ns1__EntityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EntityType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__EntityType ** SOAP_FMAC4 soap_get_PointerTons1__EntityType(struct soap *soap, ns1__EntityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EntityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__EntityType ** SOAP_FMAC4 soap_in_PointerTons1__EntityType(struct soap *soap, const char *tag, ns1__EntityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EntityType **)soap_malloc(soap, sizeof(ns1__EntityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__EntityType *)soap_instantiate_ns1__EntityType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__EntityType ** p = (ns1__EntityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EntityType, sizeof(ns1__EntityType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LatLong(struct soap *soap, ns1__LatLong *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LatLong))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LatLong(struct soap *soap, ns1__LatLong *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__LatLong);
	if (soap_out_PointerTons1__LatLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LatLong(struct soap *soap, const char *tag, int id, ns1__LatLong *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LatLong);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__LatLong ** SOAP_FMAC4 soap_get_PointerTons1__LatLong(struct soap *soap, ns1__LatLong **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LatLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__LatLong ** SOAP_FMAC4 soap_in_PointerTons1__LatLong(struct soap *soap, const char *tag, ns1__LatLong **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LatLong **)soap_malloc(soap, sizeof(ns1__LatLong *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LatLong *)soap_instantiate_ns1__LatLong(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__LatLong ** p = (ns1__LatLong **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LatLong, sizeof(ns1__LatLong), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CountryRegionInfo(struct soap *soap, ns1__CountryRegionInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CountryRegionInfo))
		soap_serialize_PointerTons1__CountryRegionInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CountryRegionInfo(struct soap *soap, ns1__CountryRegionInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CountryRegionInfo);
	if (soap_out_PointerToPointerTons1__CountryRegionInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CountryRegionInfo(struct soap *soap, const char *tag, int id, ns1__CountryRegionInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CountryRegionInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CountryRegionInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CountryRegionInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CountryRegionInfo(struct soap *soap, ns1__CountryRegionInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CountryRegionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__CountryRegionInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CountryRegionInfo(struct soap *soap, const char *tag, ns1__CountryRegionInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CountryRegionInfo ***)soap_malloc(soap, sizeof(ns1__CountryRegionInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CountryRegionInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CountryRegionInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CountryRegionInfo, sizeof(ns1__CountryRegionInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CountryRegionInfo(struct soap *soap, ns1__CountryRegionInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CountryRegionInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CountryRegionInfo(struct soap *soap, ns1__CountryRegionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CountryRegionInfo);
	if (soap_out_PointerTons1__CountryRegionInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CountryRegionInfo(struct soap *soap, const char *tag, int id, ns1__CountryRegionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CountryRegionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CountryRegionInfo ** SOAP_FMAC4 soap_get_PointerTons1__CountryRegionInfo(struct soap *soap, ns1__CountryRegionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CountryRegionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__CountryRegionInfo ** SOAP_FMAC4 soap_in_PointerTons1__CountryRegionInfo(struct soap *soap, const char *tag, ns1__CountryRegionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CountryRegionInfo **)soap_malloc(soap, sizeof(ns1__CountryRegionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CountryRegionInfo *)soap_instantiate_ns1__CountryRegionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CountryRegionInfo ** p = (ns1__CountryRegionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CountryRegionInfo, sizeof(ns1__CountryRegionInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CountryRegionContext(struct soap *soap, ns1__CountryRegionContext *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CountryRegionContext))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CountryRegionContext(struct soap *soap, ns1__CountryRegionContext *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CountryRegionContext);
	if (soap_out_PointerTons1__CountryRegionContext(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CountryRegionContext(struct soap *soap, const char *tag, int id, ns1__CountryRegionContext *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CountryRegionContext);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CountryRegionContext ** SOAP_FMAC4 soap_get_PointerTons1__CountryRegionContext(struct soap *soap, ns1__CountryRegionContext **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CountryRegionContext(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__CountryRegionContext ** SOAP_FMAC4 soap_in_PointerTons1__CountryRegionContext(struct soap *soap, const char *tag, ns1__CountryRegionContext **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CountryRegionContext **)soap_malloc(soap, sizeof(ns1__CountryRegionContext *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CountryRegionContext *)soap_instantiate_ns1__CountryRegionContext(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CountryRegionContext ** p = (ns1__CountryRegionContext **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CountryRegionContext, sizeof(ns1__CountryRegionContext), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CultureInfo(struct soap *soap, ns1__CultureInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CultureInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CultureInfo(struct soap *soap, ns1__CultureInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CultureInfo);
	if (soap_out_PointerTons1__CultureInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CultureInfo(struct soap *soap, const char *tag, int id, ns1__CultureInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CultureInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CultureInfo ** SOAP_FMAC4 soap_get_PointerTons1__CultureInfo(struct soap *soap, ns1__CultureInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CultureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__CultureInfo ** SOAP_FMAC4 soap_in_PointerTons1__CultureInfo(struct soap *soap, const char *tag, ns1__CultureInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CultureInfo **)soap_malloc(soap, sizeof(ns1__CultureInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CultureInfo *)soap_instantiate_ns1__CultureInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CultureInfo ** p = (ns1__CultureInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CultureInfo, sizeof(ns1__CultureInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__VersionInfo(struct soap *soap, ns1__VersionInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__VersionInfo))
		soap_serialize_PointerTons1__VersionInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__VersionInfo(struct soap *soap, ns1__VersionInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__VersionInfo);
	if (soap_out_PointerToPointerTons1__VersionInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__VersionInfo(struct soap *soap, const char *tag, int id, ns1__VersionInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__VersionInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__VersionInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__VersionInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons1__VersionInfo(struct soap *soap, ns1__VersionInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__VersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__VersionInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons1__VersionInfo(struct soap *soap, const char *tag, ns1__VersionInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__VersionInfo ***)soap_malloc(soap, sizeof(ns1__VersionInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__VersionInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__VersionInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__VersionInfo, sizeof(ns1__VersionInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__VersionInfo(struct soap *soap, ns1__VersionInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__VersionInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__VersionInfo(struct soap *soap, ns1__VersionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__VersionInfo);
	if (soap_out_PointerTons1__VersionInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__VersionInfo(struct soap *soap, const char *tag, int id, ns1__VersionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__VersionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__VersionInfo ** SOAP_FMAC4 soap_get_PointerTons1__VersionInfo(struct soap *soap, ns1__VersionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__VersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__VersionInfo ** SOAP_FMAC4 soap_in_PointerTons1__VersionInfo(struct soap *soap, const char *tag, ns1__VersionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__VersionInfo **)soap_malloc(soap, sizeof(ns1__VersionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__VersionInfo *)soap_instantiate_ns1__VersionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__VersionInfo ** p = (ns1__VersionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VersionInfo, sizeof(ns1__VersionInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__guid(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__guid);
	if (soap_out_ns5__guid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__guid(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns5__guid);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns5__guid(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__guid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns5__guid(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns5__guid, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__duration(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__duration);
	if (soap_out_ns5__duration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__duration(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns5__duration);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns5__duration(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns5__duration(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns5__duration, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__duration);
	if (soap_out_xsd__duration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__duration, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__decimal, 1, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
